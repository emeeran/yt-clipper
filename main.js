/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/styles.ts
var MODAL_STYLES, INPUT_STYLES;
var init_styles = __esm({
  "src/styles.ts"() {
    "use strict";
    MODAL_STYLES = {
      zIndex: "10000",
      display: "flex",
      header: {
        marginBottom: "15px",
        color: "var(--text-accent)"
      },
      message: {
        marginBottom: "20px",
        lineHeight: "1.5"
      },
      buttonContainer: {
        marginTop: "20px",
        display: "flex",
        gap: "10px",
        justifyContent: "flex-end"
      },
      button: {
        padding: "8px 16px",
        minWidth: "100px"
      }
    };
    INPUT_STYLES = {
      width: "100%",
      marginTop: "8px",
      padding: "8px",
      border: "1px solid var(--background-modifier-border)",
      borderRadius: "4px"
    };
  }
});

// src/dom.ts
var DOMUtils;
var init_dom = __esm({
  "src/dom.ts"() {
    "use strict";
    init_styles();
    DOMUtils = class _DOMUtils {
      /**
       * Apply styles to an HTML element
       */
      static applyStyles(element, styles) {
        Object.assign(element.style, styles);
      }
      /**
       * Create a standardized button container
       */
      static createButtonContainer(parent) {
        const container = parent.createDiv();
        this.applyStyles(container, MODAL_STYLES.buttonContainer);
        return container;
      }
      /**
       * Create a styled button with consistent appearance
       */
      static createStyledButton(container, text, isPrimary = false, onClick) {
        const button = container.createEl("button", { text });
        if (isPrimary) {
          button.classList.add("mod-cta");
        }
        this.applyStyles(button, MODAL_STYLES.button);
        if (onClick) {
          button.addEventListener("click", onClick);
        }
        return button;
      }
      /**
       * Create a styled input field
       */
      static createStyledInput(container, type, placeholder, value = "") {
        const input = container.createEl("input", {
          type,
          placeholder,
          value
        });
        this.applyStyles(input, INPUT_STYLES);
        return input;
      }
      /**
       * Set up modal base styling for consistency
       */
      static setupModalStyling(modalEl) {
        this.applyStyles(modalEl, {
          zIndex: MODAL_STYLES.zIndex,
          display: MODAL_STYLES.display
        });
      }
      /**
       * Create a header element with consistent styling
       */
      static createModalHeader(parent, text) {
        const header = parent.createEl("h2", { text });
        this.applyStyles(header, MODAL_STYLES.header);
        return header;
      }
      /**
       * Create a message paragraph with consistent styling
       */
      static createModalMessage(parent, text) {
        const message = parent.createEl("p");
        message.setText(text);
        this.applyStyles(message, MODAL_STYLES.message);
        return message;
      }
      /**
       * Set up keyboard event handlers for modals
       */
      static setupModalKeyHandlers(element, onEnter, onEscape) {
        element.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            e.preventDefault();
            e.stopPropagation();
            onEnter();
          }
          if (e.key === "Escape" && onEscape) {
            e.preventDefault();
            e.stopPropagation();
            onEscape();
          }
        });
      }
      // Instance methods implementing interface
      applyStyles(element, styles) {
        _DOMUtils.applyStyles(element, styles);
      }
      createButtonContainer(parent) {
        return _DOMUtils.createButtonContainer(parent);
      }
      createStyledButton(container, text, isPrimary = false, onClick) {
        return _DOMUtils.createStyledButton(container, text, isPrimary, onClick);
      }
    };
  }
});

// src/api.ts
var API_ENDPOINTS, AI_MODELS, PROVIDER_MODEL_OPTIONS, PROVIDER_MODEL_LIST_URLS, PROVIDER_MODEL_REGEX, API_LIMITS, TIMEOUTS;
var init_api = __esm({
  "src/api.ts"() {
    "use strict";
    API_ENDPOINTS = {
      GEMINI: "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-pro:generateContent",
      GROQ: "https://api.groq.com/openai/v1/chat/completions",
      YOUTUBE_OEMBED: "https://www.youtube.com/oembed",
      CORS_PROXY: "https://api.allorigins.win/raw"
    };
    AI_MODELS = {
      GEMINI: "gemini-2.5-pro",
      // Set Gemini model to gemini-2.5-pro
      GROQ: "llama-3.3-70b-versatile"
    };
    PROVIDER_MODEL_OPTIONS = {
      "Google Gemini": [
        // Gemini 2.5 series (latest, all support multimodal video analysis)
        { name: "gemini-2.5-pro", supportsAudioVideo: true },
        { name: "gemini-2.5-pro-tts", supportsAudioVideo: true },
        { name: "gemini-2.5-flash", supportsAudioVideo: true },
        { name: "gemini-2.5-flash-lite", supportsAudioVideo: true },
        // Gemini 2.0 series (video support via native API, but no explicit multimodal flag)
        { name: "gemini-2.0-pro", supportsAudioVideo: true },
        { name: "gemini-2.0-flash" },
        { name: "gemini-2.0-flash-lite" },
        // Gemini 1.5 series (available, supports video via File API)
        { name: "gemini-1.5-pro" },
        { name: "gemini-1.5-flash" }
      ],
      "Groq": [
        // Latest models (Nov 2024 - Nov 2025)
        // Note: Groq models prioritize speed/text; for multimodal video, Gemini is recommended
        { name: "llama-4-maverick-17b-128e-instruct" },
        { name: "llama-4-scout-17b-16e-instruct" },
        // Llama 3.x series
        { name: "llama-3.3-70b-versatile" },
        { name: "llama-3.1-8b-instant" }
      ]
    };
    PROVIDER_MODEL_LIST_URLS = {
      "Google Gemini": "https://developers.generativeai.google/models",
      "Groq": "https://groq.com"
    };
    PROVIDER_MODEL_REGEX = {
      "Google Gemini": /gemini[-_\.]?\d+(?:\.\d+)?(?:-[a-z0-9\-]+)?/gi,
      "Groq": /llama[-_\.]?\d+(?:\.\d+)?(?:-[a-z0-9\-]+)?/gi
    };
    API_LIMITS = {
      MAX_TOKENS: 8e3,
      // Increased from 2000 to handle comprehensive tutorials
      TEMPERATURE: 0.7,
      DESCRIPTION_MAX_LENGTH: 1e3,
      TITLE_MAX_LENGTH: 100
    };
    TIMEOUTS = {
      FILE_CREATION_WAIT: 300,
      MODAL_DELAY: 100,
      FALLBACK_MODAL_CHECK: 500,
      FOCUS_DELAY: 150,
      REPAINT_DELAY: 50
    };
  }
});

// src/confirmation-modal.ts
var confirmation_modal_exports = {};
__export(confirmation_modal_exports, {
  ConfirmationModal: () => ConfirmationModal
});
var ConfirmationModal;
var init_confirmation_modal = __esm({
  "src/confirmation-modal.ts"() {
    "use strict";
    init_base_modal();
    ConfirmationModal = class extends BaseModal {
      constructor(app, options) {
        super(app);
        this.options = options;
        this.result = false;
      }
      onOpen() {
        this.createModalContent();
        this.setupEventHandlers();
        this.focusConfirmButton();
      }
      /**
       * Create modal content with accessible structure
       */
      createModalContent() {
        const header = this.createHeader(this.options.title);
        header.setAttribute("id", "confirmation-modal-title");
        const messageContainer = this.contentEl.createDiv("confirmation-message");
        messageContainer.setAttribute("id", "confirmation-modal-description");
        messageContainer.textContent = this.options.message;
        const buttonContainer = this.createButtonContainer();
        buttonContainer.style.marginTop = "20px";
        const confirmText = this.options.confirmText || "Confirm";
        const cancelText = this.options.cancelText || "Cancel";
        const isDangerous = this.options.isDangerous || false;
        if (isDangerous) {
          this.cancelButton = this.createButton(
            buttonContainer,
            cancelText,
            false,
            () => this.handleCancel()
          );
          this.cancelButton.setAttribute("aria-label", `Cancel: ${cancelText}`);
          this.confirmButton = this.createButton(
            buttonContainer,
            confirmText,
            true,
            () => this.handleConfirm()
          );
          this.confirmButton.setAttribute("aria-label", `Confirm: ${confirmText}`);
        } else {
          this.confirmButton = this.createButton(
            buttonContainer,
            confirmText,
            true,
            () => this.handleConfirm()
          );
          this.confirmButton.setAttribute("aria-label", `Confirm: ${confirmText}`);
          this.cancelButton = this.createButton(
            buttonContainer,
            cancelText,
            false,
            () => this.handleCancel()
          );
          this.cancelButton.setAttribute("aria-label", `Cancel: ${cancelText}`);
        }
        this.contentEl.setAttribute("aria-labelledby", "confirmation-modal-title");
        this.contentEl.setAttribute("aria-describedby", "confirmation-modal-description");
        this.contentEl.setAttribute("role", "alertdialog");
      }
      /**
       * Set up keyboard event handlers (Enter to confirm, Escape to cancel)
       */
      setupEventHandlers() {
        this.scope.register([], "Enter", () => {
          this.handleConfirm();
          return false;
        });
        this.scope.register([], "Escape", () => {
          this.handleCancel();
          return false;
        });
      }
      /**
       * Focus the confirm button by default
       */
      focusConfirmButton() {
        if (this.confirmButton) {
          setTimeout(() => {
            this.confirmButton.focus();
          }, 50);
        }
      }
      /**
       * Handle confirmation (Confirm button or Enter key)
       */
      handleConfirm() {
        this.result = true;
        if (this.resolver) {
          this.resolver(true);
        }
        this.close();
      }
      /**
       * Handle cancellation (Cancel button or Escape key)
       */
      handleCancel() {
        this.result = false;
        if (this.resolver) {
          this.resolver(false);
        }
        this.close();
      }
      /**
       * Open modal and wait for user response
       * Returns promise that resolves to true if confirmed, false if cancelled
       */
      openAndWait() {
        return new Promise((resolve) => {
          this.resolver = resolve;
          this.open();
        });
      }
      /**
       * Get the result (synchronous if already closed)
       */
      getResult() {
        return this.result;
      }
    };
  }
});

// src/base-modal.ts
var import_obsidian4, MODAL_CSS_CLASSES, BaseModal;
var init_base_modal = __esm({
  "src/base-modal.ts"() {
    "use strict";
    import_obsidian4 = require("obsidian");
    init_dom();
    init_styles();
    init_api();
    MODAL_CSS_CLASSES = {
      modal: "ytc-modal",
      header: "ytc-modal-header",
      content: "ytc-modal-content",
      button: "ytc-modal-button",
      input: "ytc-modal-input"
    };
    BaseModal = class extends import_obsidian4.Modal {
      constructor(app) {
        super(app);
        this.events = {};
        this.isDisposed = false;
        this.setupModalStyling();
        this.setupConflictPrevention();
      }
      /**
       * Set up base modal styling for consistency
       */
      setupModalStyling() {
        DOMUtils.setupModalStyling(this.modalEl);
        this.modalEl.addClass(MODAL_CSS_CLASSES.modal);
        this.contentEl.addClass(MODAL_CSS_CLASSES.content);
      }
      /**
       * Set up conflict prevention measures
       */
      setupConflictPrevention() {
        this.modalEl.setAttribute("data-plugin", "youtube-clipper");
        this.modalEl.style.zIndex = "9999";
      }
      /**
       * Create standardized modal header with conflict prevention
       */
      createHeader(text) {
        const header = DOMUtils.createModalHeader(this.contentEl, text);
        header.addClass(MODAL_CSS_CLASSES.header);
        return header;
      }
      /**
       * Create standardized modal message
       */
      createMessage(text) {
        return DOMUtils.createModalMessage(this.contentEl, text);
      }
      /**
       * Create standardized button container
       */
      createButtonContainer() {
        return DOMUtils.createButtonContainer(this.contentEl);
      }
      /**
      * Create standardized button with conflict prevention and accessibility
      */
      createButton(container, text, isPrimary = false, onClick) {
        const button = DOMUtils.createStyledButton(container, text, isPrimary, onClick);
        button.addClass(MODAL_CSS_CLASSES.button);
        button.setAttribute("data-plugin", "youtube-clipper");
        button.setAttribute("role", "button");
        if (!button.getAttribute("aria-label")) {
          button.setAttribute("aria-label", text);
        }
        return button;
      }
      /**
       * Create standardized input with conflict prevention and accessibility
       */
      createInput(container, type, placeholder) {
        const input = container.createEl("input", {
          type,
          placeholder
        });
        DOMUtils.applyStyles(input, INPUT_STYLES);
        input.addClass(MODAL_CSS_CLASSES.input);
        input.setAttribute("data-plugin", "youtube-clipper");
        if (placeholder) {
          input.setAttribute("aria-label", placeholder);
        }
        return input;
      }
      /**
       * Set up keyboard event handlers
       */
      setupKeyHandlers(onEnter, onEscape) {
        const wrappedOnEnter = async () => {
          try {
            await onEnter();
          } catch (error) {
            console.error("Enter key handler error:", error);
          }
        };
        const wrappedOnEscape = onEscape ? async () => {
          try {
            await onEscape();
          } catch (error) {
            console.error("Escape key handler error:", error);
          }
        } : void 0;
        DOMUtils.setupModalKeyHandlers(this.contentEl, wrappedOnEnter, wrappedOnEscape);
      }
      /**
       * Focus element with delay for better UX
       */
      focusElement(element, delay = TIMEOUTS.FOCUS_DELAY) {
        setTimeout(() => {
          element.focus();
        }, delay);
      }
      /**
       * Set up event handlers
       */
      setEvents(events) {
        this.events = events;
      }
      /**
       * Show custom styled confirmation dialog before closing
       * This uses our custom ConfirmationModal instead of the native browser confirm()
       * for better accessibility and UX.
       * 
       * Note: This is now synchronous for backwards compatibility with existing callers,
       * but returns a boolean immediately. For async confirmation with proper modal,
       * use showConfirmationModal() instead.
       */
      confirmClose(message) {
        return confirm(message);
      }
      /**
       * Show a custom accessible confirmation modal and wait for user response.
       * Preferred method for confirmation dialogs (async, fully accessible).
       */
      async showConfirmationModal(title, message, confirmText = "Confirm", cancelText = "Cancel", isDangerous = false) {
        const { ConfirmationModal: ConfirmationModal2 } = await Promise.resolve().then(() => (init_confirmation_modal(), confirmation_modal_exports));
        const modal = new ConfirmationModal2(this.app, {
          title,
          message,
          confirmText,
          cancelText,
          isDangerous
        });
        return modal.openAndWait();
      }
      /**
       * Force modal visibility (for stubborn modals)
       */
      forceVisible() {
        setTimeout(() => {
          DOMUtils.setupModalStyling(this.modalEl);
        }, TIMEOUTS.REPAINT_DELAY);
      }
      /**
       * Clean up on close with proper disposal
       */
      onClose() {
        if (this.isDisposed) {
          return;
        }
        console.log("[youtube-clipper] Cleaning up modal");
        this.isDisposed = true;
        const { contentEl } = this;
        contentEl.empty();
        this.modalEl.removeClass(MODAL_CSS_CLASSES.modal);
        this.modalEl.removeAttribute("data-plugin");
        console.log("[youtube-clipper] Modal cleanup complete");
      }
    };
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => YoutubeClipperPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian8 = require("obsidian");

// src/conflict-prevention.ts
var ConflictPrevention = class {
  /**
   * Check if another plugin might be conflicting
   */
  static checkForPotentialConflicts() {
    const warnings = [];
    const suspiciousElements = [
      'div[data-plugin="web-clipper"]',
      ".web-clipper-modal",
      ".clipper-button",
      '[id*="clipper"]',
      '[class*="clip"]'
    ];
    suspiciousElements.forEach((selector) => {
      const elements = document.querySelectorAll(selector);
      if (elements.length > 0) {
        warnings.push(`Detected potential plugin conflict: ${selector}`);
      }
    });
    return warnings;
  }
  /**
   * Add conflict prevention attributes to an element
   */
  static markElement(element, type) {
    element.setAttribute("data-plugin", this.PLUGIN_ID);
    element.setAttribute("data-ytc-type", type);
    element.addClass(`${this.CSS_PREFIX}-${type}`);
  }
  /**
   * Remove conflict prevention attributes
   */
  static unmarkElement(element) {
    element.removeAttribute("data-plugin");
    element.removeAttribute("data-ytc-type");
    const classes = Array.from(element.classList);
    classes.forEach((className) => {
      if (className.startsWith(this.CSS_PREFIX)) {
        element.removeClass(className);
      }
    });
  }
  /**
   * Create a namespaced ID to prevent conflicts
   */
  static createUniqueId(base) {
    return `${this.CSS_PREFIX}-${base}-${Date.now()}`;
  }
  /**
   * Clean up all plugin elements from DOM
   */
  static cleanupAllElements() {
    const elements = document.querySelectorAll(`[data-plugin="${this.PLUGIN_ID}"]`);
    elements.forEach((element) => {
      if (element instanceof HTMLElement) {
        this.unmarkElement(element);
      }
    });
  }
  /**
   * Get safe storage key with namespace
   */
  static getStorageKey(key) {
    return `${this.PLUGIN_ID}-${key}`;
  }
  /**
   * Log plugin activity with namespace
   */
  static log(message, level = "info") {
    const timestamp = (/* @__PURE__ */ new Date()).toISOString();
    const logMessage = `[${this.PLUGIN_ID}] ${timestamp} - ${message}`;
    switch (level) {
      case "warn":
        console.warn(logMessage);
        break;
      case "error":
        console.error(logMessage);
        break;
      default:
        console.log(logMessage);
    }
  }
  /**
   * Check if plugin is safe to operate
   */
  static isSafeToOperate() {
    const conflicts = this.checkForPotentialConflicts();
    if (conflicts.length > 0) {
      this.log(`Potential conflicts detected: ${conflicts.join(", ")}`, "warn");
      return false;
    }
    return true;
  }
  /**
   * Wrap async operations with conflict checking
   */
  static async safeOperation(operation, operationName) {
    if (!this.isSafeToOperate()) {
      this.log(`Skipping ${operationName} due to potential conflicts`, "warn");
      return null;
    }
    try {
      this.log(`Starting ${operationName}`);
      const result = await operation();
      this.log(`Completed ${operationName}`);
      return result;
    } catch (error) {
      this.log(`Error in ${operationName}: ${error}`, "error");
      throw error;
    }
  }
};
ConflictPrevention.PLUGIN_ID = "youtube-clipper";
ConflictPrevention.CSS_PREFIX = "ytc";

// src/messages.ts
var MESSAGES = {
  PROCESSING: "Processing YouTube video...",
  SUCCESS: (title) => `Successfully processed: ${title}`,
  OPENED_FILE: (filename) => `Opened: ${filename}`,
  ERRORS: {
    INVALID_URL: "Invalid YouTube URL. Please provide a valid YouTube video URL (e.g., https://www.youtube.com/watch?v=VIDEO_ID)",
    MISSING_API_KEYS: "No valid Gemini or Groq API key configured. Please set one in plugin settings.",
    GEMINI_INVALID_KEY: "Gemini API key is invalid or missing. Please check your key.",
    GROQ_MODEL_NOT_FOUND: "Groq API error: Model not found or you do not have access. Please check your API key and model name.",
    FETCH_VIDEO_DATA: (status) => `Failed to fetch video metadata: ${status}`,
    SAVE_FILE: (message) => `Failed to save file: ${message}`,
    AI_PROCESSING: (message) => `AI processing failed: ${message}`,
    FILE_NOT_EXISTS: "File no longer exists",
    COULD_NOT_OPEN: (message) => `Could not open file: ${message}`,
    ENTER_URL: "Please enter a YouTube URL",
    VIDEO_ID_EXTRACTION: "Could not extract video ID from URL. Please check the URL format.",
    NETWORK_ERROR: "Network error occurred. Please check your internet connection and try again.",
    // Quota and billing errors
    QUOTA_EXCEEDED: (provider) => `${provider} API quota exceeded. Please check your plan and billing details, or try again later.`,
    RATE_LIMITED: (provider) => `${provider} API rate limit reached. Please wait a moment and try again.`,
    BILLING_REQUIRED: (provider) => `${provider} requires a paid plan. Please check your billing settings.`,
    CREDIT_EXHAUSTED: (provider) => `${provider} API credits exhausted. Please top up your account or upgrade your plan.`
  },
  WARNINGS: {
    CORS_RESTRICTIONS: "Description not available due to CORS restrictions",
    EXTRACTION_FAILED: "Description extraction failed",
    AUTO_EXTRACTION: "Video description could not be extracted automatically."
  },
  MODALS: {
    YOUTUBE_PROCESSED: "YouTube Video Processed",
    CONFIRM_OPEN: (filename) => `Successfully processed YouTube video and saved as "${filename}". Would you like to open the note now?`,
    CLOSE_CONFIRMATION: "Close without opening the note?",
    PROCESS_VIDEO: "Process YouTube Video",
    YES_OPEN: "Yes, open note",
    NO_THANKS: "No, thanks",
    CANCEL: "Cancel",
    PROCESS: "Process"
  },
  PLACEHOLDERS: {
    YOUTUBE_URL: "https://www.youtube.com/watch?v=...",
    GEMINI_KEY: "AIza...",
    GROQ_KEY: "gsk_...",
    OUTPUT_PATH: "YouTube/Processed Videos"
  }
};

// src/validation.ts
var ValidationUtils = class {
  /**
   * Clean and normalize YouTube URL
   */
  static cleanYouTubeUrl(url) {
    if (!url || typeof url !== "string") {
      return "";
    }
    let cleanUrl = url.trim();
    cleanUrl = cleanUrl.replace(/[\u200B-\u200D\uFEFF]/g, "");
    if (!cleanUrl.startsWith("http://") && !cleanUrl.startsWith("https://")) {
      cleanUrl = "https://" + cleanUrl;
    }
    if (cleanUrl.startsWith("http://youtube.com") || cleanUrl.startsWith("http://www.youtube.com")) {
      cleanUrl = cleanUrl.replace("http://", "https://");
    }
    return cleanUrl;
  }
  /**
   * Extract YouTube video ID from URL (memoized for performance)
   * Enhanced extraction with better error handling
   */
  static extractVideoId(url) {
    if (!url || typeof url !== "string")
      return null;
    if (this.URL_CACHE.has(url)) {
      return this.URL_CACHE.get(url);
    }
    const cleanUrl = this.cleanYouTubeUrl(url);
    let result = null;
    let match = cleanUrl.match(this.URL_PATTERNS[0]);
    if ((match == null ? void 0 : match[1]) && this.VIDEO_ID_REGEX.test(match[1])) {
      result = match[1];
    } else {
      for (let i = 1; i < this.URL_PATTERNS.length && !result; i++) {
        match = cleanUrl.match(this.URL_PATTERNS[i]);
        if ((match == null ? void 0 : match[1]) && this.VIDEO_ID_REGEX.test(match[1])) {
          result = match[1];
        }
      }
    }
    if (this.URL_CACHE.size > 100) {
      this.URL_CACHE.clear();
    }
    this.URL_CACHE.set(url, result);
    if (!result) {
      console.warn("Failed to extract video ID from URL:", url);
    }
    return result;
  }
  /**
   * Validate YouTube URL format
   */
  static isValidYouTubeUrl(url) {
    return this.extractVideoId(url) !== null;
  }
  /**
   * Sanitize filename for file system compatibility
   */
  static sanitizeFilename(filename, maxLength = 100) {
    return filename.replace(/[<>:"/\\|?*]/g, "").replace(/\s+/g, " ").trim().substring(0, maxLength);
  }
  /**
   * Validate API key format
   */
  static isValidAPIKey(key, provider) {
    if (!key || typeof key !== "string") {
      return false;
    }
    switch (provider) {
      case "gemini":
        return key.startsWith("AIza") && key.length > 10;
      case "groq":
        return key.startsWith("gsk_") && key.length > 10;
      default:
        return false;
    }
  }
  /**
   * Validate settings configuration
   */
  static validateSettings(settings) {
    const errors = [];
    const usingEnv = Boolean(settings.useEnvironmentVariables);
    const hasDirectKey = this.isNonEmptyString(settings.geminiApiKey) || this.isNonEmptyString(settings.groqApiKey);
    if (!hasDirectKey && !usingEnv) {
      errors.push(MESSAGES.ERRORS.MISSING_API_KEYS);
    }
    if (this.isNonEmptyString(settings.geminiApiKey) && !this.isValidAPIKey(settings.geminiApiKey, "gemini")) {
      errors.push("Invalid Gemini API key format");
    }
    if (this.isNonEmptyString(settings.groqApiKey) && !this.isValidAPIKey(settings.groqApiKey, "groq")) {
      errors.push("Invalid Groq API key format");
    }
    if (usingEnv && !this.isNonEmptyString(settings.environmentPrefix)) {
      errors.push("Environment variable prefix is required when using environment variables");
    }
    if (!settings.outputPath || typeof settings.outputPath !== "string") {
      errors.push("Output path is required");
    }
    return {
      isValid: errors.length === 0,
      errors
    };
  }
  /**
   * Validate file path
   */
  static isValidPath(path) {
    return typeof path === "string" && path.trim().length > 0;
  }
  /**
   * Validate that a string is not empty
   */
  static isNonEmptyString(value) {
    return typeof value === "string" && value.trim().length > 0;
  }
  /**
   * Truncate text to specified length with ellipsis
   */
  static truncateText(text, maxLength) {
    if (text.length <= maxLength) {
      return text;
    }
    return text.substring(0, maxLength - 3) + "...";
  }
  /**
   * Clean HTML entities and escape sequences from text
   */
  static cleanText(text) {
    return text.replace(/\\n/g, "\n").replace(/\\"/g, '"').replace(/\\'/g, "'").replace(
      /\\u([0-9a-fA-F]{4})/g,
      (match, code) => String.fromCharCode(parseInt(code, 16))
    );
  }
};
/**
 * YouTube URL patterns for validation (ordered by frequency for performance)
 * Enhanced patterns to handle various YouTube URL formats
 */
ValidationUtils.URL_PATTERNS = [
  // Standard youtube.com/watch?v= format (most common)
  /(?:https?:\/\/)?(?:www\.)?youtube\.com\/watch\?v=([a-zA-Z0-9_-]{11})(?:&.*)?$/,
  // youtu.be short format (second most common)
  /(?:https?:\/\/)?(?:www\.)?youtu\.be\/([a-zA-Z0-9_-]{11})(?:\?.*)?$/,
  // youtube.com/embed format
  /(?:https?:\/\/)?(?:www\.)?youtube\.com\/embed\/([a-zA-Z0-9_-]{11})(?:\?.*)?$/,
  // youtube.com/v format
  /(?:https?:\/\/)?(?:www\.)?youtube\.com\/v\/([a-zA-Z0-9_-]{11})(?:\?.*)?$/,
  // Mobile youtube.com format
  /(?:https?:\/\/)?(?:m\.)?youtube\.com\/watch\?v=([a-zA-Z0-9_-]{11})(?:&.*)?$/
];
// Memoized regex for video ID validation (hot path optimization)
ValidationUtils.VIDEO_ID_REGEX = /^[a-zA-Z0-9_-]{11}$/;
ValidationUtils.URL_CACHE = /* @__PURE__ */ new Map();

// src/services/error-handler.ts
var import_obsidian = require("obsidian");
var ErrorHandler = class _ErrorHandler {
  /**
   * Handle errors with consistent logging and user feedback
   */
  static handle(error, context, showNotice = true) {
    const errorMessage = `${context}: ${error.message}`;
    console.error(errorMessage, error);
    if (showNotice) {
      new import_obsidian.Notice(`Error: ${error.message}`);
    }
  }
  /**
   * Execute an operation with automatic error handling
   */
  static async withErrorHandling(operation, context, showNotice = true) {
    try {
      return await operation();
    } catch (error) {
      this.handle(error, context, showNotice);
      return null;
    }
  }
  /**
   * Execute a synchronous operation with error handling
   */
  static withSyncErrorHandling(operation, context, showNotice = true) {
    try {
      return operation();
    } catch (error) {
      this.handle(error, context, showNotice);
      return null;
    }
  }
  /**
   * Create a standardized error for API responses
   */
  static createAPIError(provider, status, statusText, details) {
    const message = `${provider} API error: ${status} ${statusText}${details ? `. ${details}` : ""}`;
    return new Error(message);
  }
  /**
   * Handle API response errors with consistent format
   */
  static async handleAPIError(response, provider, fallbackMessage) {
    var _a;
    let errorDetails = fallbackMessage || "";
    try {
      const errorData = await response.json();
      errorDetails = ((_a = errorData.error) == null ? void 0 : _a.message) || errorData.message || fallbackMessage || "";
    } catch (e) {
    }
    throw this.createAPIError(provider, response.status, response.statusText, errorDetails);
  }
  /**
   * Validate required configuration and throw descriptive errors
   */
  static validateConfiguration(config, requiredFields) {
    const missing = requiredFields.filter((field) => !config[field]);
    if (missing.length > 0) {
      throw new Error(`Missing required configuration: ${missing.join(", ")}`);
    }
  }
  /**
   * Create a user-friendly error message for common scenarios
   */
  static createUserFriendlyError(error, operation) {
    const message = `Failed to ${operation}: ${error.message}`;
    return new Error(message);
  }
  /**
   * Handle API quota and billing errors with specific user guidance
   */
  static handleQuotaError(error, provider) {
    const errorMessage = error.message.toLowerCase();
    let userMessage = "";
    let showRetryAction = false;
    if (errorMessage.includes("quota") || errorMessage.includes("limit") || errorMessage.includes("exceeded")) {
      if (errorMessage.includes("rate") || errorMessage.includes("too many requests")) {
        userMessage = MESSAGES.ERRORS.RATE_LIMITED(provider);
        showRetryAction = true;
      } else if (errorMessage.includes("billing") || errorMessage.includes("payment")) {
        userMessage = MESSAGES.ERRORS.BILLING_REQUIRED(provider);
      } else if (errorMessage.includes("credit") || errorMessage.includes("balance")) {
        userMessage = MESSAGES.ERRORS.CREDIT_EXHAUSTED(provider);
      } else {
        userMessage = MESSAGES.ERRORS.QUOTA_EXCEEDED(provider);
        showRetryAction = true;
      }
    } else {
      userMessage = MESSAGES.ERRORS.QUOTA_EXCEEDED(provider);
    }
    console.error(`Quota Error [${provider}]: ${error.message}`, error);
    if (showRetryAction) {
      const noticeWithAction = new import_obsidian.Notice(userMessage, 0);
      setTimeout(() => {
        const noticeEl = noticeWithAction.noticeEl;
        const retryButton = noticeEl.createEl("button", {
          text: "Retry",
          cls: "mod-cta"
        });
        retryButton.style.marginLeft = "10px";
        retryButton.onclick = () => {
          noticeWithAction.hide();
          window.dispatchEvent(new CustomEvent("yt-clipper-retry-processing"));
        };
      }, 100);
    } else {
      new import_obsidian.Notice(userMessage, 8e3);
    }
  }
  /**
   * Detect if an error is quota/billing related
   */
  static isQuotaError(error) {
    const errorMessage = error.message.toLowerCase();
    const quotaKeywords = [
      "quota",
      "limit",
      "exceeded",
      "rate",
      "billing",
      "payment",
      "credit",
      "balance",
      "insufficient",
      "429",
      "usage"
    ];
    return quotaKeywords.some((keyword) => errorMessage.includes(keyword));
  }
  /**
   * Get provider name from error or use default
   */
  static extractProviderName(error, defaultProvider = "AI Service") {
    const errorMessage = error.message.toLowerCase();
    if (errorMessage.includes("gemini") || errorMessage.includes("google")) {
      return "Google Gemini";
    } else if (errorMessage.includes("groq")) {
      return "Groq";
    } else if (errorMessage.includes("openai")) {
      return "OpenAI";
    }
    return defaultProvider;
  }
  /**
   * Enhanced error handling with quota detection
   */
  static handleEnhanced(error, context, showNotice = true) {
    if (this.isQuotaError(error)) {
      const provider = this.extractProviderName(error);
      this.handleQuotaError(error, provider);
      return;
    }
    this.handle(error, context, showNotice);
  }
  // Instance methods implementing interface
  handle(error, context, showNotice = true) {
    _ErrorHandler.handle(error, context, showNotice);
  }
  async withErrorHandling(operation, context) {
    return _ErrorHandler.withErrorHandling(operation, context);
  }
};

// src/services/logger.ts
var LogLevel = /* @__PURE__ */ ((LogLevel2) => {
  LogLevel2[LogLevel2["DEBUG"] = 0] = "DEBUG";
  LogLevel2[LogLevel2["INFO"] = 1] = "INFO";
  LogLevel2[LogLevel2["WARN"] = 2] = "WARN";
  LogLevel2[LogLevel2["ERROR"] = 3] = "ERROR";
  LogLevel2[LogLevel2["SILENT"] = 4] = "SILENT";
  return LogLevel2;
})(LogLevel || {});
var Logger = class _Logger {
  constructor(config = {}) {
    this.logs = [];
    this.config = {
      level: 1 /* INFO */,
      enableConsole: true,
      enableFile: false,
      maxLogEntries: 1e3,
      enableTimestamps: true,
      ...config
    };
  }
  static getInstance(config) {
    if (!_Logger.instance) {
      _Logger.instance = new _Logger(config);
    }
    return _Logger.instance;
  }
  shouldLog(level) {
    return level >= this.config.level;
  }
  formatMessage(entry) {
    const levelStr = LogLevel[entry.level].padEnd(5);
    const timestamp = this.config.enableTimestamps ? `[${entry.timestamp.toISOString()}] ` : "";
    const context = entry.context ? ` [${entry.context}]` : "";
    const data = entry.data ? ` ${JSON.stringify(entry.data)}` : "";
    return `${timestamp}${levelStr}${context} ${entry.message}${data}`;
  }
  addLogEntry(level, message, context, data) {
    if (!this.shouldLog(level))
      return;
    const entry = {
      timestamp: /* @__PURE__ */ new Date(),
      level,
      message,
      context,
      data
    };
    this.logs.push(entry);
    if (this.logs.length > this.config.maxLogEntries) {
      this.logs = this.logs.slice(-this.config.maxLogEntries);
    }
    if (this.config.enableConsole) {
      const formattedMessage = this.formatMessage(entry);
      switch (level) {
        case 0 /* DEBUG */:
          console.debug(formattedMessage);
          break;
        case 1 /* INFO */:
          console.info(formattedMessage);
          break;
        case 2 /* WARN */:
          console.warn(formattedMessage);
          break;
        case 3 /* ERROR */:
          console.error(formattedMessage);
          break;
      }
    }
  }
  debug(message, context, data) {
    this.addLogEntry(0 /* DEBUG */, message, context, data);
  }
  info(message, context, data) {
    this.addLogEntry(1 /* INFO */, message, context, data);
  }
  warn(message, context, data) {
    this.addLogEntry(2 /* WARN */, message, context, data);
  }
  error(message, context, data) {
    this.addLogEntry(3 /* ERROR */, message, context, data);
  }
  getLogs(level, context) {
    let filteredLogs = this.logs;
    if (level !== void 0) {
      filteredLogs = filteredLogs.filter((log) => log.level === level);
    }
    if (context) {
      filteredLogs = filteredLogs.filter((log) => log.context === context);
    }
    return filteredLogs;
  }
  clearLogs() {
    this.logs = [];
  }
  setLevel(level) {
    this.config.level = level;
  }
  getConfig() {
    return { ...this.config };
  }
  updateConfig(config) {
    this.config = { ...this.config, ...config };
  }
  // Convenience methods for common contexts
  plugin(message, data) {
    this.info(message, "Plugin", data);
  }
  aiService(message, data) {
    this.info(message, "AIService", data);
  }
  videoService(message, data) {
    this.info(message, "VideoService", data);
  }
  fileService(message, data) {
    this.info(message, "FileService", data);
  }
  modal(message, data) {
    this.info(message, "Modal", data);
  }
  performance(message, data) {
    this.debug(message, "Performance", data);
  }
};
var logger = Logger.getInstance();

// src/services/url-handler.ts
var import_obsidian2 = require("obsidian");
var UrlHandler = class {
  constructor(app, settings, onUrlDetected, config = {
    noteMarker: "<!-- ytc-extension:youtube-clipper -->",
    urlHandlerDelay: 500,
    maxHandledFiles: 100,
    tempFileAgeThreshold: 5e3
  }) {
    this.app = app;
    this.settings = settings;
    this.onUrlDetected = onUrlDetected;
    this.config = config;
    this.handledTempFiles = /* @__PURE__ */ new Set();
    this.pendingUrls = /* @__PURE__ */ new Map();
  }
  /**
   * Check if a file is a temporary YouTube clipper file
   */
  isTempFile(file, content) {
    try {
      if (content && content.includes(this.config.noteMarker)) {
        logger.debug("File identified as temp file via marker", "UrlHandler", {
          filePath: file.path,
          hasMarker: true
        });
        return true;
      }
      if (file.name && file.name.startsWith("YouTube Clip -")) {
        logger.debug("File identified as temp file via name", "UrlHandler", {
          filePath: file.path,
          fileName: file.name
        });
        return true;
      }
      const trimmedContent = content.trim();
      const lines = trimmedContent.split("\n").filter((line) => line.trim().length > 0);
      const isUrlOnly = lines.length === 1 && ValidationUtils.isValidYouTubeUrl(lines[0]);
      if (isUrlOnly && content.length < 200) {
        const fileAge = Date.now() - file.stat.ctime;
        const isInOutputPath = file.path.includes(this.settings.outputPath);
        if (fileAge < this.config.tempFileAgeThreshold && !isInOutputPath) {
          logger.debug("File identified as temp file via content analysis", "UrlHandler", {
            filePath: file.path,
            fileAge,
            isInOutputPath,
            contentLength: content.length
          });
          return true;
        }
      }
      return false;
    } catch (error) {
      logger.error("Error checking if file is temp file", "UrlHandler", {
        filePath: file.path,
        error: error instanceof Error ? error.message : String(error)
      });
      return false;
    }
  }
  /**
   * Extract YouTube URL from file content
   */
  extractUrl(content) {
    try {
      if (content && content.includes(this.config.noteMarker)) {
        const url = content.replace(this.config.noteMarker, "").trim();
        return ValidationUtils.isValidYouTubeUrl(url) ? url : null;
      }
      const trimmed = content.trim();
      const ytRegex = /(https?:\/\/(?:www\.)?youtube\.com\/watch\?v=[A-Za-z0-9_-]{6,}|https?:\/\/(?:www\.)?youtu\.be\/[A-Za-z0-9_-]{6,})/i;
      const match = trimmed.match(ytRegex);
      if (match && match[1]) {
        const url = match[1].trim();
        return ValidationUtils.isValidYouTubeUrl(url) ? url : null;
      }
      return null;
    } catch (error) {
      logger.error("Error extracting URL from content", "UrlHandler", {
        error: error instanceof Error ? error.message : String(error),
        contentLength: content.length
      });
      return null;
    }
  }
  /**
   * Safely handle detected URL with deduplication and debouncing
   */
  handleUrlSafely(result) {
    logger.info("URL detected, processing safely", "UrlHandler", {
      url: result.url,
      source: result.source,
      filePath: result.filePath
    });
    if (result.file && result.content && !this.isTempFile(result.file, result.content)) {
      logger.warn("URL rejected - not in temp file", "UrlHandler", {
        url: result.url,
        filePath: result.filePath
      });
      return;
    }
    if (this.handledTempFiles.has(result.url)) {
      logger.debug("URL already handled, skipping", "UrlHandler", { url: result.url });
      return;
    }
    if (this.pendingUrls.has(result.url)) {
      logger.debug("Cancelling pending handler for URL", "UrlHandler", { url: result.url });
      clearTimeout(this.pendingUrls.get(result.url));
    }
    this.handledTempFiles.add(result.url);
    if (result.filePath) {
      this.handledTempFiles.add(result.filePath);
    }
    const timeout = setTimeout(() => {
      logger.info("Processing URL after debounce", "UrlHandler", { url: result.url });
      this.onUrlDetected(result);
      this.pendingUrls.delete(result.url);
      this.cleanupHandledFiles();
    }, this.config.urlHandlerDelay);
    this.pendingUrls.set(result.url, timeout);
  }
  /**
   * Clean up old handled file entries to prevent memory leaks
   */
  cleanupHandledFiles() {
    if (this.handledTempFiles.size > this.config.maxHandledFiles) {
      const entries = Array.from(this.handledTempFiles);
      this.handledTempFiles.clear();
      entries.slice(-Math.floor(this.config.maxHandledFiles / 2)).forEach((entry) => {
        this.handledTempFiles.add(entry);
      });
      logger.debug("Cleaned up handled temp files", "UrlHandler", {
        oldSize: entries.length,
        newSize: this.handledTempFiles.size
      });
    }
  }
  /**
   * Handle file creation event
   */
  async handleFileCreate(file) {
    try {
      if (!(file instanceof import_obsidian2.TFile))
        return;
      const content = await this.app.vault.read(file);
      if (!this.isTempFile(file, content)) {
        logger.debug("Ignoring non-temp file in create handler", "UrlHandler", {
          filePath: file.path
        });
        return;
      }
      const url = this.extractUrl(content);
      if (!url) {
        logger.debug("No URL extracted from temp file", "UrlHandler", {
          filePath: file.path
        });
        return;
      }
      const result = {
        url,
        source: "create",
        filePath: file.path,
        file,
        content
      };
      logger.info("CREATE EVENT - detected temp note", "UrlHandler", result);
      this.handleUrlSafely(result);
    } catch (error) {
      logger.error("Error handling file create", "UrlHandler", {
        filePath: file.path,
        error: error instanceof Error ? error.message : String(error)
      });
    }
  }
  /**
   * Handle active leaf change event
   */
  async handleActiveLeafChange() {
    try {
      const file = this.app.workspace.getActiveFile();
      if (!file)
        return;
      if (!("stat" in file) || !("basename" in file) || !("extension" in file)) {
        return;
      }
      if (this.handledTempFiles.has(file.path))
        return;
      const content = await this.app.vault.read(file);
      if (!this.isTempFile(file, content)) {
        logger.debug("Ignoring non-temp file in active leaf handler", "UrlHandler", {
          filePath: file.path
        });
        return;
      }
      const url = this.extractUrl(content);
      if (!url) {
        logger.debug("No URL extracted from temp file in active leaf", "UrlHandler", {
          filePath: file.path
        });
        return;
      }
      const result = {
        url,
        source: "active-leaf",
        filePath: file.path,
        file,
        content
      };
      logger.info("ACTIVE-LEAF-CHANGE EVENT - detected temp note", "UrlHandler", result);
      this.handleUrlSafely(result);
    } catch (error) {
      logger.error("Error handling active leaf change", "UrlHandler", {
        error: error instanceof Error ? error.message : String(error)
      });
    }
  }
  /**
   * Handle protocol handler invocation
   */
  handleProtocol(params) {
    try {
      const url = params.url || params.content || params.path || "";
      if (url && ValidationUtils.isValidYouTubeUrl(url)) {
        const result = {
          url,
          source: "protocol"
        };
        logger.info("Protocol handler received valid URL", "UrlHandler", result);
        setTimeout(() => {
          this.onUrlDetected(result);
        }, 200);
      } else {
        logger.debug("Protocol handler received no valid URL", "UrlHandler", { params });
      }
    } catch (error) {
      logger.error("Error in protocol handler", "UrlHandler", {
        params,
        error: error instanceof Error ? error.message : String(error)
      });
    }
  }
  /**
   * Handle clipboard URL
   */
  async handleClipboardUrl() {
    try {
      let text = "";
      try {
        if (navigator && navigator.clipboard && navigator.clipboard.readText) {
          text = await navigator.clipboard.readText() || "";
        }
      } catch (error) {
        logger.debug("Could not read clipboard", "UrlHandler", {
          error: error instanceof Error ? error.message : String(error)
        });
        text = "";
      }
      if (text && ValidationUtils.isValidYouTubeUrl(text.trim())) {
        const result = {
          url: text.trim(),
          source: "clipboard"
        };
        logger.info("URL found in clipboard", "UrlHandler", result);
        this.onUrlDetected(result);
        return;
      }
      logger.debug("No valid YouTube URL in clipboard", "UrlHandler");
    } catch (error) {
      logger.error("Error handling clipboard URL", "UrlHandler", {
        error: error instanceof Error ? error.message : String(error)
      });
    }
  }
  /**
   * Clear all handled URLs and pending operations
   */
  clear() {
    this.pendingUrls.forEach((timeout) => clearTimeout(timeout));
    this.pendingUrls.clear();
    this.handledTempFiles.clear();
    logger.info("URL handler cleared", "UrlHandler");
  }
  /**
   * Update settings
   */
  updateSettings(settings) {
    this.settings = settings;
    logger.debug("URL handler settings updated", "UrlHandler");
  }
};

// src/services/modal-manager.ts
var ModalManager = class {
  constructor() {
    this.state = {
      isModalOpen: false
    };
  }
  /**
   * Check if a modal can be opened safely
   */
  canOpenModal(url) {
    if (this.state.isModalOpen) {
      if (url && url !== this.state.pendingModalUrl) {
        return {
          canOpen: false,
          reason: "Modal already open with different URL"
        };
      }
      return {
        canOpen: false,
        reason: "Modal already open with same URL"
      };
    }
    return { canOpen: true };
  }
  /**
   * Open a modal safely with deduplication
   */
  async openModal(url, openModalFn, onClose) {
    const callId = Math.random().toString(36).substring(2, 9);
    this.state.lastCallId = callId;
    logger.info(`Modal opening requested`, "ModalManager", {
      callId,
      url,
      currentState: { ...this.state }
    });
    const { canOpen, reason } = this.canOpenModal(url);
    if (!canOpen) {
      logger.warn(`Modal open rejected: ${reason}`, "ModalManager", {
        callId,
        url,
        reason,
        pendingUrl: this.state.pendingModalUrl
      });
      if (url && url !== this.state.pendingModalUrl) {
        logger.info(`Updating pending modal URL`, "ModalManager", {
          oldUrl: this.state.pendingModalUrl,
          newUrl: url
        });
        this.state.pendingModalUrl = url;
      }
      return null;
    }
    this.state.isModalOpen = true;
    this.state.pendingModalUrl = url;
    logger.info(`Modal state set to open`, "ModalManager", {
      callId,
      url
    });
    try {
      const enhancedOnClose = () => {
        try {
          logger.info(`Modal onClose triggered`, "ModalManager", {
            callId,
            url
          });
          this.resetModalState();
          if (onClose) {
            onClose();
          }
        } catch (error) {
          logger.error(`Error in modal onClose handler`, "ModalManager", {
            callId,
            error: error instanceof Error ? error.message : String(error)
          });
          this.resetModalState();
        }
      };
      logger.info(`About to open modal`, "ModalManager", {
        callId,
        url
      });
      const result = await openModalFn();
      const fallbackTimeout = setTimeout(() => {
        if (this.state.isModalOpen && this.state.pendingModalUrl === url) {
          logger.warn("Fallback modal state reset triggered", "ModalManager", {
            callId,
            url
          });
          this.resetModalState();
        }
      }, 1e4);
      result._fallbackTimeout = fallbackTimeout;
      setTimeout(() => {
        logger.debug(`Modal state after 100ms`, "ModalManager", {
          callId,
          isModalOpen: this.state.isModalOpen
        });
      }, 100);
      return result;
    } catch (error) {
      logger.error(`Error opening modal`, "ModalManager", {
        callId,
        url,
        error: error instanceof Error ? error.message : String(error)
      });
      this.resetModalState();
      throw error;
    }
  }
  /**
   * Reset modal state
   */
  resetModalState() {
    logger.debug(`Resetting modal state`, "ModalManager", {
      previousState: { ...this.state }
    });
    this.state.isModalOpen = false;
    this.state.pendingModalUrl = void 0;
  }
  /**
   * Force reset modal state (for cleanup)
   */
  forceResetModalState() {
    logger.warn(`Force resetting modal state`, "ModalManager", {
      previousState: { ...this.state }
    });
    this.state = {
      isModalOpen: false
    };
  }
  /**
   * Get current modal state
   */
  getState() {
    return { ...this.state };
  }
  /**
   * Check if modal is currently open
   */
  isModalOpen() {
    return this.state.isModalOpen;
  }
  /**
   * Get pending modal URL
   */
  getPendingModalUrl() {
    return this.state.pendingModalUrl;
  }
  /**
   * Clear all modal state (for plugin unload)
   */
  clear() {
    this.forceResetModalState();
    logger.info(`Modal manager cleared`, "ModalManager");
  }
};

// src/save-confirmation-modal.ts
var import_obsidian3 = require("obsidian");
var SaveConfirmationModal = class extends import_obsidian3.Modal {
  constructor(app, file, onConfirm) {
    super(app);
    this.file = file;
    this.onConfirm = onConfirm;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    try {
      contentEl.createEl("h2", { text: "Note created successfully. Open now?" });
      const buttonContainer = contentEl.createDiv("save-confirmation-buttons");
      new import_obsidian3.Setting(buttonContainer).addButton((btn) => btn.setButtonText("Open Note").setCta().onClick(() => {
        this.close();
        this.onConfirm(true);
      })).addButton((btn) => btn.setButtonText("Dismiss").onClick(() => {
        this.close();
        this.onConfirm(false);
      }));
      setTimeout(() => {
        const openButton = buttonContainer.querySelector("button");
        if (openButton) {
          openButton.focus();
        }
      }, 100);
    } catch (error) {
      console.error("[SaveConfirmationModal] Error in onOpen:", error);
      contentEl.createEl("h2", { text: "File Saved" });
      contentEl.createEl("p", { text: `File "${this.file.name}" has been saved successfully.` });
      contentEl.createEl("button", { text: "OK" }).onclick = () => this.close();
    }
  }
  /**
   * Get human-readable file size
   */
  getFileSize() {
    try {
      const stat = this.app.vault.adapter.stat(this.file.path);
      if (stat && typeof stat === "object" && "size" in stat) {
        const bytes = stat.size;
        if (bytes < 1024)
          return `${bytes} bytes`;
        if (bytes < 1024 * 1024)
          return `${(bytes / 1024).toFixed(1)} KB`;
        return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
      }
    } catch (error) {
    }
    return "";
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  /**
   * Add custom styles for the modal
   */
  addStyles() {
    var _a;
    const { contentEl } = this;
    contentEl.addClass("ytp-save-confirmation-modal");
    const style = document.createElement("style");
    style.textContent = `
            .ytp-save-confirmation-modal {
                min-width: 450px;
                max-width: 650px;
            }
            
            .save-confirmation-message {
                margin: 20px 0 30px 0;
                text-align: left;
                line-height: 1.6;
            }
            
            .save-confirmation-filename {
                font-weight: bold;
                font-size: 1.1em;
                margin-bottom: 15px;
                color: var(--text-accent);
                text-align: center;
            }
            
            .save-confirmation-location-container,
            .save-confirmation-size-container {
                margin-bottom: 10px;
                display: flex;
                align-items: center;
                gap: 8px;
            }
            
            .save-confirmation-location {
                font-family: var(--font-monospace);
                background: var(--background-secondary);
                padding: 4px 8px;
                border-radius: 4px;
                font-size: 0.9em;
                word-break: break-all;
                color: var(--text-muted);
                flex: 1;
            }
            
            .save-confirmation-size {
                font-family: var(--font-monospace);
                background: var(--background-modifier-success);
                padding: 4px 8px;
                border-radius: 4px;
                font-size: 0.9em;
                color: var(--text-on-accent);
            }
            
            .save-confirmation-buttons {
                text-align: center;
                margin-top: 20px;
                display: flex;
                justify-content: center;
                gap: 15px;
            }
            
            .save-confirmation-buttons .setting-item {
                border: none;
                padding: 0;
                margin: 0;
                display: flex;
                gap: 10px;
            }
            
            .save-confirmation-buttons button {
                min-width: 100px;
                padding: 8px 20px;
                font-size: 1em;
            }
            
            .save-confirmation-buttons button:first-child {
                /* Open File button - primary action */
                background-color: var(--interactive-accent);
                color: var(--text-on-accent);
            }
            
            .save-confirmation-buttons button:last-child {
                /* OK button - secondary action */
                background-color: var(--background-modifier-border);
                color: var(--text-normal);
            }
        `;
    document.head.appendChild(style);
    (_a = this.modalEl) == null ? void 0 : _a.setAttribute("data-style-id", "ytp-save-confirmation-style");
  }
};

// src/youtube-url-modal.ts
var import_obsidian5 = require("obsidian");
init_base_modal();
init_api();
var YouTubeUrlModal = class extends BaseModal {
  constructor(app, options) {
    super(app);
    this.options = options;
    this.url = "";
    this.format = "executive-summary";
    this.fetchInProgress = false;
    this.progressSteps = [];
    this.currentStepIndex = 0;
    this.isProcessing = false;
    // Advanced settings drawer state
    this.isDrawerOpen = false;
    // Performance settings
    this.performanceMode = "balanced";
    this.enableParallelProcessing = false;
    this.preferMultimodal = false;
    // Model parameters
    this.maxTokens = 4096;
    this.temperature = 0.5;
    this.handleRetry = () => {
      if (this.processButton && !this.processButton.disabled) {
        this.handleProcess();
      }
    };
    this.url = options.initialUrl || "";
    this.performanceMode = options.performanceMode || "balanced";
    this.enableParallelProcessing = options.enableParallelProcessing || false;
    this.preferMultimodal = options.preferMultimodal || false;
    this.maxTokens = options.defaultMaxTokens || 4096;
    this.temperature = options.defaultTemperature || 0.5;
  }
  onOpen() {
    this.createModalContent();
    this.setupEventHandlers();
    if (this.options.initialUrl) {
      if (this.url.trim() === this.options.initialUrl.trim()) {
        console.debug("YouTubeUrlModal: Same URL already set, preventing cycle");
      } else {
        this.setUrl(this.options.initialUrl);
      }
      this.updateProcessButtonState();
      const isValid = ValidationUtils.isValidYouTubeUrl((this.options.initialUrl || "").trim());
      if (isValid && this.processButton) {
        this.processButton.focus();
        return;
      }
    }
    this.focusUrlInput();
  }
  /**
   * Create modal content
   */
  createModalContent() {
    this.headerEl = this.createHeader(MESSAGES.MODALS.PROCESS_VIDEO);
    this.createUrlInputSection();
    this.createPerformanceSection();
    this.createFormatSelectionSection();
    this.createAdvancedSettingsDrawer();
    this.createProgressSection();
    this.createActionButtons();
  }
  /**
   * Create compact performance and speed settings section
   */
  createPerformanceSection() {
    const container = this.contentEl.createDiv();
    container.className = "ytc-performance-section";
    container.style.marginTop = "12px";
    container.style.padding = "10px";
    container.style.backgroundColor = "var(--background-secondary)";
    container.style.borderRadius = "6px";
    container.style.border = "1px solid var(--interactive-accent)";
    const headerContainer = container.createDiv();
    headerContainer.style.display = "flex";
    headerContainer.style.alignItems = "center";
    headerContainer.style.justifyContent = "space-between";
    headerContainer.style.marginBottom = "10px";
    const sectionHeader = headerContainer.createEl("h3");
    sectionHeader.textContent = "\u26A1 Performance";
    sectionHeader.style.margin = "0";
    sectionHeader.style.fontSize = "0.9rem";
    sectionHeader.style.fontWeight = "600";
    sectionHeader.style.color = "var(--text-accent)";
    sectionHeader.style.display = "flex";
    sectionHeader.style.alignItems = "center";
    sectionHeader.style.gap = "6px";
    const modeContainer = container.createDiv();
    modeContainer.style.marginBottom = "8px";
    this.performanceModeSelect = modeContainer.createEl("select");
    this.performanceModeSelect.style.width = "100%";
    this.performanceModeSelect.style.padding = "6px 8px";
    this.performanceModeSelect.style.borderRadius = "4px";
    this.performanceModeSelect.style.border = "1px solid var(--background-modifier-border)";
    this.performanceModeSelect.style.backgroundColor = "var(--background-primary)";
    this.performanceModeSelect.style.color = "var(--text-normal)";
    this.performanceModeSelect.style.fontSize = "0.85rem";
    this.performanceModeSelect.style.cursor = "pointer";
    const fastOption = this.performanceModeSelect.createEl("option");
    fastOption.value = "fast";
    fastOption.textContent = "\u26A1 Fast (10-30s)";
    const balancedOption = this.performanceModeSelect.createEl("option");
    balancedOption.value = "balanced";
    balancedOption.textContent = "\u2696\uFE0F Balanced (30-60s)";
    const qualityOption = this.performanceModeSelect.createEl("option");
    qualityOption.value = "quality";
    qualityOption.textContent = "\u{1F3AF} Quality (60-120s)";
    this.performanceModeSelect.value = this.performanceMode;
    this.performanceModeSelect.addEventListener("change", () => {
      this.performanceMode = this.performanceModeSelect.value;
      this.handlePerformanceSettingsChange();
    });
    const togglesContainer = container.createDiv();
    togglesContainer.style.display = "flex";
    togglesContainer.style.gap = "16px";
    togglesContainer.style.marginTop = "6px";
    const parallelContainer = togglesContainer.createDiv();
    const parallelLabel = parallelContainer.createEl("label");
    parallelLabel.style.display = "flex";
    parallelLabel.style.alignItems = "center";
    parallelLabel.style.gap = "4px";
    parallelLabel.style.fontSize = "0.8rem";
    parallelLabel.style.cursor = "pointer";
    parallelLabel.style.color = "var(--text-normal)";
    const parallelToggle = parallelLabel.createEl("input");
    parallelToggle.type = "checkbox";
    parallelToggle.id = "parallel-toggle";
    parallelToggle.checked = this.enableParallelProcessing;
    parallelToggle.addEventListener("change", () => {
      this.enableParallelProcessing = parallelToggle.checked;
      this.handlePerformanceSettingsChange();
    });
    parallelLabel.appendChild(document.createTextNode("\u{1F504} Parallel"));
    parallelContainer.appendChild(parallelLabel);
    const multimodalContainer = togglesContainer.createDiv();
    const multimodalLabel = multimodalContainer.createEl("label");
    multimodalLabel.style.display = "flex";
    multimodalLabel.style.alignItems = "center";
    multimodalLabel.style.gap = "4px";
    multimodalLabel.style.fontSize = "0.8rem";
    multimodalLabel.style.cursor = "pointer";
    multimodalLabel.style.color = "var(--text-normal)";
    const multimodalToggle = multimodalLabel.createEl("input");
    multimodalToggle.type = "checkbox";
    multimodalToggle.id = "multimodal-toggle";
    multimodalToggle.checked = this.preferMultimodal;
    multimodalToggle.addEventListener("change", () => {
      this.preferMultimodal = multimodalToggle.checked;
      this.handlePerformanceSettingsChange();
    });
    multimodalLabel.appendChild(document.createTextNode("\u{1F3A5} Multimodal"));
    multimodalContainer.appendChild(multimodalLabel);
  }
  /**
   * Create enhanced performance toggle component
   */
  createPerformanceToggle(container, id, icon, label, checked, onChange, description) {
    const toggleContainer = container.createDiv();
    toggleContainer.style.padding = "12px";
    toggleContainer.style.backgroundColor = "var(--background-primary)";
    toggleContainer.style.borderRadius = "6px";
    toggleContainer.style.border = "1px solid var(--background-modifier-border)";
    toggleContainer.style.transition = "all 0.2s ease";
    toggleContainer.style.cursor = "pointer";
    const toggleHeader = toggleContainer.createDiv();
    toggleHeader.style.display = "flex";
    toggleHeader.style.alignItems = "center";
    toggleHeader.style.justifyContent = "space-between";
    toggleHeader.style.marginBottom = "4px";
    const labelContainer = toggleHeader.createEl("div");
    labelContainer.style.display = "flex";
    labelContainer.style.alignItems = "center";
    labelContainer.style.gap = "8px";
    const iconSpan = labelContainer.createEl("span");
    iconSpan.textContent = icon;
    iconSpan.style.fontSize = "1rem";
    const labelText = labelContainer.createEl("span");
    labelText.textContent = label;
    labelText.style.fontWeight = "500";
    labelText.style.color = "var(--text-normal)";
    const toggle = toggleContainer.createEl("input");
    toggle.type = "checkbox";
    toggle.id = id;
    toggle.checked = checked;
    toggle.style.width = "20px";
    toggle.style.height = "20px";
    toggle.style.cursor = "pointer";
    const descriptionText = toggleContainer.createEl("div");
    descriptionText.textContent = description;
    descriptionText.style.fontSize = "0.8rem";
    descriptionText.style.color = "var(--text-muted)";
    descriptionText.style.marginTop = "4px";
    descriptionText.style.lineHeight = "1.3";
    toggleContainer.addEventListener("mouseenter", () => {
      toggleContainer.style.backgroundColor = "var(--background-modifier-hover)";
      toggleContainer.style.borderColor = "var(--interactive-accent)";
      toggleContainer.style.transform = "translateY(-2px)";
      toggleContainer.style.boxShadow = "0 4px 12px rgba(0,0,0,0.1)";
    });
    toggleContainer.addEventListener("mouseleave", () => {
      toggleContainer.style.backgroundColor = "var(--background-primary)";
      toggleContainer.style.borderColor = "var(--background-modifier-border)";
      toggleContainer.style.transform = "translateY(0)";
      toggleContainer.style.boxShadow = "none";
    });
    toggle.addEventListener("change", () => onChange(toggle.checked));
  }
  /**
   * Add performance preview with mode descriptions
   */
  addPerformancePreview(container) {
    const previewContainer = container.createDiv();
    previewContainer.style.marginTop = "16px";
    previewContainer.style.padding = "12px";
    previewContainer.style.backgroundColor = "var(--background-modifier-hover)";
    previewContainer.style.borderRadius = "6px";
    previewContainer.style.border = "1px dashed var(--interactive-accent)";
    const previewTitle = previewContainer.createEl("div");
    previewTitle.textContent = "\u{1F4CB} Current Configuration";
    previewTitle.style.fontWeight = "600";
    previewTitle.style.marginBottom = "8px";
    previewTitle.style.color = "var(--text-accent)";
    const previewText = previewContainer.createEl("div");
    previewText.className = "ytc-performance-preview";
    previewText.style.fontSize = "0.85rem";
    previewText.style.lineHeight = "1.4";
    previewText.style.color = "var(--text-muted)";
    this.updatePerformancePreview(previewText);
  }
  /**
   * Update performance preview text
   */
  updatePerformancePreview(previewElement) {
    const modeText = this.performanceMode === "fast" ? "\u26A1 Fast Mode" : this.performanceMode === "balanced" ? "\u2696\uFE0F Balanced Mode" : "\u{1F3AF} Quality Mode";
    const parallelText = this.enableParallelProcessing ? "\u{1F504} Enabled" : "\u23F8\uFE0F Disabled";
    const multimodalText = this.preferMultimodal ? "\u{1F3A5} Enabled" : "\u{1F4C4} Text Only";
    previewElement.innerHTML = `
            <strong>Mode:</strong> ${modeText}<br>
            <strong>Parallel Processing:</strong> ${parallelText}<br>
            <strong>Multimodal Analysis:</strong> ${multimodalText}
        `;
  }
  /**
   * Add subtle animation when performance mode changes
   */
  addPerformanceModeAnimation() {
    const previewElement = document.querySelector(".ytc-performance-preview");
    if (previewElement) {
      previewElement.style.transition = "all 0.3s ease";
      previewElement.style.transform = "scale(1.02)";
      setTimeout(() => {
        previewElement.style.transform = "scale(1)";
      }, 200);
    }
  }
  /**
   * Handle performance settings change
   */
  async handlePerformanceSettingsChange() {
    if (this.options.onPerformanceSettingsChange) {
      await this.options.onPerformanceSettingsChange(
        this.performanceMode,
        this.enableParallelProcessing,
        this.preferMultimodal
      );
    }
  }
  createProviderSelectionSection() {
    const container = this.contentEl.createDiv();
    container.style.marginTop = "10px";
    const label = container.createEl("label", { text: "AI Provider & Model:" });
    label.setAttribute("for", "ytc-provider-select");
    const row = container.createDiv();
    row.style.display = "flex";
    row.style.gap = "8px";
    row.style.alignItems = "center";
    this.providerSelect = document.createElement("select");
    this.providerSelect.id = "ytc-provider-select";
    this.providerSelect.setAttribute("aria-label", "AI Provider");
    this.providerSelect.style.flex = "1";
    this.providerSelect.style.padding = "6px";
    this.providerSelect.style.borderRadius = "6px";
    this.providerSelect.style.border = "1px solid var(--background-modifier-border)";
    row.appendChild(this.providerSelect);
    this.modelSelect = document.createElement("select");
    this.modelSelect.id = "ytc-model-select";
    this.modelSelect.setAttribute("aria-label", "AI Model");
    this.modelSelect.style.width = "220px";
    this.modelSelect.style.padding = "6px";
    this.modelSelect.style.borderRadius = "6px";
    this.modelSelect.style.border = "1px solid var(--background-modifier-border)";
    row.appendChild(this.modelSelect);
    const providers = this.options.providers || [];
    const modelOptions = this.options.modelOptions || {};
    const autoOpt = document.createElement("option");
    autoOpt.value = "";
    autoOpt.text = "Auto (fallback)";
    this.providerSelect.appendChild(autoOpt);
    providers.forEach((p) => {
      const opt = document.createElement("option");
      opt.value = p;
      opt.text = p;
      this.providerSelect.appendChild(opt);
    });
    const refreshBtn = this.createInlineButton(row, "Refresh models", () => {
      void this.handleRefreshModels();
    });
    this.refreshSpinner = document.createElement("span");
    this.refreshSpinner.style.display = "none";
    this.refreshSpinner.style.marginLeft = "8px";
    this.refreshSpinner.style.width = "16px";
    this.refreshSpinner.style.height = "16px";
    this.refreshSpinner.style.border = "2px solid var(--background-modifier-border)";
    this.refreshSpinner.style.borderTop = "2px solid var(--interactive-accent)";
    this.refreshSpinner.style.borderRadius = "50%";
    this.refreshSpinner.style.animation = "ytp-spin 1s linear infinite";
    row.appendChild(this.refreshSpinner);
    this.providerSelect.addEventListener("change", () => {
      this.selectedProvider = this.providerSelect.value || void 0;
      this.populateModelsForProvider(this.selectedProvider || "", modelOptions, this.options.defaultModel);
    });
    if (this.options.defaultProvider) {
      this.providerSelect.value = this.options.defaultProvider;
      this.selectedProvider = this.options.defaultProvider;
    }
    this.populateModelsForProvider(this.selectedProvider || "", modelOptions, this.options.defaultModel);
  }
  async handleRefreshModels() {
    if (!this.options.fetchModels) {
      this.setValidationMessage("Model refresh not available.", "error");
      return;
    }
    this.setValidationMessage("Refreshing model lists\u2026", "info");
    if (this.refreshSpinner)
      this.refreshSpinner.style.display = "inline-block";
    try {
      const map = await this.options.fetchModels();
      const providers = Object.keys(map);
      if (this.providerSelect) {
        const current = this.providerSelect.value;
        this.providerSelect.innerHTML = "";
        const autoOpt = document.createElement("option");
        autoOpt.value = "";
        autoOpt.text = "Auto (fallback)";
        this.providerSelect.appendChild(autoOpt);
        providers.forEach((p) => {
          const opt = document.createElement("option");
          opt.value = p;
          opt.text = p;
          this.providerSelect.appendChild(opt);
        });
        if (current && Array.from(this.providerSelect.options).some((o) => o.value === current)) {
          this.providerSelect.value = current;
          this.selectedProvider = current;
        }
      }
      const modelOptions = map;
      this.populateModelsForProvider(this.selectedProvider || "", modelOptions, this.options.defaultModel);
      this.setValidationMessage("Model lists refreshed.", "success");
    } catch (error) {
      this.setValidationMessage("Failed to refresh models. Using cached options.", "error");
    } finally {
      if (this.refreshSpinner)
        this.refreshSpinner.style.display = "none";
    }
  }
  populateModelsForProvider(providerName, modelOptions, defaultModel) {
    if (!this.modelSelect)
      return;
    this.modelSelect.innerHTML = "";
    const models = modelOptions[providerName] || [];
    if (models.length === 0) {
      const opt = document.createElement("option");
      opt.value = "";
      opt.text = "Default model";
      this.modelSelect.appendChild(opt);
      this.selectedModel = "";
      return;
    }
    models.forEach((m) => {
      const opt = document.createElement("option");
      opt.value = m;
      let label = m;
      try {
        const providerModels = PROVIDER_MODEL_OPTIONS[providerName] || [];
        const match = providerModels.find((pm) => {
          const name = typeof pm === "string" ? pm : pm && pm.name ? pm.name : "";
          return String(name).toLowerCase() === String(m).toLowerCase();
        });
        if (match && match.supportsAudioVideo) {
          label = `${m}  \u{1F3A5}`;
          opt.title = "Supports multimodal audio/video tokens";
        }
      } catch (err) {
      }
      opt.text = label;
      this.modelSelect.appendChild(opt);
    });
    if (defaultModel && models.includes(defaultModel)) {
      this.modelSelect.value = defaultModel;
      this.selectedModel = defaultModel;
    } else {
      this.modelSelect.selectedIndex = 0;
      this.selectedModel = this.modelSelect.value;
    }
    this.modelSelect.addEventListener("change", () => {
      this.selectedModel = this.modelSelect.value;
    });
  }
  /**
   * Create URL input section
   */
  createUrlInputSection() {
    const container = this.contentEl.createDiv();
    const label = container.createEl("label", { text: "YouTube URL:" });
    label.setAttribute("for", "ytc-url-input");
    const inputRow = container.createDiv();
    inputRow.style.display = "flex";
    inputRow.style.gap = "8px";
    inputRow.style.alignItems = "center";
    this.urlInput = this.createInput(
      inputRow,
      "url",
      MESSAGES.PLACEHOLDERS.YOUTUBE_URL + " (Press Enter to process)"
    );
    this.urlInput.id = "ytc-url-input";
    this.urlInput.setAttribute("aria-label", "YouTube URL");
    this.urlInput.setAttribute("aria-describedby", "ytc-url-hint");
    this.urlInput.style.flex = "1";
    this.urlInput.style.transition = "border-color 0.2s ease, box-shadow 0.2s ease";
    this.pasteButton = this.createInlineButton(inputRow, "Paste", () => {
      void this.handlePasteFromClipboard();
    });
    this.pasteButton.setAttribute("aria-label", "Paste YouTube URL from clipboard");
    this.clearButton = this.createInlineButton(inputRow, "Clear", () => {
      this.handleClearUrl();
    });
    this.clearButton.setAttribute("aria-label", "Clear YouTube URL input");
    if (this.options.initialUrl) {
      this.urlInput.value = this.options.initialUrl;
      this.url = this.options.initialUrl;
    }
    this.urlInput.addEventListener("input", (e) => {
      this.url = e.target.value;
      this.updateProcessButtonState();
      this.updateQuickActionsState();
    });
    this.validationMessage = container.createDiv();
    this.validationMessage.id = "ytc-url-hint";
    this.validationMessage.style.marginTop = "6px";
    this.validationMessage.style.fontSize = "0.85rem";
    this.validationMessage.style.color = "var(--text-muted)";
    this.validationMessage.setAttribute("role", "status");
    this.setValidationMessage("Paste a YouTube link to begin processing.", "info");
    const preview = container.createDiv();
    preview.style.display = "flex";
    preview.style.gap = "8px";
    preview.style.alignItems = "center";
    preview.style.marginTop = "6px";
    this.thumbnailEl = preview.createEl("img");
    this.thumbnailEl.setAttribute("aria-label", "Video thumbnail");
    this.thumbnailEl.style.width = "90px";
    this.thumbnailEl.style.height = "50px";
    this.thumbnailEl.style.objectFit = "cover";
    this.thumbnailEl.style.borderRadius = "4px";
    this.thumbnailEl.style.display = "none";
    this.metadataContainer = preview.createDiv();
    this.metadataContainer.setAttribute("aria-label", "Video metadata");
    this.metadataContainer.style.display = "none";
    this.metadataContainer.style.fontSize = "0.9rem";
    this.metadataContainer.style.color = "var(--text-normal)";
    this.metadataContainer.createDiv({ cls: "yt-preview-title" });
    this.metadataContainer.createDiv({ cls: "yt-preview-channel" });
    this.setUrlInputState("idle");
    this.updateQuickActionsState();
  }
  /**
   * Create compact format selection section
   */
  createFormatSelectionSection() {
    const container = this.contentEl.createDiv();
    container.className = "ytc-format-section";
    container.style.marginTop = "12px";
    container.style.padding = "8px";
    container.style.backgroundColor = "var(--background-secondary)";
    container.style.borderRadius = "6px";
    container.style.border = "1px solid var(--background-modifier-border)";
    const label = container.createEl("label", { text: "\u{1F4DD} Format" });
    label.id = "format-group-label";
    label.style.display = "block";
    label.style.marginBottom = "8px";
    label.style.fontSize = "0.9rem";
    label.style.fontWeight = "600";
    label.style.color = "var(--text-normal)";
    const radioContainer = container.createDiv();
    radioContainer.setAttribute("role", "group");
    radioContainer.setAttribute("aria-labelledby", "format-group-label");
    radioContainer.style.display = "grid";
    radioContainer.style.gridTemplateColumns = "repeat(4, 1fr)";
    radioContainer.style.gap = "8px";
    try {
      this.createCompactFormatRadio(radioContainer, "executive-radio", "executive-summary", "Executive", "", this.format === "executive-summary");
      this.createCompactFormatRadio(radioContainer, "tutorial-radio", "detailed-guide", "Tutorial", "", this.format === "detailed-guide");
      this.createCompactFormatRadio(radioContainer, "brief-radio", "brief", "Brief", "", this.format === "brief");
      this.createCompactFormatRadio(radioContainer, "custom-radio", "custom", "Custom", "", this.format === "custom");
    } catch (error) {
      console.error("Error creating compact format radio buttons:", error);
      this.createFormatRadio(radioContainer, "executive-radio", "executive-summary", "Executive", "Quick insights with action items", this.format === "executive-summary");
      this.createFormatRadio(radioContainer, "tutorial-radio", "detailed-guide", "Tutorial", "\u{1F4DA} Step-by-step walkthrough", this.format === "detailed-guide");
      this.createFormatRadio(radioContainer, "brief-radio", "brief", "Brief", "\u{1F4CB} Key points and takeaways", this.format === "brief");
      this.createFormatRadio(radioContainer, "custom-radio", "custom", "Custom", "\u270F\uFE0F Your custom analysis", this.format === "custom");
    }
    this.customPromptContainer = container.createDiv();
    this.customPromptContainer.style.marginTop = "12px";
    this.customPromptContainer.style.padding = "12px";
    this.customPromptContainer.style.backgroundColor = "var(--background-modifier-hover)";
    this.customPromptContainer.style.borderRadius = "4px";
    this.customPromptContainer.style.display = "none";
    const customPromptLabel = this.customPromptContainer.createEl("label", {
      text: "Custom Prompt (this session only):"
    });
    customPromptLabel.setAttribute("for", "custom-prompt-input");
    customPromptLabel.style.display = "block";
    customPromptLabel.style.marginBottom = "6px";
    customPromptLabel.style.fontWeight = "600";
    customPromptLabel.style.fontSize = "0.95rem";
    this.customPromptInput = this.customPromptContainer.createEl("textarea");
    this.customPromptInput.id = "custom-prompt-input";
    this.customPromptInput.setAttribute("aria-label", "Custom AI prompt");
    this.customPromptInput.setAttribute("placeholder", "Enter your custom prompt here. Available placeholders: __VIDEO_TITLE__, __VIDEO_DESCRIPTION__, __VIDEO_URL__");
    this.customPromptInput.style.width = "100%";
    this.customPromptInput.style.height = "100px";
    this.customPromptInput.style.padding = "8px";
    this.customPromptInput.style.fontFamily = "monospace";
    this.customPromptInput.style.fontSize = "12px";
    this.customPromptInput.style.border = "1px solid var(--background-modifier-border)";
    this.customPromptInput.style.borderRadius = "4px";
    this.customPromptInput.style.resize = "vertical";
    this.customPromptInput.style.marginBottom = "6px";
    const helpText = this.customPromptContainer.createEl("small");
    helpText.textContent = "Placeholders: __VIDEO_TITLE__, __VIDEO_DESCRIPTION__, __VIDEO_URL__, __VIDEO_ID__, __EMBED_URL__, __DATE__, __TIMESTAMP__";
    helpText.style.display = "block";
    helpText.style.marginTop = "4px";
    helpText.style.color = "var(--text-muted)";
    helpText.style.fontSize = "11px";
  }
  /**
   * Create enhanced format radio button
   */
  createFormatRadio(container, id, value, title, description, isChecked) {
    const radioContainer = container.createDiv();
    radioContainer.style.padding = "12px";
    radioContainer.style.border = "2px solid var(--background-modifier-border)";
    radioContainer.style.borderRadius = "8px";
    radioContainer.style.backgroundColor = "var(--background-primary)";
    radioContainer.style.cursor = "pointer";
    radioContainer.style.transition = "all 0.2s ease";
    radioContainer.style.textAlign = "center";
    const radio = radioContainer.createEl("input");
    radio.type = "radio";
    radio.name = "outputFormat";
    radio.value = value;
    radio.id = id;
    radio.checked = isChecked;
    radio.style.marginBottom = "8px";
    const icon = radioContainer.createEl("div");
    icon.style.fontSize = "1.5rem";
    icon.style.marginBottom = "4px";
    if (value === "executive-summary") {
      icon.textContent = "\u{1F3AF}";
    } else if (value === "detailed-guide") {
      icon.textContent = "\u{1F4DA}";
    } else if (value === "brief") {
      icon.textContent = "\u{1F4CB}";
    } else if (value === "custom") {
      icon.textContent = "\u270F\uFE0F";
    }
    const titleElement = radioContainer.createEl("div");
    titleElement.textContent = title;
    titleElement.style.fontWeight = "600";
    titleElement.style.fontSize = "0.9rem";
    titleElement.style.marginBottom = "2px";
    const descElement = radioContainer.createEl("div");
    descElement.textContent = description;
    descElement.style.fontSize = "0.75rem";
    descElement.style.color = "var(--text-muted)";
    if (isChecked) {
      radioContainer.style.borderColor = "var(--interactive-accent)";
      radioContainer.style.backgroundColor = "var(--interactive-accent-hover)";
    }
    radioContainer.addEventListener("mouseenter", () => {
      radioContainer.style.borderColor = "var(--interactive-accent)";
      radioContainer.style.transform = "translateY(-2px)";
      radioContainer.style.boxShadow = "0 4px 12px rgba(0,0,0,0.1)";
    });
    radioContainer.addEventListener("mouseleave", () => {
      if (!radio.checked) {
        radioContainer.style.borderColor = "var(--background-modifier-border)";
        radioContainer.style.transform = "translateY(0)";
        radioContainer.style.boxShadow = "none";
      }
    });
    radio.addEventListener("change", (e) => {
      var _a;
      if (e.target.checked) {
        this.format = value;
        const allContainers = container.querySelectorAll("div");
        allContainers.forEach((containerEl) => {
          const divEl = containerEl;
          divEl.style.borderColor = "var(--background-modifier-border)";
          divEl.style.backgroundColor = "var(--background-primary)";
        });
        radioContainer.style.borderColor = "var(--interactive-accent)";
        radioContainer.style.backgroundColor = "var(--interactive-accent-hover)";
        if (this.customPromptContainer) {
          if (value === "custom") {
            this.customPromptContainer.style.display = "block";
            (_a = this.customPromptInput) == null ? void 0 : _a.focus();
          } else {
            this.customPromptContainer.style.display = "none";
          }
        }
      }
    });
    radioContainer.addEventListener("click", () => {
      radio.checked = true;
      radio.dispatchEvent(new Event("change"));
    });
  }
  /**
   * Create compact format radio button
   */
  createCompactFormatRadio(container, id, value, title, icon, isChecked) {
    const radioContainer = container.createDiv();
    radioContainer.style.padding = "8px 4px";
    radioContainer.style.border = "1px solid var(--background-modifier-border)";
    radioContainer.style.borderRadius = "4px";
    radioContainer.style.backgroundColor = "var(--background-primary)";
    radioContainer.style.cursor = "pointer";
    radioContainer.style.transition = "all 0.2s ease";
    radioContainer.style.textAlign = "center";
    const radio = radioContainer.createEl("input");
    radio.type = "radio";
    radio.name = "outputFormat";
    radio.value = value;
    radio.id = id;
    radio.checked = isChecked;
    radio.style.marginBottom = "4px";
    if (icon) {
      const iconEl = radioContainer.createEl("div");
      iconEl.textContent = icon;
      iconEl.style.fontSize = "1.2rem";
      iconEl.style.marginBottom = "2px";
    }
    const titleElement = radioContainer.createEl("div");
    titleElement.textContent = title;
    titleElement.style.fontWeight = "500";
    titleElement.style.fontSize = "0.8rem";
    if (isChecked) {
      radioContainer.style.borderColor = "var(--interactive-accent)";
      radioContainer.style.backgroundColor = "var(--interactive-accent-hover)";
    }
    radioContainer.addEventListener("mouseenter", () => {
      radioContainer.style.borderColor = "var(--interactive-accent)";
      radioContainer.style.transform = "translateY(-1px)";
    });
    radioContainer.addEventListener("mouseleave", () => {
      if (!radio.checked) {
        radioContainer.style.borderColor = "var(--background-modifier-border)";
        radioContainer.style.transform = "translateY(0)";
      }
    });
    radio.addEventListener("change", (e) => {
      var _a;
      if (e.target.checked) {
        this.format = value;
        const allContainers = container.querySelectorAll("div");
        allContainers.forEach((containerEl) => {
          const divEl = containerEl;
          divEl.style.borderColor = "var(--background-modifier-border)";
          divEl.style.backgroundColor = "var(--background-primary)";
        });
        radioContainer.style.borderColor = "var(--interactive-accent)";
        radioContainer.style.backgroundColor = "var(--interactive-accent-hover)";
        if (this.customPromptContainer) {
          if (value === "custom") {
            this.customPromptContainer.style.display = "block";
            (_a = this.customPromptInput) == null ? void 0 : _a.focus();
          } else {
            this.customPromptContainer.style.display = "none";
          }
        }
      }
    });
    radioContainer.addEventListener("click", () => {
      radio.checked = true;
      radio.dispatchEvent(new Event("change"));
    });
  }
  /**
   * Create model parameters section with sliders for max tokens and temperature
   */
  createModelParametersSection() {
    const container = this.contentEl.createDiv();
    container.className = "ytc-model-params-section";
    container.style.marginTop = "16px";
    container.style.padding = "16px";
    container.style.backgroundColor = "var(--background-secondary)";
    container.style.borderRadius = "8px";
    container.style.border = "1px solid var(--background-modifier-border-hover)";
    container.style.boxShadow = "0 2px 8px rgba(0,0,0,0.1)";
    const headerContainer = container.createDiv();
    headerContainer.className = "ytc-model-params-header";
    headerContainer.style.display = "flex";
    headerContainer.style.alignItems = "center";
    headerContainer.style.justifyContent = "space-between";
    headerContainer.style.marginBottom = "16px";
    const sectionHeader = headerContainer.createEl("h3");
    sectionHeader.textContent = "\u2699\uFE0F Model Parameters";
    sectionHeader.style.margin = "0";
    sectionHeader.style.fontSize = "1rem";
    sectionHeader.style.fontWeight = "600";
    sectionHeader.style.color = "var(--text-normal)";
    sectionHeader.style.display = "flex";
    sectionHeader.style.alignItems = "center";
    sectionHeader.style.gap = "8px";
    const description = headerContainer.createDiv();
    description.className = "ytc-model-params-description";
    description.textContent = "Fine-tune AI model behavior for optimal results";
    description.style.fontSize = "0.75rem";
    description.style.color = "var(--text-muted)";
    description.style.fontWeight = "400";
    const maxTokensContainer = container.createDiv();
    maxTokensContainer.className = "ytc-slider-container";
    maxTokensContainer.style.marginBottom = "20px";
    const maxTokensHeader = maxTokensContainer.createDiv();
    maxTokensHeader.className = "ytc-slider-header";
    maxTokensHeader.style.display = "flex";
    maxTokensHeader.style.alignItems = "center";
    maxTokensHeader.style.justifyContent = "space-between";
    maxTokensHeader.style.marginBottom = "8px";
    const maxTokensLabel = maxTokensHeader.createEl("label");
    maxTokensLabel.textContent = "Max Tokens";
    maxTokensLabel.className = "ytc-slider-label";
    maxTokensLabel.style.fontSize = "0.9rem";
    maxTokensLabel.style.fontWeight = "600";
    maxTokensLabel.style.color = "var(--text-normal)";
    maxTokensLabel.style.margin = "0";
    maxTokensLabel.style.display = "flex";
    maxTokensLabel.style.alignItems = "center";
    maxTokensLabel.style.gap = "6px";
    const maxTokensInfo = maxTokensHeader.createSpan();
    maxTokensInfo.className = "ytc-slider-info";
    maxTokensInfo.textContent = "Controls response length";
    maxTokensInfo.style.fontSize = "0.75rem";
    maxTokensInfo.style.color = "var(--text-muted)";
    maxTokensInfo.style.fontWeight = "400";
    const maxTokensRow = maxTokensContainer.createDiv();
    maxTokensRow.className = "ytc-slider-row";
    maxTokensRow.style.display = "flex";
    maxTokensRow.style.alignItems = "center";
    maxTokensRow.style.gap = "12px";
    maxTokensRow.style.padding = "12px";
    maxTokensRow.style.backgroundColor = "var(--background-primary)";
    maxTokensRow.style.borderRadius = "6px";
    maxTokensRow.style.border = "1px solid var(--background-modifier-border)";
    const sliderContainer = maxTokensRow.createDiv();
    sliderContainer.style.position = "relative";
    sliderContainer.style.flex = "1";
    sliderContainer.style.height = "32px";
    sliderContainer.style.display = "flex";
    sliderContainer.style.alignItems = "center";
    this.maxTokensSlider = sliderContainer.createEl("input");
    this.maxTokensSlider.type = "range";
    this.maxTokensSlider.min = "256";
    this.maxTokensSlider.max = "8192";
    this.maxTokensSlider.step = "256";
    this.maxTokensSlider.value = this.maxTokens.toString();
    this.maxTokensSlider.className = "ytc-model-slider";
    this.maxTokensSlider.style.flex = "1";
    this.maxTokensSlider.style.margin = "0 8px";
    this.maxTokensValue = maxTokensRow.createDiv();
    this.maxTokensValue.className = "ytc-slider-value";
    this.maxTokensValue.textContent = this.maxTokens.toString();
    this.maxTokensValue.style.fontSize = "0.9rem";
    this.maxTokensValue.style.fontWeight = "700";
    this.maxTokensValue.style.color = "var(--text-accent)";
    this.maxTokensValue.style.minWidth = "70px";
    this.maxTokensValue.style.textAlign = "center";
    this.maxTokensValue.style.padding = "6px 12px";
    this.maxTokensValue.style.backgroundColor = "var(--background-secondary)";
    this.maxTokensValue.style.borderRadius = "4px";
    this.maxTokensValue.style.border = "1px solid var(--background-modifier-border)";
    const temperatureContainer = container.createDiv();
    temperatureContainer.className = "ytc-slider-container";
    temperatureContainer.style.marginBottom = "8px";
    const temperatureHeader = temperatureContainer.createDiv();
    temperatureHeader.className = "ytc-slider-header";
    temperatureHeader.style.display = "flex";
    temperatureHeader.style.alignItems = "center";
    temperatureHeader.style.justifyContent = "space-between";
    temperatureHeader.style.marginBottom = "8px";
    const temperatureLabel = temperatureHeader.createEl("label");
    temperatureLabel.textContent = "Temperature";
    temperatureLabel.className = "ytc-slider-label";
    temperatureLabel.style.fontSize = "0.9rem";
    temperatureLabel.style.fontWeight = "600";
    temperatureLabel.style.color = "var(--text-normal)";
    temperatureLabel.style.margin = "0";
    temperatureLabel.style.display = "flex";
    temperatureLabel.style.alignItems = "center";
    temperatureLabel.style.gap = "6px";
    const temperatureInfo = temperatureHeader.createSpan();
    temperatureInfo.className = "ytc-slider-info";
    temperatureInfo.textContent = "Controls creativity level";
    temperatureInfo.style.fontSize = "0.75rem";
    temperatureInfo.style.color = "var(--text-muted)";
    temperatureInfo.style.fontWeight = "400";
    const temperatureRow = temperatureContainer.createDiv();
    temperatureRow.className = "ytc-slider-row";
    temperatureRow.style.display = "flex";
    temperatureRow.style.alignItems = "center";
    temperatureRow.style.gap = "12px";
    temperatureRow.style.padding = "12px";
    temperatureRow.style.backgroundColor = "var(--background-primary)";
    temperatureRow.style.borderRadius = "6px";
    temperatureRow.style.border = "1px solid var(--background-modifier-border)";
    const tempSliderContainer = temperatureRow.createDiv();
    tempSliderContainer.style.position = "relative";
    tempSliderContainer.style.flex = "1";
    tempSliderContainer.style.height = "32px";
    tempSliderContainer.style.display = "flex";
    tempSliderContainer.style.alignItems = "center";
    this.temperatureSlider = tempSliderContainer.createEl("input");
    this.temperatureSlider.type = "range";
    this.temperatureSlider.min = "0";
    this.temperatureSlider.max = "2";
    this.temperatureSlider.step = "0.1";
    this.temperatureSlider.value = this.temperature.toString();
    this.temperatureSlider.className = "ytc-model-slider";
    this.temperatureSlider.style.flex = "1";
    this.temperatureSlider.style.margin = "0 8px";
    this.temperatureValue = temperatureRow.createDiv();
    this.temperatureValue.className = "ytc-slider-value";
    this.temperatureValue.textContent = this.temperature.toFixed(1);
    this.temperatureValue.style.fontSize = "0.9rem";
    this.temperatureValue.style.fontWeight = "700";
    this.temperatureValue.style.color = "var(--text-accent)";
    this.temperatureValue.style.minWidth = "60px";
    this.temperatureValue.style.textAlign = "center";
    this.temperatureValue.style.padding = "6px 12px";
    this.temperatureValue.style.backgroundColor = "var(--background-secondary)";
    this.temperatureValue.style.borderRadius = "4px";
    this.temperatureValue.style.border = "1px solid var(--background-modifier-border)";
    const tempScale = temperatureRow.createDiv();
    tempScale.className = "ytc-temp-scale";
    tempScale.style.fontSize = "0.75rem";
    tempScale.style.color = "var(--text-muted)";
    tempScale.style.fontWeight = "500";
    tempScale.style.display = "flex";
    tempScale.style.justifyContent = "space-between";
    tempScale.style.padding = "0 12px";
    tempScale.style.width = "100%";
    tempScale.style.marginTop = "8px";
    tempScale.innerHTML = '<span style="text-align: left;">0.0</span><span style="text-align: center;">Precise</span><span style="text-align: center;">Balanced</span><span style="text-align: center;">Creative</span><span style="text-align: right;">2.0</span>';
    this.addSliderStyling();
    this.maxTokensSlider.addEventListener("input", (e) => {
      this.maxTokens = parseInt(e.target.value);
      this.maxTokensValue.textContent = this.maxTokens.toString();
    });
    this.temperatureSlider.addEventListener("input", (e) => {
      this.temperature = parseFloat(e.target.value);
      this.temperatureValue.textContent = this.temperature.toFixed(1);
    });
  }
  /**
   * Add comprehensive CSS styling for sliders
   */
  addSliderStyling() {
    const style = document.createElement("style");
    style.textContent = `
            .ytc-model-slider {
                -webkit-appearance: none;
                appearance: none;
                background: transparent;
                cursor: pointer;
                width: 100%;
                height: 4px;
                outline: none;
                position: relative;
                z-index: 1;
            }

            .ytc-model-slider::-webkit-slider-track {
                background: var(--interactive-normal);
                height: 4px;
                border-radius: 2px;
            }

            .ytc-model-slider::-moz-range-track {
                background: var(--interactive-normal);
                height: 4px;
                border-radius: 2px;
                border: none;
            }

            .ytc-model-slider::-webkit-slider-thumb {
                -webkit-appearance: none;
                appearance: none;
                width: 18px;
                height: 18px;
                border-radius: 50%;
                background: var(--interactive-accent);
                cursor: pointer;
                border: 3px solid var(--background-primary);
                box-shadow: 0 2px 8px rgba(0,0,0,0.2);
                margin-top: -7px;
                position: relative;
                z-index: 2;
                transition: all 0.2s ease;
            }

            .ytc-model-slider::-moz-range-thumb {
                width: 18px;
                height: 18px;
                border-radius: 50%;
                background: var(--interactive-accent);
                cursor: pointer;
                border: 3px solid var(--background-primary);
                box-shadow: 0 2px 8px rgba(0,0,0,0.2);
                position: relative;
                z-index: 2;
                transition: all 0.2s ease;
            }

            .ytc-model-slider:hover::-webkit-slider-thumb {
                background: var(--interactive-accent-hover);
                transform: scale(1.1);
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            }

            .ytc-model-slider:hover::-moz-range-thumb {
                background: var(--interactive-accent-hover);
                transform: scale(1.1);
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            }

            .ytc-model-slider:focus {
                outline: none;
            }

            .ytc-model-slider:focus::-webkit-slider-thumb {
                border-color: var(--interactive-accent);
                box-shadow: 0 0 0 3px var(--interactive-accent), 0 2px 8px rgba(0,0,0,0.3);
            }

            .ytc-model-slider:focus::-moz-range-thumb {
                border-color: var(--interactive-accent);
                box-shadow: 0 0 0 3px var(--interactive-accent), 0 2px 8px rgba(0,0,0,0.3);
            }

            .ytc-slider-row {
                transition: all 0.2s ease;
            }

            .ytc-slider-row:hover {
                border-color: var(--interactive-accent);
                box-shadow: 0 2px 12px rgba(0,0,0,0.1);
            }

            .ytc-slider-value {
                transition: all 0.2s ease;
                font-variant-numeric: tabular-nums;
            }

            .ytc-model-params-section:hover {
                border-color: var(--interactive-accent);
                box-shadow: 0 4px 16px rgba(0,0,0,0.15);
            }

            .ytc-temp-scale span {
                flex: 1;
                text-align: center;
                position: relative;
            }

            .ytc-temp-scale span::before {
                content: '';
                position: absolute;
                bottom: -4px;
                left: 0;
                right: 0;
                height: 1px;
                background: var(--background-modifier-border);
            }

            .ytc-temp-scale span:first-child::before {
                left: 50%;
            }

            .ytc-temp-scale span:last-child::before {
                right: 50%;
            }

            /* Dark theme adjustments */
            body.theme-dark .ytc-slider-row {
                background: var(--background-primary-alt);
            }

            body.theme-dark .ytc-slider-value {
                background: var(--background-primary-alt);
            }

            /* High contrast theme adjustments */
            body.theme-high-contrast .ytc-model-slider {
                background: var(--text-normal);
            }

            body.theme-high-contrast .ytc-model-slider::-webkit-slider-track {
                background: var(--text-muted);
            }

            body.theme-high-contrast .ytc-model-slider::-webkit-slider-thumb {
                background: var(--text-accent);
                border-color: var(--background-primary);
            }
        `;
    if (!document.querySelector("style[data-ytc-model-params]")) {
      style.setAttribute("data-ytc-model-params", "true");
      document.head.appendChild(style);
    }
  }
  /**
   * Create collapsible advanced settings drawer
   */
  createAdvancedSettingsDrawer() {
    this.drawerToggle = this.contentEl.createEl("button");
    this.drawerToggle.textContent = "\u{1F916} Advanced AI Settings \u25B6";
    this.drawerToggle.style.width = "100%";
    this.drawerToggle.style.padding = "10px";
    this.drawerToggle.style.margin = "10px 0";
    this.drawerToggle.style.backgroundColor = "var(--background-secondary)";
    this.drawerToggle.style.border = "1px solid var(--background-modifier-border)";
    this.drawerToggle.style.borderRadius = "5px";
    this.drawerToggle.style.cursor = "pointer";
    this.drawerToggle.style.fontSize = "14px";
    this.drawerToggle.style.fontWeight = "bold";
    this.drawerContent = this.contentEl.createDiv();
    this.drawerContent.style.display = "none";
    this.drawerContent.style.padding = "15px";
    this.drawerContent.style.backgroundColor = "var(--background-primary)";
    this.drawerContent.style.border = "1px solid var(--background-modifier-border)";
    this.drawerContent.style.borderRadius = "5px";
    this.drawerContent.style.marginBottom = "10px";
    const title = this.drawerContent.createEl("h3");
    title.textContent = "AI Configuration";
    title.style.marginBottom = "15px";
    const providerLabel = this.drawerContent.createEl("label");
    providerLabel.textContent = "AI Provider:";
    providerLabel.style.display = "block";
    providerLabel.style.marginBottom = "5px";
    this.providerDropdown = this.drawerContent.createEl("select");
    this.providerDropdown.style.width = "100%";
    this.providerDropdown.style.padding = "5px";
    this.providerDropdown.style.marginBottom = "10px";
    this.options.providers.forEach((provider) => {
      const option = this.providerDropdown.createEl("option");
      option.value = provider;
      option.textContent = provider.charAt(0).toUpperCase() + provider.slice(1);
    });
    const modelLabel = this.drawerContent.createEl("label");
    modelLabel.textContent = "Model:";
    modelLabel.style.display = "block";
    modelLabel.style.marginBottom = "5px";
    this.modelDropdown = this.drawerContent.createEl("select");
    this.modelDropdown.style.width = "100%";
    this.modelDropdown.style.padding = "5px";
    this.modelDropdown.style.marginBottom = "10px";
    const models = ["gemini-2.5-pro", "gemini-1.5-pro", "gpt-4", "gpt-3.5-turbo"];
    models.forEach((model) => {
      const option = this.modelDropdown.createEl("option");
      option.value = model;
      option.textContent = model;
    });
    const tokensLabel = this.drawerContent.createEl("label");
    tokensLabel.textContent = "Max Tokens: 4096";
    tokensLabel.style.display = "block";
    tokensLabel.style.marginBottom = "5px";
    this.maxTokensSlider = this.drawerContent.createEl("input");
    this.maxTokensSlider.type = "range";
    this.maxTokensSlider.min = "256";
    this.maxTokensSlider.max = "8192";
    this.maxTokensSlider.value = "4096";
    this.maxTokensSlider.style.width = "100%";
    this.maxTokensSlider.style.marginBottom = "10px";
    this.maxTokensSlider.addEventListener("input", (e) => {
      const value = e.target.value;
      tokensLabel.textContent = `Max Tokens: ${value}`;
    });
    const tempLabel = this.drawerContent.createEl("label");
    tempLabel.textContent = "Temperature: 0.5";
    tempLabel.style.display = "block";
    tempLabel.style.marginBottom = "5px";
    this.temperatureSlider = this.drawerContent.createEl("input");
    this.temperatureSlider.type = "range";
    this.temperatureSlider.min = "0";
    this.temperatureSlider.max = "2";
    this.temperatureSlider.step = "0.1";
    this.temperatureSlider.value = "0.5";
    this.temperatureSlider.style.width = "100%";
    this.temperatureSlider.addEventListener("input", (e) => {
      const value = e.target.value;
      tempLabel.textContent = `Temperature: ${value}`;
    });
    this.drawerToggle.onclick = () => {
      console.log("Drawer button clicked!");
      if (this.drawerContent.style.display === "none") {
        this.drawerContent.style.display = "block";
        this.drawerToggle.textContent = "\u{1F916} Advanced AI Settings \u25BC";
      } else {
        this.drawerContent.style.display = "none";
        this.drawerToggle.textContent = "\u{1F916} Advanced AI Settings \u25B6";
      }
    };
    this.drawerToggle.addEventListener("click", (e) => {
      console.log("Click event fired!", e);
      e.preventDefault();
      e.stopPropagation();
    });
  }
  /**
   * Create provider selection section for drawer (modified version)
   */
  createProviderSelectionSectionForDrawer(container) {
    const sectionContainer = container.createDiv();
    sectionContainer.style.padding = "12px";
    sectionContainer.style.backgroundColor = "var(--background-secondary)";
    sectionContainer.style.borderRadius = "6px";
    sectionContainer.style.border = "1px solid var(--background-modifier-border)";
    const label = sectionContainer.createEl("label", { text: "\u{1F916} AI Provider & Model:" });
    label.setAttribute("for", "ytc-provider-select");
    label.style.display = "block";
    label.style.marginBottom = "8px";
    label.style.fontWeight = "500";
    label.style.color = "var(--text-normal)";
    const row = sectionContainer.createDiv();
    row.style.display = "flex";
    row.style.gap = "8px";
    row.style.alignItems = "center";
    this.providerSelect = document.createElement("select");
    this.providerSelect.id = "ytc-provider-select";
    this.providerSelect.setAttribute("aria-label", "AI Provider");
    this.providerSelect.style.flex = "1";
    this.providerSelect.style.padding = "4px 8px";
    this.providerSelect.style.borderRadius = "4px";
    this.providerSelect.style.border = "1px solid var(--background-modifier-border)";
    row.appendChild(this.providerSelect);
    this.modelSelect = document.createElement("select");
    this.modelSelect.setAttribute("aria-label", "AI Model");
    this.modelSelect.style.flex = "1";
    this.modelSelect.style.padding = "4px 8px";
    this.modelSelect.style.borderRadius = "4px";
    this.modelSelect.style.border = "1px solid var(--background-modifier-border)";
    row.appendChild(this.modelSelect);
    const refreshBtn = document.createElement("button");
    refreshBtn.textContent = "\u{1F504}";
    refreshBtn.style.padding = "4px 8px";
    refreshBtn.style.borderRadius = "4px";
    refreshBtn.style.border = "1px solid var(--background-modifier-border)";
    refreshBtn.style.cursor = "pointer";
    refreshBtn.setAttribute("aria-label", "Refresh model list");
    refreshBtn.addEventListener("click", () => this.handleRefreshModels());
    row.appendChild(refreshBtn);
    this.refreshSpinner = document.createElement("span");
    this.refreshSpinner.textContent = "\u23F3";
    this.refreshSpinner.style.display = "none";
    this.refreshSpinner.style.marginLeft = "4px";
    row.appendChild(this.refreshSpinner);
    this.setupProviderModelHandlers();
  }
  /**
   * Create model parameters section for drawer (modified version)
   */
  createModelParametersSectionForDrawer(container) {
    const paramsContainer = container.createDiv();
    paramsContainer.className = "ytc-model-params-section";
    paramsContainer.style.padding = "12px";
    paramsContainer.style.backgroundColor = "var(--background-secondary)";
    paramsContainer.style.borderRadius = "6px";
    paramsContainer.style.border = "1px solid var(--background-modifier-border)";
    const header = paramsContainer.createEl("h4");
    header.textContent = "\u2699\uFE0F Model Parameters";
    header.style.margin = "0 0 12px 0";
    header.style.fontSize = "0.95rem";
    header.style.color = "var(--text-normal)";
    const maxTokensContainer = paramsContainer.createDiv();
    maxTokensContainer.style.marginBottom = "12px";
    const maxTokensLabel = maxTokensContainer.createDiv();
    maxTokensLabel.textContent = "Max Tokens: " + this.maxTokens;
    maxTokensLabel.style.fontSize = "0.85rem";
    maxTokensLabel.style.fontWeight = "500";
    maxTokensLabel.style.marginBottom = "6px";
    maxTokensLabel.style.color = "var(--text-normal)";
    this.maxTokensSlider = document.createElement("input");
    this.maxTokensSlider.type = "range";
    this.maxTokensSlider.min = "256";
    this.maxTokensSlider.max = "8192";
    this.maxTokensSlider.step = "256";
    this.maxTokensSlider.value = this.maxTokens.toString();
    this.maxTokensSlider.style.width = "100%";
    this.maxTokensSlider.style.height = "4px";
    this.maxTokensSlider.className = "ytc-model-slider";
    maxTokensContainer.appendChild(this.maxTokensSlider);
    this.maxTokensValue = document.createElement("span");
    this.maxTokensValue.textContent = this.maxTokens.toString();
    this.maxTokensValue.style.fontSize = "0.8rem";
    this.maxTokensValue.style.fontWeight = "600";
    this.maxTokensValue.style.color = "var(--text-accent)";
    this.maxTokensValue.style.marginLeft = "8px";
    maxTokensContainer.appendChild(this.maxTokensValue);
    const tempContainer = paramsContainer.createDiv();
    const tempLabel = tempContainer.createDiv();
    tempLabel.textContent = "Temperature: " + this.temperature.toFixed(1);
    tempLabel.style.fontSize = "0.85rem";
    tempLabel.style.fontWeight = "500";
    tempLabel.style.marginBottom = "6px";
    tempLabel.style.color = "var(--text-normal)";
    this.temperatureSlider = document.createElement("input");
    this.temperatureSlider.type = "range";
    this.temperatureSlider.min = "0";
    this.temperatureSlider.max = "2";
    this.temperatureSlider.step = "0.1";
    this.temperatureSlider.value = this.temperature.toString();
    this.temperatureSlider.style.width = "100%";
    this.temperatureSlider.style.height = "4px";
    this.temperatureSlider.className = "ytc-model-slider";
    tempContainer.appendChild(this.temperatureSlider);
    this.temperatureValue = document.createElement("span");
    this.temperatureValue.textContent = this.temperature.toFixed(1);
    this.temperatureValue.style.fontSize = "0.8rem";
    this.temperatureValue.style.fontWeight = "600";
    this.temperatureValue.style.color = "var(--text-accent)";
    this.temperatureValue.style.marginLeft = "8px";
    tempContainer.appendChild(this.temperatureValue);
    const scaleContainer = paramsContainer.createDiv();
    scaleContainer.style.display = "flex";
    scaleContainer.style.justifyContent = "space-between";
    scaleContainer.style.fontSize = "0.75rem";
    scaleContainer.style.color = "var(--text-muted)";
    scaleContainer.style.marginTop = "4px";
    scaleContainer.createSpan({ text: "Precise" });
    scaleContainer.createSpan({ text: "Creative" });
    this.setupSliderEventHandlers();
  }
  /**
   * Create progress section
   */
  createProgressSection() {
    if (this.progressContainer) {
      this.progressContainer.remove();
      this.progressSteps = [];
    }
    this.progressContainer = this.contentEl.createDiv();
    this.progressContainer.setAttribute("role", "region");
    this.progressContainer.setAttribute("aria-label", "Processing progress");
    this.progressContainer.setAttribute("aria-live", "polite");
    this.progressContainer.style.marginTop = "16px";
    this.progressContainer.style.display = "none";
    this.progressText = this.progressContainer.createDiv();
    this.progressText.id = "progress-text";
    this.progressText.style.marginBottom = "8px";
    this.progressText.style.fontWeight = "500";
    this.progressText.style.color = "var(--text-accent)";
    this.progressText.textContent = "Processing video...";
    const progressBarContainer = this.progressContainer.createDiv();
    progressBarContainer.setAttribute("role", "progressbar");
    progressBarContainer.setAttribute("aria-valuenow", "0");
    progressBarContainer.setAttribute("aria-valuemin", "0");
    progressBarContainer.setAttribute("aria-valuemax", "100");
    progressBarContainer.setAttribute("aria-labelledby", "progress-text");
    progressBarContainer.style.width = "100%";
    progressBarContainer.style.height = "6px";
    progressBarContainer.style.backgroundColor = "var(--background-modifier-border)";
    progressBarContainer.style.borderRadius = "3px";
    progressBarContainer.style.overflow = "hidden";
    this.progressBar = progressBarContainer.createDiv();
    this.progressBar.style.height = "100%";
    this.progressBar.style.backgroundColor = "var(--text-accent)";
    this.progressBar.style.borderRadius = "3px";
    this.progressBar.style.width = "0%";
    this.progressBar.style.transition = "width 0.3s ease";
    const stepList = this.progressContainer.createEl("ol");
    stepList.setAttribute("aria-label", "Processing steps");
    stepList.style.marginTop = "12px";
    stepList.style.paddingLeft = "20px";
    stepList.style.fontSize = "0.9rem";
    stepList.style.color = "var(--text-normal)";
    const labels = [
      "Validate URL",
      "Fetch video info",
      "Run AI analysis",
      "Save note"
    ];
    this.progressSteps = labels.map((label, index) => {
      const item = stepList.createEl("li");
      item.setAttribute("role", "status");
      item.style.marginBottom = "4px";
      item.textContent = `\u25CB ${label}`;
      return { label, element: item };
    });
  }
  /**
   * Create action buttons with accessibility
   */
  createActionButtons() {
    const container = this.createButtonContainer();
    const cancelBtn = this.createButton(
      container,
      MESSAGES.MODALS.CANCEL,
      false,
      () => this.close()
    );
    cancelBtn.setAttribute("aria-label", "Cancel video processing");
    this.processButton = this.createButton(
      container,
      MESSAGES.MODALS.PROCESS,
      true,
      () => this.handleProcess()
    );
    this.processButton.setAttribute("aria-label", "Process YouTube video");
    this.openButton = this.createButton(
      container,
      "Open Note",
      true,
      () => this.handleOpenFile()
    );
    this.openButton.setAttribute("aria-label", "Open the processed note");
    this.openButton.style.display = "none";
    this.updateProcessButtonState();
  }
  /**
   * Create button container for action buttons
   */
  createButtonContainer() {
    const container = this.contentEl.createDiv();
    container.style.display = "flex";
    container.style.justifyContent = "center";
    container.style.gap = "12px";
    container.style.marginTop = "20px";
    container.style.padding = "0 16px";
    container.style.borderTop = "1px solid var(--background-modifier-border)";
    container.style.backgroundColor = "var(--background-primary)";
    return container;
  }
  /**
   * Create a button with consistent styling
   */
  createButton(container, text, isPrimary = false, onClick) {
    const button = container.createEl("button");
    button.textContent = text;
    button.style.padding = "8px 16px";
    button.style.borderRadius = "6px";
    button.style.border = "1px solid";
    button.style.cursor = "pointer";
    button.style.fontSize = "0.9rem";
    button.style.fontWeight = "500";
    button.style.transition = "all 0.2s ease";
    if (isPrimary) {
      button.style.backgroundColor = "var(--interactive-accent)";
      button.style.color = "var(--text-on-accent)";
      button.style.borderColor = "var(--interactive-accent)";
    } else {
      button.style.backgroundColor = "var(--background-secondary)";
      button.style.color = "var(--text-normal)";
      button.style.borderColor = "var(--background-modifier-border)";
    }
    button.addEventListener("mouseenter", () => {
      if (isPrimary) {
        button.style.backgroundColor = "var(--interactive-accent-hover)";
      } else {
        button.style.backgroundColor = "var(--background-modifier-hover)";
        button.style.borderColor = "var(--interactive-accent)";
      }
    });
    button.addEventListener("mouseleave", () => {
      if (isPrimary) {
        button.style.backgroundColor = "var(--interactive-accent)";
        button.style.color = "var(--text-on-accent)";
        button.style.borderColor = "var(--interactive-accent)";
      } else {
        button.style.backgroundColor = "var(--background-secondary)";
        button.style.color = "var(--text-normal)";
        button.style.borderColor = "var(--background-modifier-border)";
      }
    });
    if (onClick) {
      button.addEventListener("click", onClick);
    }
    return button;
  }
  /**
   * Set up event handlers
   */
  setupEventHandlers() {
    this.setupKeyHandlers(
      () => this.handleProcess(),
      () => this.close()
    );
    window.addEventListener("yt-clipper-retry-processing", this.handleRetry);
  }
  /**
   * Focus on URL input
   */
  focusUrlInput() {
    if (this.urlInput) {
      this.focusElement(this.urlInput);
    }
  }
  /**
   * Update process button enabled state (optimized with debouncing and memoization)
   */
  updateProcessButtonState() {
    if (!this.processButton)
      return;
    if (this.isProcessing) {
      return;
    }
    const trimmedUrl = this.url.trim();
    if (this.processButton && this.processButton.textContent !== MESSAGES.MODALS.PROCESS && trimmedUrl.length >= 0) {
      this.processButton.textContent = MESSAGES.MODALS.PROCESS;
    }
    if (trimmedUrl === this.lastValidUrl) {
      const isValid = this.lastValidResult;
      this.processButton.disabled = !isValid;
      this.processButton.style.opacity = isValid ? "1" : "0.5";
      if (trimmedUrl.length === 0) {
        this.setValidationMessage("Paste a YouTube link to begin processing.", "info");
        this.setUrlInputState("idle");
      } else {
        this.setValidationMessage(
          isValid ? "Ready to process this video." : "Enter a valid YouTube video URL.",
          isValid ? "success" : "error"
        );
        this.setUrlInputState(isValid ? "valid" : "invalid");
      }
      this.updateQuickActionsState();
      return;
    }
    if (this.validationTimer) {
      clearTimeout(this.validationTimer);
    }
    this.validationTimer = window.setTimeout(() => {
      const isValid = ValidationUtils.isValidYouTubeUrl(trimmedUrl);
      this.lastValidUrl = trimmedUrl;
      this.lastValidResult = isValid;
      this.processButton.disabled = !isValid;
      this.processButton.style.opacity = isValid ? "1" : "0.5";
      if (trimmedUrl.length === 0) {
        this.setValidationMessage("Paste a YouTube link to begin processing.", "info");
        this.setUrlInputState("idle");
      } else {
        this.setValidationMessage(
          isValid ? "Ready to process this video." : "Enter a valid YouTube video URL.",
          isValid ? "success" : "error"
        );
        this.setUrlInputState(isValid ? "valid" : "invalid");
      }
      this.updateQuickActionsState();
      if (isValid) {
        void this.maybeFetchPreview(trimmedUrl);
      } else {
        this.clearPreview();
      }
    }, 300);
  }
  /**
   * Validate URL input (simplified - used by debounced handler)
   */
  isUrlValid() {
    return ValidationUtils.isValidYouTubeUrl(this.url.trim());
  }
  /**
   * Handle process button click
   */
  async handleProcess() {
    var _a;
    const trimmedUrl = this.url.trim();
    if (!trimmedUrl) {
      new import_obsidian5.Notice(MESSAGES.ERRORS.ENTER_URL);
      this.focusUrlInput();
      return;
    }
    if (!this.isUrlValid()) {
      new import_obsidian5.Notice(MESSAGES.ERRORS.INVALID_URL);
      this.focusUrlInput();
      return;
    }
    try {
      if (this.selectedProvider === "Google Gemini" && this.selectedModel && this.isUrlValid()) {
        try {
          const models = PROVIDER_MODEL_OPTIONS["Google Gemini"] || [];
          const match = models.find((m) => {
            const name = typeof m === "string" ? m : m && m.name ? m.name : "";
            return String(name).toLowerCase() === String(this.selectedModel || "").toLowerCase();
          });
          const supportsAudioVideo = !!(match && match.supportsAudioVideo);
          if (!supportsAudioVideo) {
            const recommended = (models.find((m) => m && m.supportsAudioVideo) || { name: AI_MODELS.GEMINI }).name;
            const shouldSwitch = await this.showConfirmationModal(
              "Multimodal Model Recommended",
              `The selected model (${this.selectedModel}) may not support multimodal analysis.

Would you like to switch to a multimodal-capable model (${recommended}) for better video analysis?`,
              "Switch to Multimodal",
              "Keep Current Model",
              false
            );
            if (shouldSwitch) {
              if (this.modelSelect) {
                const exists = Array.from(this.modelSelect.options).some((o) => o.value === recommended);
                if (!exists) {
                  const opt = document.createElement("option");
                  opt.value = recommended;
                  opt.text = recommended;
                  this.modelSelect.appendChild(opt);
                }
                this.modelSelect.value = recommended;
                this.selectedModel = recommended;
              } else {
                this.selectedModel = recommended;
              }
            }
          }
        } catch (err) {
          console.warn("[YouTubeUrlModal] model recommendation failed", err);
        }
      }
      this.showProcessingState();
      this.setStepState(0, "active");
      this.updateProgress(20, "Validating YouTube URL...");
      await new Promise((resolve) => setTimeout(resolve, 500));
      this.setStepState(0, "complete");
      this.setStepState(1, "active");
      this.updateProgress(40, "Extracting video data...");
      await new Promise((resolve) => setTimeout(resolve, 500));
      this.setStepState(1, "complete");
      this.setStepState(2, "active");
      this.updateProgress(60, "Analyzing video content...");
      const customPrompt = this.format === "custom" ? (_a = this.customPromptInput) == null ? void 0 : _a.value : void 0;
      const filePath = await this.options.onProcess(
        trimmedUrl,
        this.format,
        this.selectedProvider,
        this.selectedModel,
        customPrompt,
        this.performanceMode,
        this.enableParallelProcessing,
        this.preferMultimodal,
        this.maxTokens,
        this.temperature
      );
      this.setStepState(2, "complete");
      this.setStepState(3, "active");
      this.updateProgress(80, "Generating note...");
      await new Promise((resolve) => setTimeout(resolve, 300));
      this.updateProgress(100, "Complete!");
      this.setStepState(3, "complete");
      this.processedFilePath = filePath;
      this.showCompletionState();
    } catch (error) {
      this.flagActiveStepAsError();
      this.showErrorState(error);
      ErrorHandler.handle(error, "YouTube URL processing");
    }
  }
  /**
   * Handle open file button click
   */
  async handleOpenFile() {
    if (this.processedFilePath && this.options.onOpenFile) {
      try {
        await this.options.onOpenFile(this.processedFilePath);
        this.close();
      } catch (error) {
        ErrorHandler.handle(error, "Opening file");
      }
    }
  }
  /**
   * Show processing state
   */
  showProcessingState() {
    this.isProcessing = true;
    this.setValidationMessage("Processing video. This may take a moment...", "info");
    this.resetProgressSteps();
    if (this.progressContainer) {
      this.progressContainer.style.display = "block";
    }
    if (this.urlInput) {
      this.urlInput.disabled = true;
    }
    if (this.processButton) {
      this.processButton.disabled = true;
      this.processButton.textContent = "Processing...";
    }
    if (this.openButton) {
      this.openButton.style.display = "none";
    }
    this.setUrlInputState("idle");
    this.updateQuickActionsState();
  }
  /**
   * Show completion state
   */
  showCompletionState() {
    this.isProcessing = false;
    if (this.progressContainer) {
      this.progressContainer.style.display = "none";
    }
    if (this.urlInput) {
      this.urlInput.disabled = false;
      this.urlInput.value = "";
      this.url = "";
    }
    if (this.processButton) {
      this.processButton.disabled = false;
      this.processButton.textContent = "Process Another";
      this.processButton.style.display = "inline-block";
      this.processButton.style.opacity = "1";
    }
    if (this.openButton) {
      this.openButton.style.display = "inline-block";
    }
    if (this.headerEl) {
      this.headerEl.textContent = "\u2705 Video Processed Successfully!";
    }
    this.setValidationMessage("Note saved to today's folder. You can open it now or process another video.", "success");
    this.focusUrlInput();
    this.updateQuickActionsState();
    this.setUrlInputState("idle");
  }
  /**
   * Show error state
   */
  showErrorState(error) {
    this.isProcessing = false;
    if (this.progressContainer) {
      this.progressContainer.style.display = "none";
    }
    if (this.urlInput) {
      this.urlInput.disabled = false;
    }
    if (this.processButton) {
      this.processButton.disabled = false;
      this.processButton.textContent = MESSAGES.MODALS.PROCESS;
      this.processButton.style.display = "inline-block";
    }
    if (this.openButton) {
      this.openButton.style.display = "none";
    }
    if (this.headerEl) {
      this.headerEl.textContent = "\u274C Processing Failed";
    }
    this.setValidationMessage(error.message, "error");
    this.updateQuickActionsState();
    this.setUrlInputState(this.url.trim().length > 0 ? "invalid" : "idle");
  }
  /**
   * Update progress bar and text
   */
  updateProgress(percent, text) {
    if (this.progressBar) {
      this.progressBar.style.width = `${percent}%`;
    }
    if (this.progressText) {
      this.progressText.textContent = text;
    }
  }
  /**
   * Set initial URL value
   */
  setUrl(url) {
    if (this.url.trim() === url.trim()) {
      console.debug("YouTubeUrlModal: setUrl called with same URL, preventing cycle");
      return;
    }
    this.url = url;
    if (this.urlInput) {
      this.urlInput.value = url;
      this.updateProcessButtonState();
      this.updateQuickActionsState();
      const trimmed = url.trim();
      if (trimmed.length === 0) {
        this.setUrlInputState("idle");
      } else {
        this.setUrlInputState(ValidationUtils.isValidYouTubeUrl(trimmed) ? "valid" : "invalid");
      }
    }
  }
  /**
   * Clean up resources when modal is closed
   */
  onClose() {
    if (this.validationTimer) {
      clearTimeout(this.validationTimer);
      this.validationTimer = void 0;
    }
    if (this.progressContainer) {
      this.progressContainer.remove();
      this.progressContainer = void 0;
    }
    this.progressSteps = [];
    window.removeEventListener("yt-clipper-retry-processing", this.handleRetry);
    super.onClose();
  }
  /**
   * Get current URL value
   */
  getUrl() {
    return this.url;
  }
  resetProgressSteps() {
    this.currentStepIndex = 0;
    if (this.progressSteps.length === 0) {
      return;
    }
    this.progressSteps.forEach((step) => {
      step.element.textContent = `\u25CB ${step.label}`;
    });
  }
  setStepState(index, state) {
    const target = this.progressSteps[index];
    if (!target) {
      return;
    }
    const prefix = this.getStepPrefix(state);
    target.element.textContent = `${prefix} ${target.label}`;
    if (state === "active") {
      this.currentStepIndex = index;
    } else if (state === "complete" && this.currentStepIndex === index) {
      this.currentStepIndex = Math.min(index + 1, this.progressSteps.length - 1);
    }
  }
  flagActiveStepAsError() {
    if (this.progressSteps.length === 0) {
      return;
    }
    this.setStepState(this.currentStepIndex, "error");
  }
  getStepPrefix(state) {
    switch (state) {
      case "active":
        return "\u25CF";
      case "complete":
        return "\u2714";
      case "error":
        return "\u26A0";
      default:
        return "\u25CB";
    }
  }
  createInlineButton(container, label, onClick) {
    const button = container.createEl("button", { text: label });
    button.style.padding = "6px 12px";
    button.style.fontSize = "0.85rem";
    button.style.borderRadius = "6px";
    button.style.border = "1px solid var(--background-modifier-border)";
    button.style.backgroundColor = "var(--background-primary)";
    button.style.color = "var(--text-normal)";
    button.style.cursor = "pointer";
    button.style.transition = "background-color 0.2s ease";
    button.addEventListener("mouseenter", () => {
      button.style.backgroundColor = "var(--background-modifier-hover)";
    });
    button.addEventListener("mouseleave", () => {
      button.style.backgroundColor = "var(--background-primary)";
    });
    button.addEventListener("click", onClick);
    return button;
  }
  async handlePasteFromClipboard() {
    if (this.isProcessing) {
      return;
    }
    if (!navigator.clipboard || !navigator.clipboard.readText) {
      this.setValidationMessage("Clipboard access is not available in this environment.", "error");
      new import_obsidian5.Notice("Clipboard access is not available.");
      return;
    }
    try {
      const text = await navigator.clipboard.readText();
      if (!text) {
        this.setValidationMessage("Clipboard is empty. Copy a YouTube URL first.", "info");
        return;
      }
      const trimmed = text.trim();
      this.url = trimmed;
      if (this.urlInput) {
        this.urlInput.value = trimmed;
      }
      this.lastValidUrl = void 0;
      this.updateProcessButtonState();
      this.updateQuickActionsState();
      const isValid = ValidationUtils.isValidYouTubeUrl(trimmed);
      this.setValidationMessage(
        isValid ? "Ready to process this video." : "Enter a valid YouTube video URL.",
        isValid ? "success" : "error"
      );
      this.setUrlInputState(isValid ? "valid" : "invalid");
      if (this.processButton && !this.isProcessing && isValid) {
        this.processButton.focus();
      } else {
        this.focusUrlInput();
      }
    } catch (error) {
      ErrorHandler.handle(error, "Reading clipboard", false);
      this.setValidationMessage("Could not read from clipboard. Paste manually instead.", "error");
      new import_obsidian5.Notice("Could not read from clipboard.");
    }
  }
  handleClearUrl() {
    if (this.isProcessing) {
      return;
    }
    this.url = "";
    if (this.urlInput) {
      this.urlInput.value = "";
    }
    this.lastValidUrl = void 0;
    this.updateProcessButtonState();
    this.updateQuickActionsState();
    this.setValidationMessage("Paste a YouTube link to begin processing.", "info");
    this.setUrlInputState("idle");
    this.focusUrlInput();
  }
  updateQuickActionsState() {
    const hasUrl = this.url.trim().length > 0;
    if (this.clearButton) {
      this.clearButton.disabled = !hasUrl || this.isProcessing;
      this.clearButton.style.opacity = this.clearButton.disabled ? "0.5" : "1";
    }
    if (this.pasteButton) {
      this.pasteButton.disabled = this.isProcessing;
      this.pasteButton.style.opacity = this.pasteButton.disabled ? "0.5" : "1";
    }
  }
  setUrlInputState(state) {
    if (!this.urlInput) {
      return;
    }
    let borderColor = "var(--background-modifier-border)";
    let boxShadow = "none";
    if (state === "valid") {
      borderColor = "var(--text-accent)";
      boxShadow = "0 0 0 1px var(--text-accent)";
    } else if (state === "invalid") {
      borderColor = "var(--text-error)";
      boxShadow = "0 0 0 1px var(--text-error)";
    }
    this.urlInput.style.borderColor = borderColor;
    this.urlInput.style.boxShadow = boxShadow;
  }
  setValidationMessage(message, type) {
    if (!this.validationMessage) {
      return;
    }
    this.validationMessage.textContent = message;
    let color = "var(--text-muted)";
    if (type === "error") {
      color = "var(--text-error)";
    } else if (type === "success") {
      color = "var(--text-accent)";
    } else {
      color = "var(--text-muted)";
    }
    this.validationMessage.style.color = color;
  }
  /**
   * Try to fetch a lightweight preview for the provided YouTube URL using oEmbed.
   */
  async maybeFetchPreview(url) {
    if (this.fetchInProgress)
      return;
    if (!url)
      return;
    if (this.lastValidUrl === url && this.thumbnailEl && this.thumbnailEl.style.display === "block") {
      return;
    }
    this.setFetchingState(true);
    try {
      const meta = await this.fetchVideoPreview(url);
      if (meta) {
        this.showPreview(meta);
      } else {
        this.clearPreview();
      }
    } catch (error) {
      this.clearPreview();
    } finally {
      this.setFetchingState(false);
    }
  }
  setFetchingState(isFetching) {
    var _a;
    this.fetchInProgress = isFetching;
    if (this.processButton) {
      this.processButton.disabled = isFetching || !((_a = this.lastValidResult) != null ? _a : false);
      this.processButton.style.opacity = this.processButton.disabled ? "0.5" : "1";
    }
    if (this.validationMessage) {
      if (isFetching)
        this.setValidationMessage("Fetching preview...", "info");
      else if (this.lastValidResult)
        this.setValidationMessage("Ready to process this video.", "success");
      else
        this.setValidationMessage("Enter a valid YouTube video URL.", "error");
    }
  }
  async fetchVideoPreview(url) {
    try {
      const oembed = `https://www.youtube.com/oembed?url=${encodeURIComponent(url)}&format=json`;
      const res = await fetch(oembed);
      if (!res.ok)
        return null;
      const data = await res.json();
      return {
        title: data.title || "",
        author: data.author_name || "",
        thumbnail: data.thumbnail_url || ""
      };
    } catch (error) {
      return null;
    }
  }
  showPreview(meta) {
    if (!this.thumbnailEl || !this.metadataContainer)
      return;
    if (meta.thumbnail) {
      this.thumbnailEl.src = meta.thumbnail;
      this.thumbnailEl.style.display = "block";
    } else {
      this.thumbnailEl.style.display = "none";
    }
    const titleEl = this.metadataContainer.querySelector(".yt-preview-title");
    const channelEl = this.metadataContainer.querySelector(".yt-preview-channel");
    if (titleEl) {
      titleEl.textContent = meta.title;
      titleEl.style.fontWeight = "600";
      titleEl.style.marginBottom = "4px";
    }
    if (channelEl) {
      channelEl.textContent = meta.author;
      channelEl.style.color = "var(--text-muted)";
      channelEl.style.fontSize = "0.85rem";
    }
    this.metadataContainer.style.display = "block";
  }
  clearPreview() {
    if (this.thumbnailEl) {
      this.thumbnailEl.src = "";
      this.thumbnailEl.style.display = "none";
    }
    if (this.metadataContainer) {
      const titleEl = this.metadataContainer.querySelector(".yt-preview-title");
      const channelEl = this.metadataContainer.querySelector(".yt-preview-channel");
      if (titleEl)
        titleEl.textContent = "";
      if (channelEl)
        channelEl.textContent = "";
      this.metadataContainer.style.display = "none";
    }
  }
};

// src/settings-tab.ts
var import_obsidian6 = require("obsidian");

// src/secure-config.ts
var SecureConfigService = class {
  constructor(settings) {
    this.settings = settings;
  }
  /**
   * Get API key with environment variable fallback
   */
  getApiKey(keyType) {
    if (this.settings.useEnvironmentVariables) {
      return this.getFromEnvironment(keyType);
    }
    return keyType === "gemini" ? this.settings.geminiApiKey : this.settings.groqApiKey;
  }
  /**
   * Get API key from environment variables
   */
  getFromEnvironment(keyType) {
    const prefix = this.settings.environmentPrefix || "YTC";
    const envVarName = `${prefix}_${keyType.toUpperCase()}_API_KEY`;
    return this.getSecureEnvVar(envVarName) || "";
  }
  /**
   * Secure environment variable access
   * Note: In Obsidian plugins, environment variables are limited
   * This method can be extended for server-side environments
   */
  getSecureEnvVar(varName) {
    if (typeof process !== "undefined" && process.env) {
      return process.env[varName];
    }
    return this.getFromSecureStorage(varName);
  }
  /**
   * Get from secure storage (implementation depends on environment)
   */
  getFromSecureStorage(varName) {
    return void 0;
  }
  /**
   * Validate configuration security
   */
  validateSecurityConfiguration() {
    const warnings = [];
    let isSecure = true;
    if (!this.settings.useEnvironmentVariables) {
      if (this.settings.geminiApiKey && this.settings.geminiApiKey.length > 0) {
        warnings.push("Gemini API key is stored directly in configuration. Consider using environment variables.");
        isSecure = false;
      }
      if (this.settings.groqApiKey && this.settings.groqApiKey.length > 0) {
        warnings.push("Groq API key is stored directly in configuration. Consider using environment variables.");
        isSecure = false;
      }
    }
    if (this.settings.geminiApiKey === "your-api-key-here" || this.settings.groqApiKey === "your-api-key-here") {
      warnings.push("Default placeholder API keys detected. Please set real API keys.");
      isSecure = false;
    }
    return { isSecure, warnings };
  }
  /**
   * Get configuration template for environment variables
   */
  getEnvironmentTemplate() {
    const prefix = this.settings.environmentPrefix || "YTC";
    return `# YouTubeClipper Environment Variables
# Set these in your environment for secure API key management

# Google Gemini API Key
${prefix}_GEMINI_API_KEY=your_gemini_api_key_here

# Groq API Key  
${prefix}_GROQ_API_KEY=your_groq_api_key_here

# Usage:
# 1. Set these variables in your shell profile (.bashrc, .zshrc, etc.)
# 2. Enable "Use Environment Variables" in plugin settings
# 3. Restart Obsidian to pick up the new environment variables
`;
  }
};

// src/settings-tab.ts
var SETTINGS_CSS_CLASSES = {
  container: "ytc-settings-container",
  section: "ytc-settings-section",
  header: "ytc-settings-header",
  validation: "ytc-settings-validation"
};
var YouTubeSettingsTab = class extends import_obsidian6.PluginSettingTab {
  constructor(app, options) {
    super(app, options.plugin);
    this.options = options;
    this.validationErrors = [];
    this.settings = { ...options.plugin.settings };
    this.secureConfig = new SecureConfigService(this.settings);
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.addClass(SETTINGS_CSS_CLASSES.container);
    containerEl.setAttribute("data-plugin", "youtube-clipper");
    this.createSimpleWorkingLayout();
  }
  /**
   * Create simple working layout
   */
  createSimpleWorkingLayout() {
    const { containerEl } = this;
    containerEl.style.display = "flex";
    containerEl.style.flexDirection = "column";
    containerEl.style.height = "100%";
    containerEl.style.gap = "12px";
    containerEl.style.padding = "12px";
    containerEl.style.overflow = "hidden";
    containerEl.style.backgroundColor = "var(--background-primary)";
    this.createSimpleHeader();
    const mainContent = containerEl.createDiv();
    mainContent.style.display = "grid";
    mainContent.style.gridTemplateColumns = "1fr 1fr";
    mainContent.style.gap = "16px";
    mainContent.style.flex = "1";
    mainContent.style.overflow = "hidden";
    const mediaQuery = window.matchMedia("(max-width: 800px)");
    const updateLayout = (e) => {
      if (e.matches) {
        mainContent.style.gridTemplateColumns = "1fr";
        mainContent.style.gap = "12px";
      } else {
        mainContent.style.gridTemplateColumns = "1fr 1fr";
        mainContent.style.gap = "16px";
      }
    };
    mediaQuery.addEventListener("change", updateLayout);
    updateLayout(mediaQuery);
    this.createAPISettingsSection(mainContent);
    this.createAIParametersSection(mainContent);
    this.createFileSettingsSection(mainContent);
    this.createQuickStartSection(mainContent);
  }
  /**
   * Create simple header
   */
  createSimpleHeader() {
    const { containerEl } = this;
    const header = containerEl.createDiv();
    header.style.display = "flex";
    header.style.alignItems = "center";
    header.style.justifyContent = "space-between";
    header.style.padding = "8px 12px";
    header.style.background = "var(--background-secondary)";
    header.style.borderRadius = "6px";
    header.style.border = "1px solid var(--background-modifier-border)";
    const title = header.createEl("h2", {
      text: "YouTubeClipper Settings",
      style: "margin: 0; font-size: 1.1rem; font-weight: 600; color: var(--text-normal);"
    });
    const hasValidConfig = this.validateConfiguration();
    const statusBadge = header.createDiv();
    statusBadge.style.padding = "4px 12px";
    statusBadge.style.borderRadius = "12px";
    statusBadge.style.fontSize = "0.75rem";
    statusBadge.style.fontWeight = "600";
    if (hasValidConfig) {
      statusBadge.style.background = "var(--interactive-accent)";
      statusBadge.style.color = "var(--text-on-accent)";
      statusBadge.textContent = "\u2713 Ready";
    } else {
      statusBadge.style.background = "var(--text-warning)";
      statusBadge.style.color = "var(--text-on-accent)";
      statusBadge.textContent = "\u26A0 Setup Needed";
    }
  }
  /**
   * Create API settings section
   */
  createAPISettingsSection(mainContent) {
    const section = mainContent.createDiv();
    section.style.background = "var(--background-secondary)";
    section.style.border = "1px solid var(--background-modifier-border)";
    section.style.borderRadius = "6px";
    section.style.padding = "12px";
    section.style.display = "flex";
    section.style.flexDirection = "column";
    section.style.gap = "8px";
    const header = section.createEl("h3", {
      text: "\u{1F511} API Configuration",
      style: "margin: 0 0 6px 0; font-size: 0.9rem; font-weight: 600; color: var(--text-normal);"
    });
    new import_obsidian6.Setting(section).setName("Gemini API Key").setDesc("Google Gemini API key for content processing").addText((text) => text.setPlaceholder("AIza...").setValue(this.settings.geminiApiKey || "").onChange(async (value) => {
      await this.updateSetting("geminiApiKey", value);
    }));
    new import_obsidian6.Setting(section).setName("Groq API Key").setDesc("Groq API key for fast processing").addText((text) => text.setPlaceholder("gsk_...").setValue(this.settings.groqApiKey || "").onChange(async (value) => {
      await this.updateSetting("groqApiKey", value);
    }));
    const testDiv = section.createDiv();
    testDiv.style.marginTop = "4px";
    new import_obsidian6.Setting(testDiv).setName("Test Connection").setDesc("Verify API keys").addButton((btn) => btn.setButtonText("Test").onClick(async () => {
      btn.setDisabled(true);
      btn.setButtonText("Testing...");
      try {
        await this.testAPIKeys();
        btn.setButtonText("\u2713 Success");
        setTimeout(() => {
          btn.setButtonText("Test");
          btn.setDisabled(false);
        }, 1500);
      } catch (error) {
        btn.setButtonText("\u2717 Failed");
        ErrorHandler.handle(error, "API key test failed", true);
        setTimeout(() => {
          btn.setButtonText("Test");
          btn.setDisabled(false);
        }, 1500);
      }
    }));
  }
  /**
   * Validate entire configuration
   */
  validateConfiguration() {
    var _a, _b;
    const hasApiKey = ((_a = this.settings.geminiApiKey) == null ? void 0 : _a.trim()) || ((_b = this.settings.groqApiKey) == null ? void 0 : _b.trim());
    const hasValidPath = ValidationUtils.isValidPath(this.settings.outputPath);
    return Boolean(hasApiKey && hasValidPath);
  }
  /**
   * Show inline documentation
   */
  showDocumentation() {
    window.open("https://github.com/youtube-clipper/obsidian-plugin#readme", "_blank");
  }
  /**
  * Create API configuration settings
  */
  createAPISettings(container = this.containerEl) {
    const apiHeader = container.createEl("h3", {
      text: "API Keys",
      style: "margin: 0 0 12px 0; font-size: 1rem; color: var(--text-normal);"
    });
    const geminiSetting = new import_obsidian6.Setting(container).setName("Gemini API Key").setDesc("Google Gemini API key").addText((text) => {
      const inputEl = text.setPlaceholder("sk-... (your key is encrypted)").setValue(this.settings.geminiApiKey || "").onChange(async (value) => {
        await this.updateSetting("geminiApiKey", value);
      }).inputEl;
      inputEl.type = "password";
      inputEl.style.fontFamily = "monospace";
      inputEl.style.letterSpacing = "0.1em";
      return text;
    });
    this.addKeyToggle(geminiSetting, this.settings.geminiApiKey);
    this.addKeyClearButton(geminiSetting, "geminiApiKey");
    const groqSetting = new import_obsidian6.Setting(container).setName("Groq API Key").setDesc("Groq API key (fast processing)").addText((text) => {
      const inputEl = text.setPlaceholder("gsk_... (your key is encrypted)").setValue(this.settings.groqApiKey || "").onChange(async (value) => {
        await this.updateSetting("groqApiKey", value);
      }).inputEl;
      inputEl.type = "password";
      inputEl.style.fontFamily = "monospace";
      inputEl.style.letterSpacing = "0.1em";
      return text;
    });
    this.addKeyToggle(groqSetting, this.settings.groqApiKey);
    this.addKeyClearButton(groqSetting, "groqApiKey");
    const testSection = container.createDiv("ytc-test-connection");
    testSection.style.marginTop = "8px";
    testSection.style.paddingTop = "8px";
    testSection.style.borderTop = "1px solid var(--background-modifier-border)";
    new import_obsidian6.Setting(testSection).setName("Test Connection").setDesc("Verify API keys").addButton((btn) => btn.setButtonText("Test").onClick(async () => {
      btn.setDisabled(true);
      btn.setButtonText("...");
      try {
        await this.testAPIKeys();
        btn.setButtonText("\u2713 OK");
        setTimeout(() => {
          btn.setButtonText("Test");
          btn.setDisabled(false);
        }, 1500);
      } catch (error) {
        btn.setButtonText("\u2717 Error");
        ErrorHandler.handle(error, "API key test failed", true);
        setTimeout(() => {
          btn.setButtonText("Test");
          btn.setDisabled(false);
        }, 1500);
      }
    }));
  }
  /**
   * Add show/hide toggle for sensitive API keys
   */
  addKeyToggle(setting, keyValue) {
    const toggleBtn = setting.addButton((btn) => btn.setButtonText("\u{1F441}\uFE0F Show").setTooltip("Toggle key visibility").onClick((e) => {
      const inputs = setting.settingEl.querySelectorAll('input[type="password"], input[type="text"]');
      if (inputs.length === 0)
        return;
      const input = inputs[0];
      const isPassword = input.type === "password";
      input.type = isPassword ? "text" : "password";
      btn.setButtonText(isPassword ? "\u{1F441}\uFE0F\u200D\u{1F5E8}\uFE0F Hide" : "\u{1F441}\uFE0F Show");
    }));
  }
  /**
   * Add clear button to remove API key
   */
  addKeyClearButton(setting, settingKey) {
    const clearBtn = setting.addButton((btn) => btn.setButtonText("\u{1F5D1}\uFE0F Clear").setTooltip("Remove this API key").onClick(async () => {
      const keyName = settingKey === "geminiApiKey" ? "Gemini" : "Groq";
      if (confirm(`Are you sure you want to clear the ${keyName} API key?`)) {
        await this.updateSetting(settingKey, "");
        this.display();
      }
    }));
  }
  /**
   * Test API keys for validity
   */
  async testAPIKeys() {
    const errors = [];
    if (this.settings.geminiApiKey) {
      try {
        const response = await fetch(
          "https://generativelanguage.googleapis.com/v1beta/models?key=" + this.settings.geminiApiKey
        );
        if (!response.ok) {
          errors.push(`Gemini API key invalid (${response.status})`);
        }
      } catch (error) {
        errors.push("Gemini API key test failed (network error)");
      }
    } else {
      errors.push("Gemini API key not configured");
    }
    if (errors.length > 0) {
      throw new Error(errors.join("\n"));
    }
  }
  /**
   * Create AI parameters section
   */
  createAIParametersSection(mainContent) {
    const section = mainContent.createDiv();
    section.style.background = "var(--background-secondary)";
    section.style.border = "1px solid var(--background-modifier-border)";
    section.style.borderRadius = "6px";
    section.style.padding = "12px";
    section.style.display = "flex";
    section.style.flexDirection = "column";
    section.style.gap = "8px";
    const header = section.createEl("h3", {
      text: "\u2699\uFE0F AI Model Defaults",
      style: "margin: 0 0 4px 0; font-size: 0.9rem; font-weight: 600; color: var(--text-normal);"
    });
    const styleSheet = document.createElement("style");
    styleSheet.textContent = `
            .ytc-slider {
                width: 100% !important;
                height: 8px !important;
                border-radius: 4px !important;
                background: var(--interactive-normal) !important;
                outline: none !important;
                -webkit-appearance: none !important;
                appearance: none !important;
                cursor: pointer !important;
            }
            .ytc-slider:hover {
                background: var(--interactive-hover) !important;
            }
            .ytc-slider::-webkit-slider-thumb {
                -webkit-appearance: none !important;
                appearance: none !important;
                width: 18px !important;
                height: 18px !important;
                background: var(--interactive-accent) !important;
                border-radius: 50% !important;
                cursor: pointer !important;
                border: 2px solid var(--text-on-accent) !important;
                box-shadow: 0 2px 4px rgba(0,0,0,0.2) !important;
            }
            .ytc-slider::-moz-range-thumb {
                width: 18px !important;
                height: 18px !important;
                background: var(--interactive-accent) !important;
                border-radius: 50% !important;
                cursor: pointer !important;
                border: 2px solid var(--text-on-accent) !important;
                box-shadow: 0 2px 4px rgba(0,0,0,0.2) !important;
            }
            .ytc-slider::-webkit-slider-thumb:hover {
                transform: scale(1.1) !important;
            }
            .ytc-slider::-moz-range-thumb:hover {
                transform: scale(1.1) !important;
            }
        `;
    document.head.appendChild(styleSheet);
    const createCompactSlider = (label, min, max, step, value, settingKey) => {
      const container = section.createDiv();
      container.style.marginBottom = "6px";
      const labelRow = container.createDiv();
      labelRow.style.display = "flex";
      labelRow.style.justifyContent = "space-between";
      labelRow.style.alignItems = "center";
      labelRow.style.marginBottom = "4px";
      const labelText = labelRow.createSpan();
      labelText.textContent = label;
      labelText.style.fontSize = "0.85rem";
      labelText.style.fontWeight = "500";
      labelText.style.color = "var(--text-normal)";
      const valueText = labelRow.createSpan();
      valueText.textContent = value.toString();
      valueText.style.fontSize = "0.8rem";
      valueText.style.fontWeight = "600";
      valueText.style.color = "var(--interactive-accent)";
      valueText.style.padding = "2px 6px";
      valueText.style.background = "var(--background-primary)";
      valueText.style.borderRadius = "4px";
      valueText.style.border = "1px solid var(--interactive-accent)";
      const slider = container.createEl("input", { type: "range" });
      slider.className = "ytc-slider";
      slider.min = min.toString();
      slider.max = max.toString();
      slider.step = step.toString();
      slider.value = value.toString();
      slider.addEventListener("input", () => {
        valueText.textContent = settingKey === "defaultTemperature" ? parseFloat(slider.value).toFixed(1) : slider.value;
      });
      slider.addEventListener("change", async () => {
        const finalValue = settingKey === "defaultTemperature" ? parseFloat(slider.value) : parseInt(slider.value);
        await this.updateSetting(settingKey, finalValue);
      });
      return container;
    };
    createCompactSlider(
      "Max Tokens",
      256,
      8192,
      256,
      this.settings.defaultMaxTokens || 4096,
      "defaultMaxTokens"
    );
    createCompactSlider(
      "Temperature",
      0,
      2,
      0.1,
      this.settings.defaultTemperature || 0.5,
      "defaultTemperature"
    );
    const scaleDiv = section.createDiv();
    scaleDiv.style.display = "flex";
    scaleDiv.style.justifyContent = "space-between";
    scaleDiv.style.fontSize = "0.7rem";
    scaleDiv.style.color = "var(--text-muted)";
    scaleDiv.style.marginTop = "-4px";
    scaleDiv.style.padding = "0 4px";
    scaleDiv.createSpan({ text: "Precise" });
    scaleDiv.createSpan({ text: "Creative" });
  }
  /**
   * Create security configuration settings
   */
  createSecuritySettings(container = this.containerEl) {
    container.createEl("h3", {
      text: "Security",
      style: "margin: 0 0 12px 0; font-size: 1rem; color: var(--text-normal);"
    });
    new import_obsidian6.Setting(container).setName("Use Environment Variables").setDesc("Load API keys from environment variables instead of storing them in configuration").addToggle((toggle) => toggle.setValue(this.settings.useEnvironmentVariables || false).onChange(async (value) => {
      await this.updateSetting("useEnvironmentVariables", value);
      this.display();
    }));
    if (this.settings.useEnvironmentVariables) {
      new import_obsidian6.Setting(container).setName("Environment Variable Prefix").setDesc("Prefix for environment variable names").addText((text) => text.setPlaceholder("YTC").setValue(this.settings.environmentPrefix || "YTC").onChange(async (value) => {
        await this.updateSetting("environmentPrefix", value || "YTC");
      }));
      const envTemplate = this.secureConfig.getEnvironmentTemplate();
      const envSection = container.createDiv("ytc-env-template");
      envSection.style.marginTop = "8px";
      envSection.style.padding = "8px";
      envSection.style.backgroundColor = "var(--background-primary)";
      envSection.style.borderRadius = "4px";
      envSection.style.border = "1px solid var(--background-modifier-border)";
      const envTitle = envSection.createEl("h4", {
        text: "Environment Variables",
        style: "margin: 0 0 4px 0; font-size: 0.8rem;"
      });
      const preEl = envSection.createEl("pre");
      preEl.style.margin = "0";
      preEl.style.fontSize = "0.7rem";
      preEl.style.lineHeight = "1.2";
      preEl.createEl("code", { text: envTemplate });
      const copyBtn = envSection.createEl("button", {
        text: "\u{1F4CB} Copy",
        style: "margin-top: 6px; padding: 2px 6px; font-size: 0.7rem; border-radius: 3px; border: 1px solid var(--background-modifier-border); background: var(--interactive-normal); cursor: pointer;"
      });
      copyBtn.addEventListener("click", () => {
        navigator.clipboard.writeText(envTemplate);
        copyBtn.textContent = "\u2713 Copied";
        setTimeout(() => copyBtn.textContent = "\u{1F4CB} Copy", 1500);
      });
    }
    const validation = this.secureConfig.validateSecurityConfiguration();
    if (!validation.isSecure) {
      const warningEl = container.createDiv("ytc-security-warnings");
      warningEl.style.marginTop = "8px";
      warningEl.style.padding = "6px";
      warningEl.style.backgroundColor = "var(--background-warning)";
      warningEl.style.borderRadius = "4px";
      warningEl.style.fontSize = "0.75rem";
      warningEl.style.color = "var(--text-warning)";
      warningEl.createEl("div", { text: "\u26A0\uFE0F " + validation.warnings.join(" ") });
    }
  }
  /**
   * Create file settings section
   */
  createFileSettingsSection(mainContent) {
    const section = mainContent.createDiv();
    section.style.background = "var(--background-secondary)";
    section.style.border = "1px solid var(--background-modifier-border)";
    section.style.borderRadius = "6px";
    section.style.padding = "12px";
    section.style.display = "flex";
    section.style.flexDirection = "column";
    section.style.gap = "8px";
    const header = section.createEl("h3", {
      text: "\u{1F4C1} File Configuration",
      style: "margin: 0 0 4px 0; font-size: 0.9rem; font-weight: 600; color: var(--text-normal);"
    });
    new import_obsidian6.Setting(section).setName("Output Path").setDesc("Folder for processed videos (relative to vault root)").addText((text) => text.setPlaceholder("YouTube/Processed Videos").setValue(this.settings.outputPath).onChange(async (value) => {
      await this.updateSetting("outputPath", value);
    }));
  }
  /**
   * Create validation status display
   */
  createValidationStatus() {
    const { containerEl } = this;
    if (this.validationErrors.length > 0) {
      const errorSection = containerEl.createDiv();
      errorSection.style.marginTop = "20px";
      errorSection.style.padding = "10px";
      errorSection.style.backgroundColor = "var(--background-modifier-error)";
      errorSection.style.borderRadius = "4px";
      errorSection.createEl("h4", {
        text: "\u26A0\uFE0F Configuration Issues",
        attr: { style: "color: var(--text-error); margin-top: 0;" }
      });
      const errorList = errorSection.createEl("ul");
      this.validationErrors.forEach((error) => {
        errorList.createEl("li", { text: error });
      });
    } else {
      const successSection = containerEl.createDiv();
      successSection.style.marginTop = "20px";
      successSection.style.padding = "10px";
      successSection.style.backgroundColor = "var(--background-modifier-success)";
      successSection.style.borderRadius = "4px";
      successSection.createEl("h4", {
        text: "\u2705 Configuration Valid",
        attr: { style: "color: var(--text-success); margin-top: 0;" }
      });
    }
  }
  /**
   * Create quick start section
   */
  createQuickStartSection(mainContent) {
    const section = mainContent.createDiv();
    section.style.background = "var(--background-secondary)";
    section.style.border = "1px solid var(--background-modifier-border)";
    section.style.borderRadius = "6px";
    section.style.padding = "12px";
    section.style.display = "flex";
    section.style.flexDirection = "column";
    section.style.gap = "8px";
    const header = section.createEl("h3", {
      text: "\u{1F680} Quick Start",
      style: "margin: 0 0 4px 0; font-size: 0.9rem; font-weight: 600; color: var(--text-normal);"
    });
    const stepsDiv = section.createDiv();
    stepsDiv.style.fontSize = "0.8rem";
    stepsDiv.style.lineHeight = "1.4";
    const steps = [
      "Add API key (Gemini/Groq)",
      "Configure AI defaults",
      "Click video icon or paste URL",
      "Process video to create notes"
    ];
    steps.forEach((step, index) => {
      const stepDiv = stepsDiv.createDiv();
      stepDiv.style.marginBottom = "4px";
      stepDiv.style.display = "flex";
      stepDiv.style.alignItems = "flex-start";
      stepDiv.style.gap = "6px";
      const stepNumber = stepDiv.createSpan();
      stepNumber.textContent = index + 1 + ".";
      stepNumber.style.color = "var(--interactive-accent)";
      stepNumber.style.fontWeight = "600";
      stepNumber.style.minWidth = "16px";
      const stepText = stepDiv.createSpan();
      stepText.textContent = step;
    });
    const linksDiv = section.createDiv();
    linksDiv.style.marginTop = "6px";
    linksDiv.style.paddingTop = "8px";
    linksDiv.style.borderTop = "1px solid var(--background-modifier-border)";
    linksDiv.style.fontSize = "0.75rem";
    linksDiv.style.color = "var(--text-muted)";
    const linksLabel = linksDiv.createSpan();
    linksLabel.textContent = "Get API Keys: ";
    linksLabel.style.fontWeight = "500";
    const geminiLink = linksDiv.createEl("a", {
      text: "Gemini",
      href: "https://aistudio.google.com/app/apikey",
      cls: "external-link"
    });
    geminiLink.style.marginRight = "8px";
    geminiLink.style.color = "var(--link-color)";
    const groqLink = linksDiv.createEl("a", {
      text: "Groq",
      href: "https://console.groq.com/keys",
      cls: "external-link"
    });
    groqLink.style.color = "var(--link-color)";
  }
  /**
   * Update a setting value
   */
  async updateSetting(key, value) {
    try {
      this.settings[key] = value;
      await this.validateAndSaveSettings();
    } catch (error) {
      ErrorHandler.handle(error, `Settings update for ${key}`);
    }
  }
  /**
   * Validate and save settings
   */
  async validateAndSaveSettings() {
    const validation = ValidationUtils.validateSettings(this.settings);
    this.validationErrors = validation.errors;
    if (validation.isValid) {
      await this.options.onSettingsChange(this.settings);
    }
    this.display();
  }
  /**
   * Get current settings
   */
  getSettings() {
    return { ...this.settings };
  }
  /**
   * Update settings from external source
   */
  updateSettings(newSettings) {
    this.settings = { ...newSettings };
    this.display();
  }
};

// src/services/ai-service.ts
init_api();

// src/performance.ts
var PERFORMANCE_PRESETS = {
  fast: {
    name: "Fast",
    description: "Maximum speed with optimized models and parallel processing. Best for quick summaries.",
    timeouts: {
      geminiTimeout: 15e3,
      groqTimeout: 1e4,
      metadataTimeout: 5e3
    },
    enableParallel: true,
    preferMultimodal: false,
    modelStrategy: {
      briefFormat: "llama-3.1-8b-instant",
      executiveSummary: "llama-3.3-70b-versatile",
      detailedGuide: "gemini-2.0-flash-lite",
      fallbackModel: "llama-3.1-8b-instant"
    }
  },
  balanced: {
    name: "Balanced",
    description: "Balanced speed and quality with multimodal analysis for detailed content.",
    timeouts: {
      geminiTimeout: 3e4,
      groqTimeout: 2e4,
      metadataTimeout: 1e4
    },
    enableParallel: true,
    preferMultimodal: true,
    modelStrategy: {
      briefFormat: "llama-3.1-8b-instant",
      executiveSummary: "gemini-2.0-flash-lite",
      detailedGuide: "gemini-2.5-flash",
      fallbackModel: "llama-3.3-70b-versatile"
    }
  },
  quality: {
    name: "Quality",
    description: "Maximum quality with comprehensive multimodal analysis. Slower but most detailed.",
    timeouts: {
      geminiTimeout: 6e4,
      groqTimeout: 3e4,
      metadataTimeout: 15e3
    },
    enableParallel: false,
    preferMultimodal: true,
    modelStrategy: {
      briefFormat: "gemini-2.0-flash-lite",
      executiveSummary: "gemini-2.5-flash",
      detailedGuide: "gemini-2.5-pro",
      fallbackModel: "gemini-2.0-flash"
    }
  }
};

// src/services/retry-service.ts
var RetryService = class {
  /**
   * Execute an operation with retry logic
   */
  static async executeWithRetry(operation, operationName, config = {}) {
    const finalConfig = { ...this.defaultConfig, ...config };
    const startTime = Date.now();
    let lastError;
    logger.info(`Starting retryable operation: ${operationName}`, "RetryService", {
      maxAttempts: finalConfig.maxAttempts,
      baseDelayMs: finalConfig.baseDelayMs
    });
    for (let attempt = 1; attempt <= finalConfig.maxAttempts; attempt++) {
      try {
        const result = await operation();
        const totalTime2 = Date.now() - startTime;
        logger.info(`Operation succeeded: ${operationName}`, "RetryService", {
          attempt,
          totalTimeMs: totalTime2
        });
        return {
          success: true,
          result,
          attempts: attempt,
          totalTimeMs: totalTime2
        };
      } catch (error) {
        lastError = error;
        logger.warn(`Operation failed: ${operationName}`, "RetryService", {
          attempt,
          error: lastError.message,
          willRetry: attempt < finalConfig.maxAttempts && this.isRetryableError(lastError, finalConfig)
        });
        if (attempt === finalConfig.maxAttempts || !this.isRetryableError(lastError, finalConfig)) {
          break;
        }
        const delay = this.calculateDelay(attempt, finalConfig);
        logger.debug(`Waiting ${delay}ms before retry`, "RetryService", {
          attempt,
          delay
        });
        await this.sleep(delay);
      }
    }
    const totalTime = Date.now() - startTime;
    logger.error(`Operation failed after all retries: ${operationName}`, "RetryService", {
      attempts: finalConfig.maxAttempts,
      totalTimeMs: totalTime,
      finalError: lastError == null ? void 0 : lastError.message
    });
    return {
      success: false,
      error: lastError,
      attempts: finalConfig.maxAttempts,
      totalTimeMs: totalTime
    };
  }
  /**
   * Execute with simple retry (for backward compatibility)
   */
  static async withRetry(operation, operationName, maxAttempts = 3, baseDelayMs = 1e3) {
    const result = await this.executeWithRetry(operation, operationName, {
      maxAttempts,
      baseDelayMs
    });
    if (result.success) {
      return result.result;
    } else {
      throw result.error || new Error("Operation failed after retries");
    }
  }
  /**
   * Check if an error is retryable
   */
  static isRetryableError(error, config) {
    const errorMessage = error.message.toLowerCase();
    const errorName = error.name.toLowerCase();
    for (const retryableError of config.retryableErrors) {
      if (errorMessage.includes(retryableError.toLowerCase()) || errorName.includes(retryableError.toLowerCase())) {
        return true;
      }
    }
    if ("status" in error) {
      const status = error.status;
      return config.retryableStatusCodes.includes(status);
    }
    if (error instanceof TypeError && error.message.includes("fetch")) {
      return true;
    }
    return false;
  }
  /**
   * Calculate delay with exponential backoff and optional jitter
   */
  static calculateDelay(attempt, config) {
    let delay = config.baseDelayMs * Math.pow(config.backoffFactor, attempt - 1);
    delay = Math.min(delay, config.maxDelayMs);
    if (config.jitter) {
      const jitterAmount = delay * 0.25;
      delay = delay + (Math.random() - 0.5) * 2 * jitterAmount;
    }
    return Math.floor(delay);
  }
  /**
   * Sleep for specified milliseconds
   */
  static sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
  /**
   * Create a wrapped fetch with retry logic
   */
  static createRetryableFetch(input, init, retryConfig) {
    return this.withRetry(
      async () => {
        const response = await fetch(input, init);
        if (!response.ok) {
          const error = new Error(`HTTP ${response.status}: ${response.statusText}`);
          error.status = response.status;
          error.statusText = response.statusText;
          throw error;
        }
        return response;
      },
      `fetch: ${typeof input === "string" ? input : "request"}`,
      (retryConfig == null ? void 0 : retryConfig.maxAttempts) || 3,
      (retryConfig == null ? void 0 : retryConfig.baseDelayMs) || 1e3
    );
  }
  /**
   * Execute multiple operations concurrently with individual retry logic
   */
  static async executeWithRetryConcurrently(operations) {
    logger.info(`Executing ${operations.length} operations concurrently with retry`, "RetryService");
    const promises = operations.map(
      ({ operation, name, config }) => this.executeWithRetry(operation, name, config)
    );
    const results = await Promise.all(promises);
    const successfulCount = results.filter((r) => r.success).length;
    const failedCount = results.length - successfulCount;
    logger.info(`Concurrent operations completed`, "RetryService", {
      total: results.length,
      successful: successfulCount,
      failed: failedCount
    });
    return results;
  }
  /**
   * Execute operations in series with retry logic
   */
  static async executeWithRetrySeries(operations) {
    logger.info(`Executing ${operations.length} operations in series with retry`, "RetryService");
    const results = [];
    for (const { operation, name, config, continueOnError = false } of operations) {
      const result = await this.executeWithRetry(operation, name, config);
      results.push(result);
      if (!result.success && !continueOnError) {
        logger.info(`Stopping series execution due to failure in: ${name}`, "RetryService");
        break;
      }
    }
    const successfulCount = results.filter((r) => r.success).length;
    const failedCount = results.length - successfulCount;
    logger.info(`Series operations completed`, "RetryService", {
      total: results.length,
      successful: successfulCount,
      failed: failedCount
    });
    return results;
  }
};
RetryService.defaultConfig = {
  maxAttempts: 3,
  baseDelayMs: 1e3,
  maxDelayMs: 3e4,
  backoffFactor: 2,
  retryableErrors: [
    "ECONNRESET",
    "ECONNREFUSED",
    "ETIMEDOUT",
    "ENOTFOUND",
    "NETWORK_ERROR",
    "TIMEOUT",
    "Rate limit",
    "Quota exceeded",
    "Service unavailable"
  ],
  retryableStatusCodes: [408, 429, 500, 502, 503, 504],
  jitter: true
};
var retry = RetryService.withRetry;
var retryFetch = RetryService.createRetryableFetch;

// src/services/ai-service.ts
var AIService = class {
  constructor(providers, settings) {
    this.providers = [];
    if (!providers || providers.length === 0) {
      throw new Error(MESSAGES.ERRORS.MISSING_API_KEYS);
    }
    this.providers = providers;
    this.settings = settings;
    this.applyPerformanceSettings();
  }
  /**
   * Apply performance settings to providers
   */
  applyPerformanceSettings() {
    const preset = PERFORMANCE_PRESETS[this.settings.performanceMode] || PERFORMANCE_PRESETS.balanced;
    const timeouts = this.settings.customTimeouts || preset.timeouts;
    this.providers.forEach((provider) => {
      if (provider.name === "Google Gemini" && provider.setTimeout) {
        provider.setTimeout(timeouts.geminiTimeout);
      } else if (provider.name === "Groq" && provider.setTimeout) {
        provider.setTimeout(timeouts.groqTimeout);
      }
    });
  }
  /**
   * Update settings and reapply performance configurations
   */
  updateSettings(newSettings) {
    this.settings = newSettings;
    this.applyPerformanceSettings();
  }
  /**
   * Return available model options for a provider name (from constants mapping)
   */
  getProviderModels(providerName) {
    const raw = PROVIDER_MODEL_OPTIONS[providerName] || [];
    return raw.map((r) => typeof r === "string" ? r : r && r.name ? r.name : String(r));
  }
  /**
   * Best-effort fetch of latest models for all providers by scraping known provider pages.
   * Returns a mapping providerName -> list of discovered models. Falls back to static mapping.
   */
  async fetchLatestModels() {
    const result = {};
    const providers = this.getProviderNames();
    for (const p of providers) {
      try {
        const models = await this.fetchLatestModelsForProvider(p);
        result[p] = models.length > 0 ? models : PROVIDER_MODEL_OPTIONS[p] ? PROVIDER_MODEL_OPTIONS[p].map((m) => typeof m === "string" ? m : m.name) : [];
      } catch (error) {
        result[p] = PROVIDER_MODEL_OPTIONS[p] ? PROVIDER_MODEL_OPTIONS[p].map((m) => typeof m === "string" ? m : m.name) : [];
      }
    }
    return result;
  }
  /**
   * Fetch latest models for a single provider (best-effort scraping).
   */
  async fetchLatestModelsForProvider(providerName) {
    var _a;
    const url = PROVIDER_MODEL_LIST_URLS[providerName];
    const regex = PROVIDER_MODEL_REGEX[providerName];
    if (!url || !regex) {
      return PROVIDER_MODEL_OPTIONS[providerName] ? PROVIDER_MODEL_OPTIONS[providerName].map((m) => typeof m === "string" ? m : m.name) : [];
    }
    try {
      logger.debug(`Fetching latest models for ${providerName}`, "AIService", { url });
      const result = await RetryService.executeWithRetry(
        async () => {
          const resp = await RetryService.createRetryableFetch(url, {
            method: "GET",
            headers: {
              "User-Agent": "Mozilla/5.0 (compatible; YT-Clipper/1.3.5)"
            }
          }, {
            maxAttempts: 2,
            baseDelayMs: 1e3
          });
          if (!resp.ok) {
            const error = new Error(`HTTP ${resp.status}: ${resp.statusText}`);
            error.status = resp.status;
            throw error;
          }
          return resp;
        },
        `fetch-models-${providerName}`,
        {
          maxAttempts: 2,
          baseDelayMs: 1e3,
          retryableStatusCodes: [429, 500, 502, 503, 504]
        }
      );
      if (!result.success) {
        logger.warn(`Failed to fetch models for ${providerName}, using fallback`, "AIService", {
          error: (_a = result.error) == null ? void 0 : _a.message
        });
        return PROVIDER_MODEL_OPTIONS[providerName] ? PROVIDER_MODEL_OPTIONS[providerName].map((m) => typeof m === "string" ? m : m.name) : [];
      }
      const text = await result.result.text();
      const matches = text.match(regex) || [];
      const normalized = Array.from(new Set(matches.map((m) => m.toLowerCase())));
      logger.debug(`Found ${normalized.length} models for ${providerName}`, "AIService", {
        models: normalized.slice(0, 5)
        // Log first 5 for debugging
      });
      return normalized;
    } catch (error) {
      logger.error(`Error fetching models for ${providerName}`, "AIService", {
        error: error instanceof Error ? error.message : String(error),
        providerName
      });
      return PROVIDER_MODEL_OPTIONS[providerName] ? PROVIDER_MODEL_OPTIONS[providerName].map((m) => typeof m === "string" ? m : m.name) : [];
    }
  }
  /**
   * Process prompt with fallback support (original sequential method)
   */
  async process(prompt) {
    if (!prompt || typeof prompt !== "string") {
      throw new Error("Valid prompt is required");
    }
    if (this.settings.enableParallelProcessing) {
      return this.processParallel(prompt);
    }
    return this.processSequential(prompt);
  }
  /**
   * Process prompt with sequential fallback (original method)
   */
  async processSequential(prompt) {
    let lastError = null;
    for (const provider of this.providers) {
      try {
        logger.info(`Attempting to process with ${provider.name}`, "AIService", {
          model: provider.model
        });
        const content = await RetryService.withRetry(
          () => provider.process(prompt),
          `${provider.name}-process`,
          2,
          // 2 attempts per provider
          2e3
          // 2 second base delay
        );
        if (content && content.trim().length > 0) {
          logger.info(`Successfully processed with ${provider.name}`, "AIService", {
            model: provider.model,
            contentLength: content.length
          });
          return {
            content,
            provider: provider.name,
            model: provider.model
          };
        } else {
          throw new Error("Empty response from AI provider");
        }
      } catch (error) {
        lastError = error;
        logger.warn(`${provider.name} failed`, "AIService", {
          error: error instanceof Error ? error.message : String(error),
          model: provider.model
        });
        if (provider === this.providers[this.providers.length - 1]) {
          break;
        }
      }
    }
    const errorMessage = lastError ? MESSAGES.ERRORS.AI_PROCESSING(lastError.message) : "All AI providers failed to process the request";
    throw new Error(errorMessage);
  }
  /**
   * Process prompt with parallel provider racing for maximum speed
   */
  async processParallel(prompt) {
    console.log("Starting parallel provider racing...");
    const providerPromises = this.providers.map(async (provider) => {
      try {
        const content = await provider.processWithTimeout(prompt);
        if (content && content.trim().length > 0) {
          return {
            content,
            provider: provider.name,
            model: provider.model,
            success: true,
            responseTime: Date.now()
          };
        } else {
          throw new Error("Empty response from AI provider");
        }
      } catch (error) {
        console.warn(`${provider.name} failed in parallel race:`, error);
        return {
          error: error.message,
          provider: provider.name,
          model: provider.model,
          success: false,
          responseTime: Date.now()
        };
      }
    });
    const results = await Promise.allSettled(providerPromises);
    for (const result of results) {
      if (result.status === "fulfilled" && result.value.success) {
        console.log(`Parallel winner: ${result.value.provider} (${Date.now() - result.value.responseTime}ms)`);
        return {
          content: result.value.content,
          provider: result.value.provider,
          model: result.value.model
        };
      }
    }
    const errors = results.filter((r) => r.status === "fulfilled" && !r.value.success).map((r) => r.value.error);
    const errorMessage = errors.length > 0 ? MESSAGES.ERRORS.AI_PROCESSING(errors.join("; ")) : "All AI providers failed to process the request";
    throw new Error(errorMessage);
  }
  /**
   * Process prompt using a specific provider name. Optionally override the model if supported.
   */
  async processWith(providerName, prompt, overrideModel) {
    const provider = this.providers.find((p) => p.name === providerName);
    if (!provider) {
      throw new Error(`AI provider not found: ${providerName}`);
    }
    try {
      if (overrideModel && typeof provider.setModel === "function") {
        provider.setModel(overrideModel);
      }
      const content = await provider.process(prompt);
      if (content && content.trim().length > 0) {
        return { content, provider: provider.name, model: provider.model };
      }
      throw new Error("Empty response from AI provider");
    } catch (error) {
      throw new Error(MESSAGES.ERRORS.AI_PROCESSING(error.message));
    }
  }
  /**
   * Check if any providers are available
   */
  hasAvailableProviders() {
    return this.providers.length > 0;
  }
  /**
   * Get list of available provider names
   */
  getProviderNames() {
    return this.providers.map((p) => p.name);
  }
  /**
   * Add a new provider
   */
  addProvider(provider) {
    this.providers.push(provider);
  }
  /**
   * Remove a provider by name
   */
  removeProvider(providerName) {
    const index = this.providers.findIndex((p) => p.name === providerName);
    if (index !== -1) {
      this.providers.splice(index, 1);
      return true;
    }
    return false;
  }
};

// src/gemini.ts
init_api();

// src/base.ts
var BaseAIProvider = class {
  constructor(apiKey, initialModel, timeout) {
    this.apiKey = apiKey;
    this._timeout = 3e4;
    // Default 30s timeout
    this._maxTokens = 2048;
    // Default max tokens
    this._temperature = 0.7;
    if (!apiKey) {
      throw new Error("API key is required for AI provider");
    }
    this._model = initialModel || "";
    if (timeout) {
      this._timeout = timeout;
    }
  }
  // Default temperature
  get model() {
    return this._model;
  }
  get timeout() {
    return this._timeout;
  }
  get maxTokens() {
    return this._maxTokens;
  }
  get temperature() {
    return this._temperature;
  }
  setModel(model) {
    this._model = model;
  }
  setTimeout(timeout) {
    this._timeout = timeout;
  }
  setMaxTokens(maxTokens) {
    this._maxTokens = maxTokens;
  }
  setTemperature(temperature) {
    this._temperature = temperature;
  }
  /**
   * Process with timeout support
   */
  async processWithTimeout(prompt, customTimeout) {
    const timeoutMs = customTimeout || this._timeout;
    const timeoutPromise = new Promise((_, reject) => {
      setTimeout(() => {
        reject(new Error(`${this.name} request timed out after ${timeoutMs}ms`));
      }, timeoutMs);
    });
    const processPromise = this.process(prompt);
    return Promise.race([processPromise, timeoutPromise]);
  }
  /**
   * Validate API response structure
   */
  validateResponse(response, requiredPath) {
    let current = response;
    for (const key of requiredPath) {
      if (!current || typeof current !== "object" || !(key in current)) {
        return false;
      }
      current = current[key];
    }
    return current !== null && current !== void 0;
  }
  /**
   * Safely parse JSON response without throwing
   */
  async safeJsonParse(response) {
    try {
      return await response.json();
    } catch (e) {
      return null;
    }
  }
  /**
   * Handle API errors consistently
   */
  async handleAPIError(response) {
    return ErrorHandler.handleAPIError(response, this.name);
  }
};

// src/gemini.ts
var GeminiProvider = class extends BaseAIProvider {
  constructor(apiKey, model, timeout) {
    super(apiKey, model || AI_MODELS.GEMINI, timeout);
    this.name = "Google Gemini";
  }
  async process(prompt) {
    var _a, _b;
    try {
      if (!this.apiKey || this.apiKey.trim().length === 0) {
        throw new Error(MESSAGES.ERRORS.GEMINI_INVALID_KEY);
      }
      const response = await fetch(`${API_ENDPOINTS.GEMINI}?key=${this.apiKey}`, {
        method: "POST",
        headers: this.createHeaders(),
        body: JSON.stringify(this.createRequestBody(prompt))
      });
      if (response.status === 400) {
        const errorData = await this.safeJsonParse(response);
        const errorMessage = ((_a = errorData == null ? void 0 : errorData.error) == null ? void 0 : _a.message) || "Bad request";
        throw new Error(`Gemini API error: ${errorMessage}. Try checking the model configuration.`);
      }
      if (response.status === 401) {
        throw new Error(MESSAGES.ERRORS.GEMINI_INVALID_KEY);
      }
      if (response.status === 403) {
        throw new Error("Gemini API quota exceeded or billing required. Please check your plan and billing details.");
      }
      if (response.status === 429) {
        try {
          const errorData = await response.json();
          const errorMessage = ((_b = errorData.error) == null ? void 0 : _b.message) || errorData.message || "";
          if (errorMessage.toLowerCase().includes("quota")) {
            throw new Error(`Gemini API quota exceeded: ${errorMessage}. Please check your plan and billing details.`);
          } else if (errorMessage.toLowerCase().includes("rate")) {
            throw new Error(`Gemini API rate limit exceeded: ${errorMessage}. Please wait a moment and try again.`);
          } else {
            throw new Error(`Gemini API rate limit exceeded. Please wait and try again.`);
          }
        } catch (e) {
          throw new Error("Gemini API rate limit exceeded. Please wait and try again.");
        }
      }
      if (!response.ok) {
        await this.handleAPIError(response);
      }
      const data = await response.json();
      if (!data.candidates || !data.candidates.length) {
        throw new Error("No response candidates returned from Gemini API");
      }
      if (data.candidates[0].finishReason === "SAFETY") {
        throw new Error("Response blocked by Gemini safety filters. Try rephrasing.");
      }
      if (!this.validateResponse(data, ["candidates", "0", "content", "parts", "0", "text"])) {
        throw new Error("Invalid response format from Gemini API");
      }
      return this.extractContent(data);
    } catch (error) {
      if (error instanceof Error) {
        throw error;
      }
      throw new Error(`Gemini processing failed: ${error}`);
    }
  }
  createHeaders() {
    return {
      "Content-Type": "application/json"
    };
  }
  createRequestBody(prompt) {
    const normalizedPrompt = prompt.toLowerCase();
    const isVideoAnalysis = normalizedPrompt.includes("youtube video") || normalizedPrompt.includes("youtu.be/") || normalizedPrompt.includes("youtube.com/");
    const baseConfig = {
      contents: [{
        parts: [{ text: prompt }]
      }],
      generationConfig: {
        temperature: this._temperature,
        maxOutputTokens: this._maxTokens,
        candidateCount: 1
      }
      // safetySettings: [
      //     {
      //         category: "HARM_CATEGORY_HARASSMENT",
      //         threshold: "BLOCK_MEDIUM_AND_ABOVE"
      //     },
      //     {
      //         category: "HARM_CATEGORY_HATE_SPEECH", 
      //         threshold: "BLOCK_MEDIUM_AND_ABOVE"
      //     }
      // ]
    };
    if (isVideoAnalysis) {
      const providerModels = PROVIDER_MODEL_OPTIONS["Google Gemini"] || [];
      const currentModelName = String(this.model || "").toLowerCase();
      const matched = providerModels.find((m) => {
        const name = typeof m === "string" ? m : m && m.name ? m.name : "";
        return String(name).toLowerCase() === currentModelName;
      });
      const supportsAudioVideo = matched && matched.supportsAudioVideo === true;
      const videoConfig = {
        ...baseConfig,
        systemInstruction: {
          parts: [{
            text: `You are an expert video content analyzer. Provide comprehensive, multimodal analysis using:
\u2022 AUDIO STREAM: Transcribe all spoken content, identify speakers, capture tone/emphasis/emotion
\u2022 VIDEO STREAM: Analyze visual elements, text overlays, diagrams, slides, gestures, scene changes, and visual demonstrations
\u2022 INTEGRATED INSIGHTS: Synthesize audio and visual data to provide complete understanding

For best results:
- Prioritize accuracy in transcription and speaker identification
- Extract and explain key concepts shown visually
- Note timing relationships between audio and visual elements
- Identify visual cues that reinforce or clarify spoken content`
          }]
        }
      };
      const gcsMatch = prompt.match(/(gs:\/\/[\w\-\.\/]+\.(?:mp4|mov|mkv|webm))/i);
      if (gcsMatch && gcsMatch[1]) {
        const gcsUri = gcsMatch[1];
        videoConfig.contents = videoConfig.contents || [];
        videoConfig.contents.push({
          parts: [{ fileData: { fileUri: gcsUri, mimeType: "video/mp4" } }]
        });
      }
      return videoConfig;
    }
    return baseConfig;
  }
  extractContent(response) {
    const content = response.candidates[0].content.parts[0].text;
    return content ? content.trim() : "";
  }
};

// src/groq.ts
init_api();
var GroqProvider = class extends BaseAIProvider {
  constructor(apiKey, model, timeout) {
    super(apiKey, model || AI_MODELS.GROQ, timeout);
    this.name = "Groq";
  }
  async process(prompt) {
    var _a;
    const response = await fetch(API_ENDPOINTS.GROQ, {
      method: "POST",
      headers: this.createHeaders(),
      body: JSON.stringify(this.createRequestBody(prompt))
    });
    if (response.status === 401) {
      throw new Error("Groq API key is invalid or missing. Please check your key.");
    }
    if (response.status === 402) {
      throw new Error("Groq API requires a paid plan. Please check your billing settings.");
    }
    if (response.status === 404) {
      throw new Error(MESSAGES.ERRORS.GROQ_MODEL_NOT_FOUND);
    }
    if (response.status === 429) {
      try {
        const errorData = await response.json();
        const errorMessage = ((_a = errorData.error) == null ? void 0 : _a.message) || errorData.message || "";
        if (errorMessage.toLowerCase().includes("quota")) {
          throw new Error(`Groq API quota exceeded: ${errorMessage}. Please check your plan and billing details.`);
        } else if (errorMessage.toLowerCase().includes("rate")) {
          throw new Error(`Groq API rate limit exceeded: ${errorMessage}. Please wait a moment and try again.`);
        } else {
          throw new Error("Groq API rate limit exceeded. Please wait and try again.");
        }
      } catch (e) {
        throw new Error("Groq API rate limit exceeded. Please wait and try again.");
      }
    }
    if (!response.ok) {
      await this.handleAPIError(response);
    }
    const data = await response.json();
    if (!this.validateResponse(data, ["choices", "0", "message"])) {
      throw new Error("Invalid response format from Groq API");
    }
    return this.extractContent(data);
  }
  createHeaders() {
    return {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${this.apiKey}`
    };
  }
  createRequestBody(prompt) {
    return {
      model: this.model,
      messages: [
        {
          role: "system",
          content: "You are an expert content analyzer specializing in extracting practical value and creating actionable guides from video content. Focus on clarity, practicality, and immediate implementability. Even with limited information, provide maximum value through structured analysis and practical recommendations."
        },
        {
          role: "user",
          content: prompt
        }
      ],
      max_tokens: this._maxTokens,
      temperature: this._temperature
    };
  }
  extractContent(response) {
    const content = response.choices[0].message.content;
    return content ? content.trim() : "";
  }
};

// src/video-data.ts
init_api();

// src/services/transcript-service.ts
init_api();
var YouTubeTranscriptService = class {
  // 1 hour
  constructor(cache) {
    this.cache = cache;
    this.transcriptTTL = 1e3 * 60 * 60;
  }
  /**
   * Extract transcript for a YouTube video
   */
  async getTranscript(videoId) {
    var _a, _b;
    if (!videoId) {
      throw new Error("Video ID is required");
    }
    const cacheKey = `transcript-${videoId}`;
    const cached = (_a = this.cache) == null ? void 0 : _a.get(cacheKey);
    if (cached) {
      return cached;
    }
    try {
      const transcript = await this.fetchTranscriptWithFallback(videoId);
      if (transcript) {
        (_b = this.cache) == null ? void 0 : _b.set(cacheKey, transcript, this.transcriptTTL);
        return transcript;
      }
      return null;
    } catch (error) {
      console.warn("Failed to fetch transcript:", error);
      return null;
    }
  }
  /**
   * Fetch transcript using multiple methods with fallback
   */
  async fetchTranscriptWithFallback(videoId) {
    try {
      const transcript = await this.fetchFromYouTubeAPI(videoId);
      if (transcript)
        return transcript;
    } catch (error) {
      console.debug("YouTube API method failed:", error);
    }
    try {
      const transcript = await this.scrapeTranscriptFromPage(videoId);
      if (transcript)
        return transcript;
    } catch (error) {
      console.debug("Page scraping method failed:", error);
    }
    try {
      const transcript = await this.fetchFromThirdParty(videoId);
      if (transcript)
        return transcript;
    } catch (error) {
      console.debug("Third-party method failed:", error);
    }
    return null;
  }
  /**
   * Method 1: Official YouTube transcript API
   */
  async fetchFromYouTubeAPI(videoId) {
    const url = `https://video.google.com/timedtext?lang=en&v=${videoId}`;
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`Transcript API failed: ${response.status}`);
    }
    const xmlText = await response.text();
    return this.parseXMLTranscript(xmlText, videoId);
  }
  /**
   * Method 2: Scrape transcript from YouTube page
   */
  async scrapeTranscriptFromPage(videoId) {
    const videoUrl = `https://www.youtube.com/watch?v=${videoId}`;
    const proxyUrl = `${API_ENDPOINTS.CORS_PROXY}?url=${encodeURIComponent(videoUrl)}`;
    const response = await fetch(proxyUrl);
    if (!response.ok) {
      throw new Error("Failed to fetch video page");
    }
    const html = await response.text();
    const transcriptData = await this.extractTranscriptFromHTML(html);
    if (transcriptData) {
      return this.createTranscript(transcriptData, videoId, true);
    }
    return null;
  }
  /**
   * Method 3: Third-party transcript service (optional)
   */
  async fetchFromThirdParty(videoId) {
    return null;
  }
  /**
   * Parse XML transcript from YouTube API
   */
  parseXMLTranscript(xmlText, videoId) {
    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(xmlText, "text/xml");
    const textElements = xmlDoc.getElementsByTagName("text");
    const segments = [];
    let fullText = "";
    for (let i = 0; i < textElements.length; i++) {
      const element = textElements[i];
      const text = element.textContent || "";
      const start = parseFloat(element.getAttribute("start") || "0");
      const duration = parseFloat(element.getAttribute("dur") || "0");
      if (text.trim()) {
        segments.push({ text: text.trim(), start, duration });
        fullText += text.trim() + " ";
      }
    }
    return {
      segments,
      fullText: fullText.trim(),
      language: "en",
      autoGenerated: true
    };
  }
  /**
   * Extract transcript data from YouTube page HTML
   */
  async extractTranscriptFromHTML(html) {
    const transcriptRegex = /"captions":\s*{[^}]*"playerCaptionsTracklistRenderer":\s*{[^}]*"captionTracks":\s*\[([^\]]+)\]/;
    const match = html.match(transcriptRegex);
    if (!match || !match[1]) {
      return null;
    }
    try {
      const captionTracksJson = match[1];
      const captionTracks = JSON.parse(`[${captionTracksJson}]`);
      const englishTrack = captionTracks.find(
        (track) => {
          var _a;
          return track.languageCode === "en" || ((_a = track.languageCode) == null ? void 0 : _a.startsWith("en"));
        }
      );
      if (!englishTrack || !englishTrack.baseUrl) {
        return null;
      }
      return fetch(englishTrack.baseUrl).then((resp) => {
        if (!resp.ok)
          throw new Error("Failed to fetch caption track");
        return resp.text();
      }).then((xmlText) => this.parseXMLTranscript(xmlText, "").segments).catch((err) => {
        console.debug("Failed to fetch caption track:", err);
        return null;
      });
    } catch (error) {
      console.debug("Failed to parse transcript from HTML:", error);
      return null;
    }
  }
  /**
   * Create transcript object from segments
   */
  createTranscript(segments, videoId, autoGenerated = false) {
    if (!Array.isArray(segments)) {
      segments = [segments];
    }
    const normalizedSegments = segments.map((seg) => ({
      text: seg.text,
      start: seg.start,
      duration: seg.duration || 0
    }));
    const fullText = normalizedSegments.map((seg) => seg.text).join(" ").trim();
    return {
      segments: normalizedSegments,
      fullText,
      language: "en",
      autoGenerated
    };
  }
  /**
   * Get transcript summary for quick analysis
   */
  async getTranscriptSummary(videoId, maxLength = 2e3) {
    const transcript = await this.getTranscript(videoId);
    if (!transcript) {
      return null;
    }
    if (transcript.fullText.length <= maxLength) {
      return transcript.fullText;
    }
    const keySegments = transcript.segments.filter((seg) => seg.text.length > 20).slice(0, 10).map((seg) => seg.text).join(" ");
    return keySegments.length > maxLength ? keySegments.substring(0, maxLength) + "..." : keySegments;
  }
  /**
   * Extract key time-stamped moments from transcript
   */
  async extractKeyMoments(videoId, count = 5) {
    const transcript = await this.getTranscript(videoId);
    if (!transcript || transcript.segments.length === 0) {
      return null;
    }
    const meaningfulSegments = transcript.segments.filter((seg) => seg.text.length > 30);
    if (meaningfulSegments.length === 0) {
      return null;
    }
    const totalSegments = meaningfulSegments.length;
    const step = Math.max(1, Math.floor(totalSegments / count));
    const keyMoments = [];
    for (let i = 0; i < totalSegments && keyMoments.length < count; i += step) {
      const segment = meaningfulSegments[i];
      keyMoments.push({
        time: segment.start,
        text: segment.text
      });
    }
    return keyMoments;
  }
  /**
   * Check if transcript is available for a video
   */
  async isTranscriptAvailable(videoId) {
    const transcript = await this.getTranscript(videoId);
    return transcript !== null && transcript.segments.length > 0;
  }
};

// src/video-data.ts
var YouTubeVideoService = class {
  constructor(cache) {
    this.cache = cache;
    this.metadataTTL = 1e3 * 60 * 30;
    // 30 minutes
    this.descriptionTTL = 1e3 * 60 * 30;
    this.transcriptService = new YouTubeTranscriptService(cache);
  }
  /**
   * Extract video ID from YouTube URL
   */
  extractVideoId(url) {
    return ValidationUtils.extractVideoId(url);
  }
  /**
   * Get video metadata and description
   */
  async getVideoData(videoId) {
    var _a, _b;
    if (!videoId) {
      throw new Error("Video ID is required");
    }
    const cacheKey = this.getCacheKey("video-data", videoId);
    const cached = (_a = this.cache) == null ? void 0 : _a.get(cacheKey);
    if (cached) {
      return cached;
    }
    try {
      const metadata = await this.getVideoMetadata(videoId);
      const result = {
        title: metadata.title || "Unknown Title",
        description: metadata.description || "No description available",
        duration: metadata.duration,
        thumbnail: metadata.thumbnail,
        channelName: metadata.channelName
      };
      if (result.duration && result.duration < 1800) {
        this.checkTranscriptAvailability(videoId).then((hasTranscript) => {
          var _a2;
          result.hasTranscript = hasTranscript;
          (_a2 = this.cache) == null ? void 0 : _a2.set(cacheKey, result, this.metadataTTL);
        });
      }
      (_b = this.cache) == null ? void 0 : _b.set(cacheKey, result, this.metadataTTL);
      return result;
    } catch (error) {
      throw ErrorHandler.createUserFriendlyError(
        error,
        "fetch video data"
      );
    }
  }
  /**
   * Get video metadata using YouTube oEmbed API
   */
  async getVideoMetadata(videoId) {
    var _a, _b;
    const cacheKey = this.getCacheKey("metadata", videoId);
    const cached = (_a = this.cache) == null ? void 0 : _a.get(cacheKey);
    if (cached) {
      return cached;
    }
    const oembedUrl = `${API_ENDPOINTS.YOUTUBE_OEMBED}?url=https://www.youtube.com/watch?v=${videoId}&format=json`;
    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 1e4);
      const response = await fetch(oembedUrl, {
        headers: {
          "User-Agent": "Obsidian YoutubeClipper Plugin"
        },
        signal: controller.signal
      });
      clearTimeout(timeoutId);
      if (!response.ok) {
        if (response.status === 400) {
          throw new Error(`Invalid YouTube video ID: ${videoId}. Please check the URL and try again.`);
        } else if (response.status === 404) {
          throw new Error(`YouTube video not found: ${videoId}. The video may be private, deleted, or the ID is incorrect.`);
        } else if (response.status === 403) {
          throw new Error(`Access denied to YouTube video: ${videoId}. The video may be private or restricted.`);
        } else {
          throw new Error(MESSAGES.ERRORS.FETCH_VIDEO_DATA(response.status));
        }
      }
      const data = await response.json();
      let enhancedData = {
        title: data.title || "Unknown Title",
        thumbnail: data.thumbnail_url,
        author_name: data.author_name
      };
      try {
        const pageData = await this.scrapeAdditionalMetadata(videoId);
        enhancedData = { ...enhancedData, ...pageData };
      } catch (error) {
        console.debug("Could not scrape additional metadata:", error);
      }
      const metadata = {
        title: enhancedData.title,
        description: enhancedData.description,
        duration: enhancedData.duration,
        thumbnail: enhancedData.thumbnail,
        channelName: enhancedData.author_name
      };
      (_b = this.cache) == null ? void 0 : _b.set(cacheKey, metadata, this.metadataTTL);
      return metadata;
    } catch (error) {
      if (error instanceof DOMException && error.name === "AbortError") {
        throw new Error("Request timed out. Please check your internet connection and try again.");
      } else if (error instanceof TypeError) {
        throw new Error(MESSAGES.ERRORS.NETWORK_ERROR);
      } else if (error instanceof Error && error.message.includes("JSON")) {
        throw new Error("Failed to parse YouTube response. The service may be temporarily unavailable.");
      }
      throw error;
    }
  }
  /**
   * Scrape additional metadata from YouTube page
   */
  async scrapeAdditionalMetadata(videoId) {
    try {
      const html = await this.fetchVideoPageHTML(videoId);
      const durationMatch = html.match(/"lengthSeconds":"(\d+)"/);
      const duration = durationMatch ? parseInt(durationMatch[1]) : void 0;
      const descriptionMatch = html.match(/"shortDescription":"([^"]+)"/);
      const description = descriptionMatch ? descriptionMatch[1].replace(/\\u0026/g, "&").replace(/\\n/g, "\n") : void 0;
      return { description, duration };
    } catch (error) {
      return {};
    }
  }
  /**
   * Check if transcript is available for this video
   */
  async checkTranscriptAvailability(videoId) {
    try {
      return await this.transcriptService.isTranscriptAvailable(videoId);
    } catch (error) {
      return false;
    }
  }
  /**
   * Get video description by scraping the YouTube page
   */
  async getVideoDescription(videoId) {
    var _a, _b, _c;
    const cacheKey = this.getCacheKey("description", videoId);
    const cached = (_a = this.cache) == null ? void 0 : _a.get(cacheKey);
    if (cached) {
      return cached;
    }
    try {
      const html = await this.fetchVideoPageHTML(videoId);
      const description = this.extractDescriptionFromHTML(html);
      (_b = this.cache) == null ? void 0 : _b.set(cacheKey, description, this.descriptionTTL);
      return description;
    } catch (error) {
      console.warn("Failed to scrape video page:", error);
      const fallback = MESSAGES.WARNINGS.EXTRACTION_FAILED;
      (_c = this.cache) == null ? void 0 : _c.set(cacheKey, fallback, this.descriptionTTL);
      return fallback;
    }
  }
  /**
   * Fetch YouTube page HTML using CORS proxy
   */
  async fetchVideoPageHTML(videoId) {
    const videoUrl = `https://www.youtube.com/watch?v=${videoId}`;
    const proxyUrl = `${API_ENDPOINTS.CORS_PROXY}?url=${encodeURIComponent(videoUrl)}`;
    const response = await fetch(proxyUrl);
    if (!response.ok) {
      throw new Error(MESSAGES.WARNINGS.CORS_RESTRICTIONS);
    }
    return response.text();
  }
  /**
   * Extract description from YouTube page HTML
   */
  extractDescriptionFromHTML(html) {
    const patterns = [
      /"shortDescription":"([^"]*?)"/,
      /"description":{"simpleText":"([^"]*?)"}/,
      /<meta name="description" content="([^"]*?)">/,
      /<meta property="og:description" content="([^"]*?)">/
    ];
    for (const pattern of patterns) {
      const match = html.match(pattern);
      if (match && match[1]) {
        const cleanedText = ValidationUtils.cleanText(match[1]);
        return ValidationUtils.truncateText(cleanedText, API_LIMITS.DESCRIPTION_MAX_LENGTH);
      }
    }
    return MESSAGES.WARNINGS.AUTO_EXTRACTION;
  }
  /**
   * Validate YouTube URL and extract video ID
   */
  validateAndExtractVideoId(url) {
    if (!ValidationUtils.isValidYouTubeUrl(url)) {
      throw new Error(MESSAGES.ERRORS.INVALID_URL);
    }
    const videoId = this.extractVideoId(url);
    if (!videoId) {
      throw new Error(MESSAGES.ERRORS.INVALID_URL);
    }
    return videoId;
  }
  getCacheKey(namespace, videoId) {
    return `youtube-video-service:${namespace}:${videoId}`;
  }
};

// src/obsidian-file.ts
var import_obsidian7 = require("obsidian");
init_api();

// src/file-conflict-modal.ts
init_base_modal();
var COPY_WARNING = "A note with this title already exists. Choose how to proceed.";
var FileConflictModal = class extends BaseModal {
  constructor(app, file) {
    super(app);
    this.file = file;
    this.decision = "cancel";
  }
  onOpen() {
    this.createHeader("Note Already Exists");
    this.createMessage(`${COPY_WARNING}

Existing note: ${this.file.path}`);
    this.createButtons();
  }
  openAndWait() {
    return new Promise((resolve) => {
      this.resolve = resolve;
      this.forceVisible();
      this.open();
    });
  }
  onClose() {
    if (this.resolve) {
      this.resolve(this.decision);
    }
    super.onClose();
  }
  createButtons() {
    const container = this.createButtonContainer();
    this.createButton(container, "Cancel", false, () => {
      this.closeWithDecision("cancel");
    });
    this.createButton(container, "Save as Numbered Copy", false, () => {
      this.closeWithDecision("new-name");
    });
    this.createButton(container, "Overwrite Existing", true, () => {
      this.closeWithDecision("overwrite");
    });
  }
  closeWithDecision(decision) {
    this.decision = decision;
    this.close();
  }
};

// src/obsidian-file.ts
var ObsidianFileService = class {
  constructor(app) {
    this.app = app;
  }
  /**
   * Save content to a file in the vault
   */
  async saveToFile(title, content, outputPath) {
    try {
      const filename = this.createSafeFilename(title);
      const normalizedBase = this.normalizePath(outputPath);
      await this.ensureDirectoryExists(normalizedBase);
      const dailyFolder = this.getDailyFolderPath(normalizedBase);
      await this.ensureDirectoryExists(dailyFolder);
      const filePath = `${dailyFolder}/${filename}`;
      const finalPath = await this.handleFileConflicts(filePath, content);
      return finalPath;
    } catch (error) {
      throw new Error(MESSAGES.ERRORS.SAVE_FILE(error.message));
    }
  }
  /**
   * Open a file with user confirmation
   */
  async openFileWithConfirmation(file) {
    await this.waitForFileCreation();
    try {
      const currentFile = this.app.vault.getAbstractFileByPath(file.path);
      if (!(currentFile instanceof import_obsidian7.TFile)) {
        throw new Error(MESSAGES.ERRORS.FILE_NOT_EXISTS);
      }
      const leaf = this.app.workspace.getLeaf(false);
      await leaf.openFile(currentFile);
    } catch (error) {
      throw new Error(MESSAGES.ERRORS.COULD_NOT_OPEN(error.message));
    }
  }
  /**
   * Create a safe filename from title
   */
  createSafeFilename(title) {
    const sanitized = ValidationUtils.sanitizeFilename(title);
    return `${sanitized}.md`;
  }
  /**
   * Ensure the output directory exists
   */
  async ensureDirectoryExists(outputPath) {
    try {
      await this.app.vault.createFolder(outputPath);
    } catch (error) {
    }
  }
  getDailyFolderPath(basePath) {
    const trimmedBase = basePath.replace(/\/+$/, "");
    const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
    return `${trimmedBase}/${today}`;
  }
  /**
   * Handle file naming conflicts by adding timestamp
   */
  async handleFileConflicts(filePath, content) {
    const existingFile = this.app.vault.getAbstractFileByPath(filePath);
    if (existingFile instanceof import_obsidian7.TFile) {
      const decision = await this.promptConflictResolution(existingFile);
      switch (decision) {
        case "overwrite":
          await this.app.vault.modify(existingFile, content);
          return existingFile.path;
        case "new-name":
          return this.createVersionedCopy(existingFile.path, content);
        default:
          throw new Error("Save cancelled by user");
      }
    }
    await this.app.vault.create(filePath, content);
    return filePath;
  }
  /**
   * Wait for file creation to complete
   */
  async waitForFileCreation() {
    return new Promise(
      (resolve) => setTimeout(resolve, TIMEOUTS.FILE_CREATION_WAIT)
    );
  }
  /**
   * Get file by path with validation
   */
  getFileByPath(filePath) {
    const file = this.app.vault.getAbstractFileByPath(filePath);
    return file instanceof import_obsidian7.TFile ? file : null;
  }
  /**
   * Check if file exists at path
   */
  fileExists(filePath) {
    return this.getFileByPath(filePath) !== null;
  }
  /**
   * Create a file with unique naming
   */
  async createUniqueFile(basePath, content) {
    let counter = 1;
    let filePath = basePath;
    while (this.fileExists(filePath)) {
      const pathParts = basePath.split("/");
      const filename = pathParts.pop();
      const nameWithoutExt = filename.replace(".md", "");
      const newFilename = `${nameWithoutExt} (${counter}).md`;
      filePath = [...pathParts, newFilename].join("/");
      counter++;
    }
    await this.app.vault.create(filePath, content);
    return filePath;
  }
  async promptConflictResolution(file) {
    const modal = new FileConflictModal(this.app, file);
    const decision = await modal.openAndWait();
    return decision;
  }
  async createVersionedCopy(originalPath, content) {
    const pathParts = originalPath.split("/");
    const filename = pathParts.pop();
    const nameWithoutExt = filename.replace(".md", "");
    let counter = 1;
    let candidatePath;
    do {
      candidatePath = [...pathParts, `${nameWithoutExt} (${counter}).md`].join("/");
      counter++;
    } while (this.fileExists(candidatePath));
    await this.app.vault.create(candidatePath, content);
    return candidatePath;
  }
  normalizePath(path) {
    if (!path) {
      return "";
    }
    let normalized = path.trim();
    if (normalized.startsWith("./")) {
      normalized = normalized.slice(2);
    }
    while (normalized.startsWith("/")) {
      normalized = normalized.slice(1);
    }
    normalized = normalized.replace(/\/+/g, "/");
    return normalized;
  }
};

// src/services/prompt-service.ts
var _AIPromptService = class _AIPromptService {
  /**
   * Create analysis prompt for YouTube video content with performance optimization
   */
  createAnalysisPrompt(videoData, videoUrl, format = "detailed-guide", customPrompt, performanceMode = "balanced") {
    if (customPrompt && customPrompt.trim()) {
      return this.applyCustomPrompt(customPrompt, videoData, videoUrl);
    }
    let baseTemplate;
    switch (performanceMode) {
      case "fast":
        baseTemplate = _AIPromptService.COMPACT_BASE_TEMPLATE;
        break;
      case "quality":
        baseTemplate = _AIPromptService.COMPREHENSIVE_BASE_TEMPLATE;
        break;
      default:
        baseTemplate = _AIPromptService.BALANCED_BASE_TEMPLATE;
    }
    const baseContent = baseTemplate.replace("{{TITLE}}", videoData.title).replace("{{URL}}", videoUrl).replace("{{DESCRIPTION}}", videoData.description);
    switch (format) {
      case "executive-summary":
        return this.createExecutiveSummaryPrompt(baseContent, videoUrl, performanceMode);
      case "brief":
        return this.createBriefPrompt(baseContent, videoUrl, performanceMode);
      case "detailed-guide":
      default:
        return this.createDetailedGuidePrompt(baseContent, videoUrl, performanceMode);
    }
  }
  /**
   * Apply custom prompt template with placeholder substitution
   */
  applyCustomPrompt(customPrompt, videoData, videoUrl) {
    const videoId = ValidationUtils.extractVideoId(videoUrl);
    const embedUrl = videoId ? `https://www.youtube-nocookie.com/embed/${videoId}` : videoUrl;
    return customPrompt.replace(/__VIDEO_TITLE__/g, videoData.title || "Unknown Video").replace(/__VIDEO_DESCRIPTION__/g, videoData.description || "No description available").replace(/__VIDEO_URL__/g, videoUrl).replace(/__VIDEO_ID__/g, videoId || "unknown").replace(/__EMBED_URL__/g, embedUrl).replace(/__DATE__/g, (/* @__PURE__ */ new Date()).toISOString().split("T")[0]).replace(/__TIMESTAMP__/g, (/* @__PURE__ */ new Date()).toISOString());
  }
  /**
   * Create a brief prompt: short description plus resources list
   */
  createBriefPrompt(baseContent, videoUrl, performanceMode = "balanced") {
    const videoId = ValidationUtils.extractVideoId(videoUrl);
    const embedUrl = videoId ? `https://www.youtube-nocookie.com/embed/${videoId}` : videoUrl;
    return `${baseContent}

        OUTPUT FORMAT - BRIEF DESCRIPTION + RESOURCES:

        Use this EXACT template:

        ---
        title: {Video Title}
        source: ${videoUrl}
        created: "${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}"
        modified: "${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}"
        description: "One short paragraph (3-4 sentences) summarizing the video"
        type: youtube-note
        format: brief
        tags:
          - youtube
          - brief
        status: processed
        duration: "[Extract video duration]"
        channel: "[Extract channel name]"
        video_id: "${videoId || "unknown"}"
        processing_date: "${(/* @__PURE__ */ new Date()).toISOString()}"
    ai_provider: "__AI_PROVIDER__"
    ai_model: "__AI_MODEL__"
        ---

        <iframe width="640" height="360" src="${embedUrl}" title="{Video Title}" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

        ---

        ## Brief Description
        [Provide a concise 3-4 sentence description that captures the core message of the video]

        ## Key Takeaways
        - **[Takeaway 1]**: [Core insight or lesson from the video]
        - **[Takeaway 2]**: [Core insight or lesson from the video]
        - **[Takeaway 3]**: [Core insight or lesson from the video]

        ## Quick Actions
        1. **[Immediate Action]**: [Specific action you can take right away]
        2. **[Next Step]**: [Follow-up action to apply what you learned]

        ## Resources
        - **Original Video:** [Watch on YouTube](${videoUrl})
        - **Channel:** [Creator's Channel](https://youtube.com/channel/[extract-channel-id])
        - **Top resources mentioned or related (links):**
          - [Resource 1]
          - [Resource 2]
          - [Resource 3]

        IMPORTANT: Keep the Brief Description short and focused. Provide 2-3 high-quality resource links that help the reader explore the topic further. Action items should be simple and immediately applicable.`;
  }
  /**
   * Create executive summary prompt (250 words, tech/developer focused)
   */
  createExecutiveSummaryPrompt(baseContent, videoUrl, performanceMode = "balanced") {
    const videoId = ValidationUtils.extractVideoId(videoUrl);
    const embedUrl = videoId ? `https://www.youtube-nocookie.com/embed/${videoId}` : videoUrl;
    const modeMap = {
      "fast": "Fast Mode: transcript only",
      "balanced": "Balanced Mode: transcript + primary visuals",
      "quality": "Quality Mode: full multimodal analysis (audio, visuals, diagrams, slides, demonstrations)"
    };
    const processingMode = modeMap[performanceMode] || modeMap["balanced"];
    return `## \u{1F3AF} YouTube \u2192 Obsidian Executive Summary Prompt (Tech/Developer Focus)

**ROLE:**
You are an expert technical analyst and executive summarizer. Your task is to extract high-value strategic insights from a technology-focused YouTube video and produce a concise, structured note for Obsidian.

---

Use this EXACT template:

---
title: {{TITLE}}
source: ${videoUrl}
created: "${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}"
modified: "${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}"
description: "Single sentence capturing the core insight"
type: youtube-note
format: executive-summary
tags:
  - youtube
  - executive-summary
  - technology
  - strategy
status: processed
duration: "[Extract video duration]"
channel: "[Extract channel name]"
video_id: "${videoId || "unknown"}"
processing_date: "${(/* @__PURE__ */ new Date()).toISOString()}"
word_count: 250
ai_provider: "__AI_PROVIDER__"
ai_model: "__AI_MODEL__"
---

<div style="text-align: center; margin-bottom: 24px;">
<iframe width="640" height="360" src="${embedUrl}" title="{{TITLE}}" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</div>

---

# \u{1F4CA} Executive Summary

The video discusses [explain the main problem/opportunity and the central argument of the video].

Key concepts include [summarize the most important concepts, frameworks, or differentiators that create impact].

To implement these insights, [provide recommendations, risks, and priority actions based on the insights].

> **\u{1F4A1} Focus:** Strategic value over narrative recap - prioritize actionable insights.

---

## \u{1F3AF} Key Strategic Insights

### \u{1F527} Technical Strategy
**[Critical insight with specific business impact and example from video]**

### \u{1F4A1} Design Thinking
**[Critical insight with specific business impact and example from video]**

### \u{1F4DA} Continuous Learning
**[Critical insight with specific business impact and example from video]**

> *Optional: Add 4\u20135 additional insights if they provide significant value.*

---

## \u{1F680} Action Plan & Implementation

### \u26A1 Immediate (0-30 days)
- **Action:** [Specific, measurable action]
- **Success Metric:** [Clear success criteria]

### \u{1F4C8} Short-term (1-3 months)
- **Action:** [Specific, measurable action]
- **Success Metric:** [Clear success criteria]

### \u{1F3AF} Mid-term (3-6 months)
- **Action:** [Specific, measurable action]
- **Success Metric:** [Clear success criteria]

### \u{1F52E} Long-term (6+ months)
- **Action:** [Specific, measurable action]
- **Success Metric:** [Clear success criteria]

> **\u2705 Requirement:** Each action item must include clear, measurable success criteria.

---

## \u{1F4DA} Curated Resources & References

### \u{1F3A5} Primary Sources
- **Original Video:** [Watch on YouTube](${videoUrl})
- **Channel:** [Creator's Channel](https://youtube.com/channel/[extract-channel-id])

### \u{1F6E0}\uFE0F Key Tools & Technologies
- [List main tools, frameworks, or technologies mentioned]

### \u{1F4D6} Official Documentation
- [Links to official documentation for mentioned technologies]

### \u{1F31F} Further Reading
- [1-2 high-quality related articles or resources for deep dive]

---

### Non-Negotiable Rules

- Executive Summary \u2264 250 words
- Insights & action items must reference the video
- Focus on strategy and developer/business value
- Avoid fluff and storytelling\u2014prioritize usable analysis

---

### Suggested Prompt Invocation

Analyze this YouTube video in **${processingMode}**:
Title: {{TITLE}}
URL: ${videoUrl}
Description: {{DESCRIPTION}}
Return a structured Obsidian-ready note with strategic insights and developer-aligned action steps.`;
  }
  /**
   * Create detailed guide prompt
   */
  createDetailedGuidePrompt(baseContent, videoUrl, performanceMode = "balanced") {
    const videoId = ValidationUtils.extractVideoId(videoUrl);
    const embedUrl = videoId ? `https://www.youtube-nocookie.com/embed/${videoId}` : videoUrl;
    return `${baseContent}

        OUTPUT FORMAT - EFFICIENT STEP-BY-STEP TUTORIAL:

        Create a concise step-by-step tutorial following this structure:

        ---
        title: {{TITLE}}
        source: ${videoUrl}
        created: "${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}"
        type: youtube-tutorial
        format: step-by-step
        tags: [youtube, tutorial, implementation, practical]
        status: processed
        channel: "[Extract channel name]"
        video_id: "${videoId || "unknown"}"
        ai_provider: "__AI_PROVIDER__"
        ai_model: "__AI_MODEL__"
        ---

        <div style="text-align: center; margin-bottom: 24px;">
        <iframe width="640" height="360" src="${embedUrl}" title="{{TITLE}}" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
        </div>

        ---

        # [Title] - Practical Tutorial

        ## Overview
        **Goal:** [Main learning objective]
        **Duration:** [Estimated time]
        **Level:** [Difficulty]

        **Video:** [{{TITLE}}](${videoUrl})

        ## Prerequisites
        - [Requirement 1]
        - [Requirement 2]
        - [Requirement 3]

        ## Step-by-Step Guide

        ### Step 1: [Action/Setup]
        **Objective:** [Clear goal]

        **Actions:**
        1. [Specific instruction]
        2. [Follow-up instruction]
        3. [Verification step]

        \u2705 **Success:** [How to confirm it worked]

        ### Step 2: [Core Implementation]
        **Objective:** [Clear goal]

        [Continue with remaining steps...]

        ### Step 3: [Final Touches]
        **Objective:** [Clear goal]

        ## Learning Outcomes
        Upon completion, you will:
- [Achieved skill 1]
- [Achieved skill 2]
- [Achieved skill 3]

        ## Required Tools
        - **[Tool/Resource 1]:** [Where to get it]
        - **[Tool/Resource 2]:** [Where to get it]

        ## Pro Tips
        \u{1F4A1} **Tip 1:** [Key insight from video]
        \u{1F4A1} **Tip 2:** [Best practice]
        \u26A0\uFE0F **Avoid:** [Common mistake]

        ## Verification
        **Final Check:** [How to verify complete success]
        **Expected Result:** [What you should see/accomplish]

              *Generated from YouTube video content*`;
  }
  /**
   * Process AI response and inject provider information
   */
  processAIResponse(content, provider, model, format) {
    if (!content) {
      return content;
    }
    const providerValue = provider || "unknown";
    const modelValue = model || "unknown";
    let updatedContent = content.replace(/__AI_PROVIDER__/g, providerValue).replace(/__AI_MODEL__/g, modelValue);
    updatedContent = this.ensureFrontMatterValue(updatedContent, "ai_provider", providerValue);
    updatedContent = this.ensureFrontMatterValue(updatedContent, "ai_model", modelValue);
    return updatedContent;
  }
  ensureFrontMatterValue(content, key, value) {
    const pattern = new RegExp(`(${key}\\s*:\\s*)(["'])?([^"'\\n]*)(["'])?`, "i");
    if (pattern.test(content)) {
      return content.replace(pattern, (_, prefix, openingQuote, _existing, closingQuote) => {
        const quote = openingQuote || closingQuote ? '"' : "";
        return `${prefix}${quote}${value}${quote}`;
      });
    }
    if (content.startsWith("---")) {
      return content.replace(/^---\s*\n/, `---
${key}: "${value}"
`);
    }
    return content;
  }
  /**
   * Create a summary prompt for shorter content
   */
  createSummaryPrompt(videoData, videoUrl) {
    return `Create a concise summary for this YouTube video:

        Title: ${videoData.title}
        URL: ${videoUrl}
        Description: ${videoData.description}

        Please provide:
        1. A 2-paragraph summary (max 250 words)
        2. 3-5 key takeaways
        3. Main actionable insights

        Format as markdown with clear headings.`;
  }
  /**
   * Validate prompt length and content
   */
  validatePrompt(prompt) {
    return Boolean(prompt) && typeof prompt === "string" && prompt.trim().length > 10 && prompt.length < 5e4;
  }
};
// Optimized prompt templates for different performance modes
_AIPromptService.COMPACT_BASE_TEMPLATE = `Analyze this YouTube video:
Title: {{TITLE}}
URL: {{URL}}
Description: {{DESCRIPTION}}

Focus on extracting the key information and insights.`;
_AIPromptService.BALANCED_BASE_TEMPLATE = `Analyze this YouTube video with multimodal analysis:
Title: {{TITLE}}
URL: {{URL}}
Description: {{DESCRIPTION}}

Extract insights from both spoken content and visual elements, focusing on practical information.`;
_AIPromptService.COMPREHENSIVE_BASE_TEMPLATE = `Analyze this YouTube video using comprehensive multimodal analysis:
Title: {{TITLE}}
URL: {{URL}}
Description: {{DESCRIPTION}}

MULTIMODAL ANALYSIS INSTRUCTIONS:
1. Watch the complete video using both audio and visual analysis capabilities
2. Extract insights from spoken content, music, sound effects, and ambient audio
3. Analyze visual elements including slides, diagrams, charts, body language, and demonstrations
4. Focus on practical, action-oriented information with specific examples
5. Maintain accuracy and cite specific examples from the video when relevant`;
var AIPromptService = _AIPromptService;

// src/services/cache/memory-cache.ts
var MemoryCacheService = class {
  constructor() {
    this.cache = /* @__PURE__ */ new Map();
    this.defaultTTL = 3e5;
    // 5 minutes
    this.lastCleanup = 0;
    this.CLEANUP_INTERVAL = 6e4;
  }
  // 1 minute
  /**
   * Get item from cache (optimized with lazy cleanup)
   */
  get(key) {
    var _a;
    if (this.cache.size > 50) {
      this.cleanup();
    }
    const item = this.cache.get(key);
    if (!item)
      return null;
    const ttl = (_a = item.ttl) != null ? _a : this.defaultTTL;
    if (Date.now() - item.timestamp > ttl) {
      this.cache.delete(key);
      return null;
    }
    return item.data;
  }
  /**
   * Set item in cache
   */
  set(key, data, ttl) {
    this.cache.set(key, {
      data,
      timestamp: Date.now(),
      ttl
    });
  }
  /**
   * Clear all cache items
   */
  clear() {
    this.cache.clear();
  }
  /**
   * Delete specific cache item
   */
  delete(key) {
    return this.cache.delete(key);
  }
  /**
   * Check if key exists in cache
   */
  has(key) {
    var _a;
    const item = this.cache.get(key);
    if (!item) {
      return false;
    }
    const ttl = (_a = item.ttl) != null ? _a : this.defaultTTL;
    if (Date.now() - item.timestamp > ttl) {
      this.cache.delete(key);
      return false;
    }
    return true;
  }
  /**
   * Get cache size
   */
  size() {
    return this.cache.size;
  }
  /**
   * Clean up expired items (optimized with batched operations)
   */
  cleanup() {
    var _a;
    const now = Date.now();
    if (now - this.lastCleanup < this.CLEANUP_INTERVAL)
      return;
    this.lastCleanup = now;
    const expiredKeys = [];
    for (const [key, item] of this.cache.entries()) {
      const ttl = (_a = item.ttl) != null ? _a : this.defaultTTL;
      if (now - item.timestamp > ttl) {
        expiredKeys.push(key);
      }
    }
    expiredKeys.forEach((key) => this.cache.delete(key));
  }
};

// src/services/service-container.ts
var ServiceContainer = class {
  constructor(settings, app) {
    this.settings = settings;
    this.app = app;
  }
  get aiService() {
    if (!this._aiService) {
      const providers = [];
      if (this.settings.geminiApiKey) {
        providers.push(new GeminiProvider(this.settings.geminiApiKey));
      }
      if (this.settings.groqApiKey) {
        providers.push(new GroqProvider(this.settings.groqApiKey));
      }
      this._aiService = new AIService(providers, this.settings);
    }
    return this._aiService;
  }
  get videoService() {
    if (!this._videoService) {
      this._videoService = new YouTubeVideoService(this.cacheService);
    }
    return this._videoService;
  }
  get fileService() {
    if (!this._fileService) {
      this._fileService = new ObsidianFileService(this.app);
    }
    return this._fileService;
  }
  get cacheService() {
    if (!this._cacheService) {
      this._cacheService = new MemoryCacheService();
    }
    return this._cacheService;
  }
  get promptService() {
    if (!this._promptService) {
      this._promptService = new AIPromptService();
    }
    return this._promptService;
  }
  /**
   * Update settings and refresh services that depend on them
   */
  async updateSettings(newSettings) {
    this.settings = newSettings;
    this._aiService = void 0;
  }
  /**
   * Clear all cached services
   */
  clearServices() {
    this._aiService = void 0;
    this._videoService = void 0;
    this._fileService = void 0;
    this._cacheService = void 0;
    this._promptService = void 0;
  }
};

// src/main.ts
var PLUGIN_PREFIX = "ytp";
var PLUGIN_VERSION = "1.3.5";
var DEFAULT_SETTINGS = {
  geminiApiKey: "",
  groqApiKey: "",
  outputPath: "YouTube/Processed Videos",
  useEnvironmentVariables: false,
  environmentPrefix: "YTC",
  performanceMode: "balanced",
  enableParallelProcessing: true,
  preferMultimodal: true,
  defaultMaxTokens: 4096,
  // Good balance for Gemini video processing
  defaultTemperature: 0.5
  // Balanced creativity vs consistency
};
var YoutubeClipperPlugin = class extends import_obsidian8.Plugin {
  constructor() {
    super(...arguments);
    this.settings = DEFAULT_SETTINGS;
    this.isUnloading = false;
    this.operationCount = 0;
  }
  async onload() {
    this.manifest.version = PLUGIN_VERSION;
    logger.info(`Initializing YoutubeClipper Plugin v${PLUGIN_VERSION}...`);
    try {
      await this.loadSettings();
      this.setupLogger();
      await this.initializeServices();
      this.registerUIComponents();
      this.setupUrlHandling();
      this.setupProtocolHandler();
      logger.plugin("Plugin loaded successfully");
    } catch (error) {
      logger.error("Failed to load plugin", "Plugin", {
        error: error instanceof Error ? error.message : String(error)
      });
      ErrorHandler.handle(error, "Plugin initialization");
      new import_obsidian8.Notice("Failed to load YoutubeClipper Plugin. Check console for details.");
    }
  }
  onunload() {
    var _a, _b, _c;
    logger.plugin("Unloading YoutubeClipper Plugin...");
    this.isUnloading = true;
    try {
      (_a = this.urlHandler) == null ? void 0 : _a.clear();
      (_b = this.modalManager) == null ? void 0 : _b.clear();
      (_c = this.serviceContainer) == null ? void 0 : _c.clearServices();
      this.cleanupUIElements();
      ConflictPrevention.cleanupAllElements();
      logger.plugin("Plugin unloaded successfully");
    } catch (error) {
      logger.error("Error during plugin unload", "Plugin", {
        error: error instanceof Error ? error.message : String(error)
      });
    }
  }
  setupLogger() {
    const isDev = true;
    logger.updateConfig({
      level: isDev ? 0 /* DEBUG */ : 1 /* INFO */,
      enableConsole: true,
      enableFile: false,
      maxLogEntries: 1e3
    });
  }
  async initializeServices() {
    this.serviceContainer = new ServiceContainer(this.settings, this.app);
    this.modalManager = new ModalManager();
    this.urlHandler = new UrlHandler(
      this.app,
      this.settings,
      this.handleUrlDetection.bind(this)
    );
  }
  setupUrlHandling() {
    if (!this.urlHandler)
      return;
    this.registerEvent(this.app.vault.on("create", (file) => {
      if (file instanceof import_obsidian8.TFile) {
        this.safeOperation(() => this.urlHandler.handleFileCreate(file), "Handle file create");
      }
    }));
    this.registerEvent(this.app.workspace.on("active-leaf-change", () => {
      this.safeOperation(() => this.urlHandler.handleActiveLeafChange(), "Handle active leaf change");
    }));
  }
  setupProtocolHandler() {
    var _a;
    try {
      (_a = this.registerObsidianProtocolHandler) == null ? void 0 : _a.call(this, "youtube-clipper", (params) => {
        var _a2;
        (_a2 = this.urlHandler) == null ? void 0 : _a2.handleProtocol(params);
      });
    } catch (error) {
      logger.debug("Protocol handler not available", "Plugin");
    }
  }
  registerUIComponents() {
    this.ribbonIcon = this.addRibbonIcon("film", "Process YouTube Video", () => {
      void this.safeShowUrlModal();
    });
    logger.plugin("Ribbon icon set successfully");
    this.addCommand({
      id: `${PLUGIN_PREFIX}-process-youtube-video`,
      name: "Process YouTube Video",
      callback: () => {
        void this.safeShowUrlModal();
      }
    });
    this.addSettingTab(new YouTubeSettingsTab(this.app, {
      plugin: this,
      onSettingsChange: this.handleSettingsChange.bind(this)
    }));
    this.addCommand({
      id: `${PLUGIN_PREFIX}-open-url-from-clipboard`,
      name: "YouTube Clipper: Open URL Modal (from clipboard)",
      callback: async () => {
        await this.handleClipboardUrl();
      }
    });
  }
  cleanupUIElements() {
    if (this.ribbonIcon) {
      this.ribbonIcon.remove();
      this.ribbonIcon = null;
    }
  }
  handleUrlDetection(result) {
    logger.info("URL detected, opening modal", "Plugin", {
      url: result.url,
      source: result.source,
      filePath: result.filePath
    });
    void this.safeShowUrlModal(result.url);
  }
  async handleClipboardUrl() {
    try {
      if (!this.urlHandler)
        return;
      await this.urlHandler.handleClipboardUrl();
      const manual = window.prompt("Paste YouTube URL to open in YouTube Clipper:");
      if (manual && ValidationUtils.isValidYouTubeUrl(manual.trim())) {
        void this.safeShowUrlModal(manual.trim());
      } else {
        new import_obsidian8.Notice("No valid YouTube URL provided.");
      }
    } catch (error) {
      ErrorHandler.handle(error, "Open URL from clipboard");
    }
  }
  async safeShowUrlModal(initialUrl) {
    if (!this.modalManager || !this.serviceContainer)
      return;
    await this.safeOperation(async () => {
      return this.modalManager.openModal(
        initialUrl,
        () => this.openYouTubeUrlModal(initialUrl),
        () => {
          logger.debug("Modal closed", "Plugin", { url: initialUrl });
        }
      );
    }, "Show URL Modal");
  }
  async openYouTubeUrlModal(initialUrl) {
    if (this.isUnloading) {
      ConflictPrevention.log("Plugin is unloading, ignoring modal request");
      return;
    }
    ConflictPrevention.safeOperation(async () => {
      if (!this.serviceContainer)
        return;
      const aiService = this.serviceContainer.aiService;
      const providers = aiService ? aiService.getProviderNames() : [];
      const modelOptionsMap = this.settings.modelOptionsCache || {};
      if (aiService && (!this.settings.modelOptionsCache || Object.keys(this.settings.modelOptionsCache).length === 0)) {
        for (const provider of providers) {
          modelOptionsMap[provider] = aiService.getProviderModels(provider) || [];
        }
      }
      const modal = new YouTubeUrlModal(this.app, {
        onProcess: this.processYouTubeVideo.bind(this),
        onOpenFile: this.openFileByPath.bind(this),
        ...initialUrl && { initialUrl },
        providers,
        defaultProvider: "gemini",
        // Prefer Gemini as default provider
        defaultModel: "gemini-2.5-pro",
        // Use the latest Gemini model
        defaultMaxTokens: this.settings.defaultMaxTokens,
        defaultTemperature: this.settings.defaultTemperature,
        modelOptions: modelOptionsMap,
        fetchModels: async () => {
          try {
            const map = await this.serviceContainer.aiService.fetchLatestModels();
            this.settings.modelOptionsCache = map;
            await this.saveSettings();
            return map;
          } catch (error) {
            return modelOptionsMap;
          }
        },
        performanceMode: this.settings.performanceMode || "balanced",
        enableParallelProcessing: this.settings.enableParallelProcessing || false,
        preferMultimodal: this.settings.preferMultimodal || false,
        onPerformanceSettingsChange: async (performanceMode, enableParallel, preferMultimodal) => {
          this.settings.performanceMode = performanceMode;
          this.settings.enableParallelProcessing = enableParallel;
          this.settings.preferMultimodal = preferMultimodal;
          await this.saveSettings();
          this.serviceContainer = new ServiceContainer(this.settings, this.app);
        }
      });
      modal.open();
    }, "YouTube URL Modal").catch((error) => {
      ErrorHandler.handle(error, "Opening YouTube URL modal");
    });
  }
  async processYouTubeVideo(url, format = "detailed-guide", providerName, model, customPrompt, performanceMode, enableParallel, preferMultimodal, maxTokens, temperature) {
    if (this.isUnloading) {
      ConflictPrevention.log("Plugin is unloading, cancelling video processing");
      throw new Error("Plugin is shutting down");
    }
    const result = await ConflictPrevention.safeOperation(async () => {
      var _a, _b;
      new import_obsidian8.Notice(MESSAGES.PROCESSING);
      const validation = ValidationUtils.validateSettings(this.settings);
      if (!validation.isValid) {
        throw new Error(`Configuration invalid: ${validation.errors.join(", ")}`);
      }
      if (!this.serviceContainer)
        throw new Error("Service container not initialized");
      const youtubeService = this.serviceContainer.videoService;
      const aiService = this.serviceContainer.aiService;
      const fileService = this.serviceContainer.fileService;
      const promptService = this.serviceContainer.promptService;
      const videoId = youtubeService.extractVideoId(url);
      if (!videoId) {
        throw new Error(MESSAGES.ERRORS.VIDEO_ID_EXTRACTION);
      }
      const videoData = await youtubeService.getVideoData(videoId);
      let promptToUse;
      if (format === "custom") {
        promptToUse = customPrompt;
      } else {
        promptToUse = (_a = this.settings.customPrompts) == null ? void 0 : _a[format];
      }
      const prompt = promptService.createAnalysisPrompt(videoData, url, format, promptToUse);
      logger.aiService("Processing video", {
        videoId,
        format,
        provider: providerName || "Auto",
        model: model || "Default",
        maxTokens: maxTokens || 2048,
        temperature: temperature || 0.7
      });
      const providers = aiService.providers || [];
      for (const provider of providers) {
        if (maxTokens && provider.setMaxTokens) {
          provider.setMaxTokens(maxTokens);
        }
        if (temperature !== void 0 && provider.setTemperature) {
          provider.setTemperature(temperature);
        }
      }
      let aiResponse;
      try {
        if (providerName) {
          aiResponse = await aiService.processWith(providerName, prompt, model);
        } else {
          aiResponse = await aiService.process(prompt);
        }
        logger.aiService("AI Response received", {
          provider: aiResponse.provider,
          model: aiResponse.model,
          contentLength: ((_b = aiResponse.content) == null ? void 0 : _b.length) || 0
        });
      } catch (error) {
        logger.error("AI Processing failed", "Plugin", {
          error: error instanceof Error ? error.message : String(error)
        });
        if (error instanceof Error) {
          ErrorHandler.handleEnhanced(error, "AI Processing");
        }
        throw error;
      }
      const formattedContent = promptService.processAIResponse(
        aiResponse.content,
        aiResponse.provider,
        aiResponse.model,
        format,
        videoData,
        url
      );
      const filePath = await fileService.saveToFile(
        videoData.title,
        formattedContent,
        this.settings.outputPath
      );
      new import_obsidian8.Notice(MESSAGES.SUCCESS(videoData.title));
      return filePath;
    }, "YouTube Video Processing");
    if (!result) {
      throw new Error("Failed to process YouTube video");
    }
    return result;
  }
  async openFileByPath(filePath) {
    try {
      await new Promise((resolve) => setTimeout(resolve, 300));
      const cleanPath = filePath.startsWith("/") ? filePath.substring(1) : filePath;
      const file = this.app.vault.getAbstractFileByPath(cleanPath);
      if (!file || !(file instanceof import_obsidian8.TFile)) {
        throw new Error(`File not found at path: ${cleanPath}`);
      }
      await this.openFileInNewTab(file);
    } catch (error) {
      ErrorHandler.handle(error, "Opening file by path");
      throw error;
    }
  }
  async openFileInNewTab(file) {
    try {
      const leaf = this.app.workspace.getLeaf("tab");
      await leaf.openFile(file);
      this.app.workspace.setActiveLeaf(leaf);
      new import_obsidian8.Notice(`\u{1F4C2} Opened: ${file.name}`);
    } catch (error) {
      try {
        const currentLeaf = this.app.workspace.getLeaf(false);
        await currentLeaf.openFile(file);
        new import_obsidian8.Notice(`\u{1F4C2} Opened: ${file.name}`);
      } catch (fallbackError) {
        ErrorHandler.handle(fallbackError, "Opening file in current tab");
        new import_obsidian8.Notice(`Note saved as "${file.name}" but could not auto-open. Please open manually.`);
      }
    }
  }
  showPersistentSaveConfirmation(file) {
    try {
      const modal = new SaveConfirmationModal(this.app, file, (shouldOpen) => {
        if (shouldOpen) {
          void this.openFileInNewTab(file);
        }
      });
      modal.open();
    } catch (error) {
      ErrorHandler.handle(error, "Showing save confirmation");
      new import_obsidian8.Notice(`File saved: ${file.name}. Click to open.`, 0).noticeEl.onclick = () => {
        void this.openFileInNewTab(file);
      };
    }
  }
  async handleSettingsChange(newSettings) {
    var _a, _b;
    try {
      this.settings = { ...newSettings };
      await this.saveSettings();
      await ((_a = this.serviceContainer) == null ? void 0 : _a.updateSettings(this.settings));
      (_b = this.urlHandler) == null ? void 0 : _b.updateSettings(this.settings);
    } catch (error) {
      ErrorHandler.handle(error, "Settings update");
      throw error;
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async safeOperation(operation, operationName) {
    if (this.isUnloading) {
      logger.warn(`Attempted ${operationName} during plugin unload - skipping`, "Plugin");
      return null;
    }
    const opId = ++this.operationCount;
    logger.info(`Starting operation ${opId}: ${operationName}`, "Plugin");
    try {
      const result = await operation();
      logger.info(`Completed operation ${opId}: ${operationName}`, "Plugin");
      return result;
    } catch (error) {
      logger.error(`Failed operation ${opId}: ${operationName}`, "Plugin", {
        error: error instanceof Error ? error.message : String(error)
      });
      ErrorHandler.handle(error, operationName);
      return null;
    }
  }
  getServiceContainer() {
    return this.serviceContainer;
  }
  // Expose services for testing and external access
  getUrlHandler() {
    return this.urlHandler;
  }
  getModalManager() {
    return this.modalManager;
  }
  // Public method to get current settings
  getCurrentSettings() {
    return { ...this.settings };
  }
};
