/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/styles.ts
var MODAL_STYLES, INPUT_STYLES;
var init_styles = __esm({
  "src/styles.ts"() {
    "use strict";
    MODAL_STYLES = {
      zIndex: "10000",
      display: "flex",
      header: {
        marginBottom: "15px",
        color: "var(--text-accent)"
      },
      message: {
        marginBottom: "20px",
        lineHeight: "1.5"
      },
      buttonContainer: {
        marginTop: "20px",
        display: "flex",
        gap: "10px",
        justifyContent: "flex-end"
      },
      button: {
        padding: "8px 16px",
        minWidth: "100px"
      }
    };
    INPUT_STYLES = {
      width: "100%",
      marginTop: "8px",
      padding: "8px",
      border: "1px solid var(--background-modifier-border)",
      borderRadius: "4px"
    };
  }
});

// src/dom.ts
var DOMUtils;
var init_dom = __esm({
  "src/dom.ts"() {
    "use strict";
    init_styles();
    DOMUtils = class _DOMUtils {
      /**
       * Apply styles to an HTML element
       */
      static applyStyles(element, styles) {
        Object.assign(element.style, styles);
      }
      /**
       * Create a standardized button container
       */
      static createButtonContainer(parent) {
        const container = parent.createDiv();
        this.applyStyles(container, MODAL_STYLES.buttonContainer);
        return container;
      }
      /**
       * Create a styled button with consistent appearance
       */
      static createStyledButton(container, text, isPrimary = false, onClick) {
        const button = container.createEl("button", { text });
        if (isPrimary) {
          button.classList.add("mod-cta");
        }
        this.applyStyles(button, MODAL_STYLES.button);
        if (onClick) {
          button.addEventListener("click", onClick);
        }
        return button;
      }
      /**
       * Create a styled input field
       */
      static createStyledInput(container, type, placeholder, value = "") {
        const input = container.createEl("input", {
          type,
          placeholder,
          value
        });
        this.applyStyles(input, INPUT_STYLES);
        return input;
      }
      /**
       * Set up modal base styling for consistency
       */
      static setupModalStyling(modalEl) {
        this.applyStyles(modalEl, {
          zIndex: MODAL_STYLES.zIndex,
          display: MODAL_STYLES.display
        });
      }
      /**
       * Create a header element with consistent styling
       */
      static createModalHeader(parent, text) {
        const header = parent.createEl("h2", { text });
        this.applyStyles(header, MODAL_STYLES.header);
        return header;
      }
      /**
       * Create a message paragraph with consistent styling
       */
      static createModalMessage(parent, text) {
        const message = parent.createEl("p");
        message.setText(text);
        this.applyStyles(message, MODAL_STYLES.message);
        return message;
      }
      /**
       * Set up keyboard event handlers for modals
       */
      static setupModalKeyHandlers(element, onEnter, onEscape) {
        element.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            e.preventDefault();
            e.stopPropagation();
            onEnter();
          }
          if (e.key === "Escape" && onEscape) {
            e.preventDefault();
            e.stopPropagation();
            onEscape();
          }
        });
      }
      // Instance methods implementing interface
      applyStyles(element, styles) {
        _DOMUtils.applyStyles(element, styles);
      }
      createButtonContainer(parent) {
        return _DOMUtils.createButtonContainer(parent);
      }
      createStyledButton(container, text, isPrimary = false, onClick) {
        return _DOMUtils.createStyledButton(container, text, isPrimary, onClick);
      }
    };
  }
});

// src/api.ts
var API_ENDPOINTS, AI_MODELS, PROVIDER_MODEL_OPTIONS, PROVIDER_MODEL_LIST_URLS, PROVIDER_MODEL_REGEX, API_LIMITS, TIMEOUTS;
var init_api = __esm({
  "src/api.ts"() {
    "use strict";
    API_ENDPOINTS = {
      GEMINI: "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-pro:generateContent",
      GROQ: "https://api.groq.com/openai/v1/chat/completions",
      YOUTUBE_OEMBED: "https://www.youtube.com/oembed",
      CORS_PROXY: "https://api.allorigins.win/raw"
    };
    AI_MODELS = {
      GEMINI: "gemini-2.5-pro",
      // Set Gemini model to gemini-2.5-pro
      GROQ: "llama-3.3-70b-versatile"
    };
    PROVIDER_MODEL_OPTIONS = {
      "Google Gemini": [
        // Gemini 2.5 series (latest, all support multimodal video analysis)
        { name: "gemini-2.5-pro", supportsAudioVideo: true },
        { name: "gemini-2.5-pro-tts", supportsAudioVideo: true },
        { name: "gemini-2.5-flash", supportsAudioVideo: true },
        { name: "gemini-2.5-flash-lite", supportsAudioVideo: true },
        // Gemini 2.0 series (video support via native API, but no explicit multimodal flag)
        { name: "gemini-2.0-pro", supportsAudioVideo: true },
        { name: "gemini-2.0-flash" },
        { name: "gemini-2.0-flash-lite" },
        // Gemini 1.5 series (available, supports video via File API)
        { name: "gemini-1.5-pro" },
        { name: "gemini-1.5-flash" }
      ],
      "Groq": [
        // Latest models (Nov 2024 - Nov 2025)
        // Note: Groq models prioritize speed/text; for multimodal video, Gemini is recommended
        { name: "llama-4-maverick-17b-128e-instruct" },
        { name: "llama-4-scout-17b-16e-instruct" },
        // Llama 3.x series
        { name: "llama-3.3-70b-versatile" },
        { name: "llama-3.1-8b-instant" }
      ],
      "Ollama": [
        // Various Ollama models
        { name: "qwen3-coder:480b-cloud" },
        { name: "llama3.2" },
        { name: "llama3.1" },
        { name: "mistral" },
        { name: "mixtral" },
        { name: "gemma2" },
        { name: "phi3" },
        { name: "qwen2" },
        { name: "command-r" }
      ]
    };
    PROVIDER_MODEL_LIST_URLS = {
      "Google Gemini": "https://developers.generativeai.google/models",
      "Groq": "https://groq.com",
      "Ollama": "http://localhost:11434"
      // Local Ollama instance
    };
    PROVIDER_MODEL_REGEX = {
      "Google Gemini": /gemini[-_\.]?\d+(?:\.\d+)?(?:-[a-z0-9\-]+)?/gi,
      "Groq": /llama[-_\.]?\d+(?:\.\d+)?(?:-[a-z0-9\-]+)?/gi,
      "Ollama": /[a-zA-Z0-9]+(?:[-_:][a-zA-Z0-9]+)*/g
      // General pattern for Ollama models
    };
    API_LIMITS = {
      MAX_TOKENS: 8e3,
      // Increased from 2000 to handle comprehensive tutorials
      TEMPERATURE: 0.7,
      DESCRIPTION_MAX_LENGTH: 1e3,
      TITLE_MAX_LENGTH: 100
    };
    TIMEOUTS = {
      FILE_CREATION_WAIT: 300,
      MODAL_DELAY: 100,
      FALLBACK_MODAL_CHECK: 500,
      FOCUS_DELAY: 150,
      REPAINT_DELAY: 50
    };
  }
});

// src/confirmation-modal.ts
var confirmation_modal_exports = {};
__export(confirmation_modal_exports, {
  ConfirmationModal: () => ConfirmationModal
});
var ConfirmationModal;
var init_confirmation_modal = __esm({
  "src/confirmation-modal.ts"() {
    "use strict";
    init_base_modal();
    ConfirmationModal = class extends BaseModal {
      constructor(app, options) {
        super(app);
        this.options = options;
        this.result = false;
      }
      onOpen() {
        this.createModalContent();
        this.setupEventHandlers();
        this.focusConfirmButton();
      }
      /**
       * Create modal content with accessible structure
       */
      createModalContent() {
        const header = this.createHeader(this.options.title);
        header.setAttribute("id", "confirmation-modal-title");
        const messageContainer = this.contentEl.createDiv("confirmation-message");
        messageContainer.setAttribute("id", "confirmation-modal-description");
        messageContainer.textContent = this.options.message;
        const buttonContainer = this.createButtonContainer();
        buttonContainer.style.marginTop = "20px";
        const confirmText = this.options.confirmText || "Confirm";
        const cancelText = this.options.cancelText || "Cancel";
        const isDangerous = this.options.isDangerous || false;
        if (isDangerous) {
          this.cancelButton = this.createButton(
            buttonContainer,
            cancelText,
            false,
            () => this.handleCancel()
          );
          this.cancelButton.setAttribute("aria-label", `Cancel: ${cancelText}`);
          this.confirmButton = this.createButton(
            buttonContainer,
            confirmText,
            true,
            () => this.handleConfirm()
          );
          this.confirmButton.setAttribute("aria-label", `Confirm: ${confirmText}`);
        } else {
          this.confirmButton = this.createButton(
            buttonContainer,
            confirmText,
            true,
            () => this.handleConfirm()
          );
          this.confirmButton.setAttribute("aria-label", `Confirm: ${confirmText}`);
          this.cancelButton = this.createButton(
            buttonContainer,
            cancelText,
            false,
            () => this.handleCancel()
          );
          this.cancelButton.setAttribute("aria-label", `Cancel: ${cancelText}`);
        }
        this.contentEl.setAttribute("aria-labelledby", "confirmation-modal-title");
        this.contentEl.setAttribute("aria-describedby", "confirmation-modal-description");
        this.contentEl.setAttribute("role", "alertdialog");
      }
      /**
       * Set up keyboard event handlers (Enter to confirm, Escape to cancel)
       */
      setupEventHandlers() {
        this.scope.register([], "Enter", () => {
          this.handleConfirm();
          return false;
        });
        this.scope.register([], "Escape", () => {
          this.handleCancel();
          return false;
        });
      }
      /**
       * Focus the confirm button by default
       */
      focusConfirmButton() {
        if (this.confirmButton) {
          setTimeout(() => {
            this.confirmButton.focus();
          }, 50);
        }
      }
      /**
       * Handle confirmation (Confirm button or Enter key)
       */
      handleConfirm() {
        this.result = true;
        if (this.resolver) {
          this.resolver(true);
        }
        this.close();
      }
      /**
       * Handle cancellation (Cancel button or Escape key)
       */
      handleCancel() {
        this.result = false;
        if (this.resolver) {
          this.resolver(false);
        }
        this.close();
      }
      /**
       * Open modal and wait for user response
       * Returns promise that resolves to true if confirmed, false if cancelled
       */
      openAndWait() {
        return new Promise((resolve) => {
          this.resolver = resolve;
          this.open();
        });
      }
      /**
       * Get the result (synchronous if already closed)
       */
      getResult() {
        return this.result;
      }
    };
  }
});

// src/base-modal.ts
var import_obsidian4, MODAL_CSS_CLASSES, BaseModal;
var init_base_modal = __esm({
  "src/base-modal.ts"() {
    "use strict";
    import_obsidian4 = require("obsidian");
    init_dom();
    init_styles();
    init_api();
    MODAL_CSS_CLASSES = {
      modal: "ytc-modal",
      header: "ytc-modal-header",
      content: "ytc-modal-content",
      button: "ytc-modal-button",
      input: "ytc-modal-input"
    };
    BaseModal = class extends import_obsidian4.Modal {
      constructor(app) {
        super(app);
        this.events = {};
        this.isDisposed = false;
        this.setupModalStyling();
        this.setupConflictPrevention();
      }
      /**
       * Set up base modal styling for consistency
       */
      setupModalStyling() {
        DOMUtils.setupModalStyling(this.modalEl);
        this.modalEl.addClass(MODAL_CSS_CLASSES.modal);
        this.contentEl.addClass(MODAL_CSS_CLASSES.content);
      }
      /**
       * Set up conflict prevention measures
       */
      setupConflictPrevention() {
        this.modalEl.setAttribute("data-plugin", "youtube-clipper");
        this.modalEl.style.zIndex = "9999";
      }
      /**
       * Create standardized modal header with conflict prevention
       */
      createHeader(text) {
        const header = DOMUtils.createModalHeader(this.contentEl, text);
        header.addClass(MODAL_CSS_CLASSES.header);
        return header;
      }
      /**
       * Create standardized modal message
       */
      createMessage(text) {
        return DOMUtils.createModalMessage(this.contentEl, text);
      }
      /**
       * Create standardized button container
       */
      createButtonContainer() {
        return DOMUtils.createButtonContainer(this.contentEl);
      }
      /**
      * Create standardized button with conflict prevention and accessibility
      */
      createButton(container, text, isPrimary = false, onClick) {
        const button = DOMUtils.createStyledButton(container, text, isPrimary, onClick);
        button.addClass(MODAL_CSS_CLASSES.button);
        button.setAttribute("data-plugin", "youtube-clipper");
        button.setAttribute("role", "button");
        if (!button.getAttribute("aria-label")) {
          button.setAttribute("aria-label", text);
        }
        return button;
      }
      /**
       * Create standardized input with conflict prevention and accessibility
       */
      createInput(container, type, placeholder) {
        const input = container.createEl("input", {
          type,
          placeholder
        });
        DOMUtils.applyStyles(input, INPUT_STYLES);
        input.addClass(MODAL_CSS_CLASSES.input);
        input.setAttribute("data-plugin", "youtube-clipper");
        if (placeholder) {
          input.setAttribute("aria-label", placeholder);
        }
        return input;
      }
      /**
       * Set up keyboard event handlers
       */
      setupKeyHandlers(onEnter, onEscape) {
        const wrappedOnEnter = async () => {
          try {
            await onEnter();
          } catch (error) {
            console.error("Enter key handler error:", error);
          }
        };
        const wrappedOnEscape = onEscape ? async () => {
          try {
            await onEscape();
          } catch (error) {
            console.error("Escape key handler error:", error);
          }
        } : void 0;
        DOMUtils.setupModalKeyHandlers(this.contentEl, wrappedOnEnter, wrappedOnEscape);
      }
      /**
       * Focus element with delay for better UX
       */
      focusElement(element, delay = TIMEOUTS.FOCUS_DELAY) {
        setTimeout(() => {
          element.focus();
        }, delay);
      }
      /**
       * Set up event handlers
       */
      setEvents(events) {
        this.events = events;
      }
      /**
       * Show custom styled confirmation dialog before closing
       * This uses our custom ConfirmationModal instead of the native browser confirm()
       * for better accessibility and UX.
       * 
       * Note: This is now synchronous for backwards compatibility with existing callers,
       * but returns a boolean immediately. For async confirmation with proper modal,
       * use showConfirmationModal() instead.
       */
      confirmClose(message) {
        return confirm(message);
      }
      /**
       * Show a custom accessible confirmation modal and wait for user response.
       * Preferred method for confirmation dialogs (async, fully accessible).
       */
      async showConfirmationModal(title, message, confirmText = "Confirm", cancelText = "Cancel", isDangerous = false) {
        const { ConfirmationModal: ConfirmationModal2 } = await Promise.resolve().then(() => (init_confirmation_modal(), confirmation_modal_exports));
        const modal = new ConfirmationModal2(this.app, {
          title,
          message,
          confirmText,
          cancelText,
          isDangerous
        });
        return modal.openAndWait();
      }
      /**
       * Force modal visibility (for stubborn modals)
       */
      forceVisible() {
        setTimeout(() => {
          DOMUtils.setupModalStyling(this.modalEl);
        }, TIMEOUTS.REPAINT_DELAY);
      }
      /**
       * Clean up on close with proper disposal
       */
      onClose() {
        if (this.isDisposed) {
          return;
        }
        console.log("[youtube-clipper] Cleaning up modal");
        this.isDisposed = true;
        const { contentEl } = this;
        contentEl.empty();
        this.modalEl.removeClass(MODAL_CSS_CLASSES.modal);
        this.modalEl.removeAttribute("data-plugin");
        console.log("[youtube-clipper] Modal cleanup complete");
      }
    };
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => YoutubeClipperPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian8 = require("obsidian");

// src/conflict-prevention.ts
var ConflictPrevention = class {
  /**
   * Check if another plugin might be conflicting
   */
  static checkForPotentialConflicts() {
    const warnings = [];
    const suspiciousElements = [
      'div[data-plugin="web-clipper"]',
      ".web-clipper-modal",
      ".clipper-button",
      '[id*="clipper"]',
      '[class*="clip"]'
    ];
    suspiciousElements.forEach((selector) => {
      const elements = document.querySelectorAll(selector);
      if (elements.length > 0) {
        warnings.push(`Detected potential plugin conflict: ${selector}`);
      }
    });
    return warnings;
  }
  /**
   * Add conflict prevention attributes to an element
   */
  static markElement(element, type) {
    element.setAttribute("data-plugin", this.PLUGIN_ID);
    element.setAttribute("data-ytc-type", type);
    element.addClass(`${this.CSS_PREFIX}-${type}`);
  }
  /**
   * Remove conflict prevention attributes
   */
  static unmarkElement(element) {
    element.removeAttribute("data-plugin");
    element.removeAttribute("data-ytc-type");
    const classes = Array.from(element.classList);
    classes.forEach((className) => {
      if (className.startsWith(this.CSS_PREFIX)) {
        element.removeClass(className);
      }
    });
  }
  /**
   * Create a namespaced ID to prevent conflicts
   */
  static createUniqueId(base) {
    return `${this.CSS_PREFIX}-${base}-${Date.now()}`;
  }
  /**
   * Clean up all plugin elements from DOM
   */
  static cleanupAllElements() {
    const elements = document.querySelectorAll(`[data-plugin="${this.PLUGIN_ID}"]`);
    elements.forEach((element) => {
      if (element instanceof HTMLElement) {
        this.unmarkElement(element);
      }
    });
  }
  /**
   * Get safe storage key with namespace
   */
  static getStorageKey(key) {
    return `${this.PLUGIN_ID}-${key}`;
  }
  /**
   * Log plugin activity with namespace
   */
  static log(message, level = "info") {
    const timestamp = (/* @__PURE__ */ new Date()).toISOString();
    const logMessage = `[${this.PLUGIN_ID}] ${timestamp} - ${message}`;
    switch (level) {
      case "warn":
        console.warn(logMessage);
        break;
      case "error":
        console.error(logMessage);
        break;
      default:
        console.log(logMessage);
    }
  }
  /**
   * Check if plugin is safe to operate
   */
  static isSafeToOperate() {
    const conflicts = this.checkForPotentialConflicts();
    if (conflicts.length > 0) {
      this.log(`Potential conflicts detected: ${conflicts.join(", ")}`, "warn");
      return false;
    }
    return true;
  }
  /**
   * Wrap async operations with conflict checking
   */
  static async safeOperation(operation, operationName) {
    if (!this.isSafeToOperate()) {
      this.log(`Skipping ${operationName} due to potential conflicts`, "warn");
      return null;
    }
    try {
      this.log(`Starting ${operationName}`);
      const result = await operation();
      this.log(`Completed ${operationName}`);
      return result;
    } catch (error) {
      this.log(`Error in ${operationName}: ${error}`, "error");
      throw error;
    }
  }
};
ConflictPrevention.PLUGIN_ID = "youtube-clipper";
ConflictPrevention.CSS_PREFIX = "ytc";

// src/messages.ts
var MESSAGES = {
  PROCESSING: "Processing YouTube video...",
  SUCCESS: (title) => `Successfully processed: ${title}`,
  OPENED_FILE: (filename) => `Opened: ${filename}`,
  ERRORS: {
    INVALID_URL: "Invalid YouTube URL. Please provide a valid YouTube video URL (e.g., https://www.youtube.com/watch?v=VIDEO_ID)",
    MISSING_API_KEYS: "No valid Gemini or Groq API key configured. Please set one in plugin settings.",
    GEMINI_INVALID_KEY: "Gemini API key is invalid or missing. Please check your key.",
    GROQ_MODEL_NOT_FOUND: "Groq API error: Model not found or you do not have access. Please check your API key and model name.",
    FETCH_VIDEO_DATA: (status) => `Failed to fetch video metadata: ${status}`,
    SAVE_FILE: (message) => `Failed to save file: ${message}`,
    AI_PROCESSING: (message) => `AI processing failed: ${message}`,
    FILE_NOT_EXISTS: "File no longer exists",
    COULD_NOT_OPEN: (message) => `Could not open file: ${message}`,
    ENTER_URL: "Please enter a YouTube URL",
    VIDEO_ID_EXTRACTION: "Could not extract video ID from URL. Please check the URL format.",
    NETWORK_ERROR: "Network error occurred. Please check your internet connection and try again.",
    // Quota and billing errors
    QUOTA_EXCEEDED: (provider) => `${provider} API quota exceeded. Please check your plan and billing details, or try again later.`,
    RATE_LIMITED: (provider) => `${provider} API rate limit reached. Please wait a moment and try again.`,
    BILLING_REQUIRED: (provider) => `${provider} requires a paid plan. Please check your billing settings.`,
    CREDIT_EXHAUSTED: (provider) => `${provider} API credits exhausted. Please top up your account or upgrade your plan.`
  },
  WARNINGS: {
    CORS_RESTRICTIONS: "Description not available due to CORS restrictions",
    EXTRACTION_FAILED: "Description extraction failed",
    AUTO_EXTRACTION: "Video description could not be extracted automatically."
  },
  MODALS: {
    YOUTUBE_PROCESSED: "YouTube Video Processed",
    CONFIRM_OPEN: (filename) => `Successfully processed YouTube video and saved as "${filename}". Would you like to open the note now?`,
    CLOSE_CONFIRMATION: "Close without opening the note?",
    PROCESS_VIDEO: "Process YouTube Video",
    YES_OPEN: "Yes, open note",
    NO_THANKS: "No, thanks",
    CANCEL: "Cancel",
    PROCESS: "Process"
  },
  PLACEHOLDERS: {
    YOUTUBE_URL: "https://www.youtube.com/watch?v=...",
    GEMINI_KEY: "AIza...",
    GROQ_KEY: "gsk_...",
    OUTPUT_PATH: "YouTube/Processed Videos"
  }
};

// src/validation.ts
var ValidationUtils = class {
  /**
   * Clean and normalize YouTube URL
   */
  static cleanYouTubeUrl(url) {
    if (!url || typeof url !== "string") {
      return "";
    }
    let cleanUrl = url.trim();
    cleanUrl = cleanUrl.replace(/[\u200B-\u200D\uFEFF]/g, "");
    if (!cleanUrl.startsWith("http://") && !cleanUrl.startsWith("https://")) {
      cleanUrl = "https://" + cleanUrl;
    }
    if (cleanUrl.startsWith("http://youtube.com") || cleanUrl.startsWith("http://www.youtube.com")) {
      cleanUrl = cleanUrl.replace("http://", "https://");
    }
    return cleanUrl;
  }
  /**
   * Extract YouTube video ID from URL (memoized for performance)
   * Enhanced extraction with better error handling
   */
  static extractVideoId(url) {
    if (!url || typeof url !== "string")
      return null;
    if (this.URL_CACHE.has(url)) {
      return this.URL_CACHE.get(url);
    }
    const cleanUrl = this.cleanYouTubeUrl(url);
    let result = null;
    let match = cleanUrl.match(this.URL_PATTERNS[0]);
    if ((match == null ? void 0 : match[1]) && this.VIDEO_ID_REGEX.test(match[1])) {
      result = match[1];
    } else {
      for (let i = 1; i < this.URL_PATTERNS.length && !result; i++) {
        match = cleanUrl.match(this.URL_PATTERNS[i]);
        if ((match == null ? void 0 : match[1]) && this.VIDEO_ID_REGEX.test(match[1])) {
          result = match[1];
        }
      }
    }
    if (this.URL_CACHE.size > 100) {
      this.URL_CACHE.clear();
    }
    this.URL_CACHE.set(url, result);
    if (!result) {
      console.warn("Failed to extract video ID from URL:", url);
    }
    return result;
  }
  /**
   * Validate YouTube URL format
   */
  static isValidYouTubeUrl(url) {
    return this.extractVideoId(url) !== null;
  }
  /**
   * Sanitize filename for file system compatibility
   */
  static sanitizeFilename(filename, maxLength = 100) {
    return filename.replace(/[<>:"/\\|?*]/g, "").replace(/\s+/g, " ").trim().substring(0, maxLength);
  }
  /**
   * Validate API key format
   */
  static isValidAPIKey(key, provider) {
    if (!key || typeof key !== "string") {
      return false;
    }
    switch (provider) {
      case "gemini":
        return key.startsWith("AIza") && key.length > 10;
      case "groq":
        return key.startsWith("gsk_") && key.length > 10;
      default:
        return false;
    }
  }
  /**
   * Validate settings configuration
   */
  static validateSettings(settings) {
    const errors = [];
    const usingEnv = Boolean(settings.useEnvironmentVariables);
    const hasDirectKey = this.isNonEmptyString(settings.geminiApiKey) || this.isNonEmptyString(settings.groqApiKey);
    if (!hasDirectKey && !usingEnv) {
      errors.push(MESSAGES.ERRORS.MISSING_API_KEYS);
    }
    if (this.isNonEmptyString(settings.geminiApiKey) && !this.isValidAPIKey(settings.geminiApiKey, "gemini")) {
      errors.push("Invalid Gemini API key format");
    }
    if (this.isNonEmptyString(settings.groqApiKey) && !this.isValidAPIKey(settings.groqApiKey, "groq")) {
      errors.push("Invalid Groq API key format");
    }
    if (usingEnv && !this.isNonEmptyString(settings.environmentPrefix)) {
      errors.push("Environment variable prefix is required when using environment variables");
    }
    if (!settings.outputPath || typeof settings.outputPath !== "string") {
      errors.push("Output path is required");
    }
    return {
      isValid: errors.length === 0,
      errors
    };
  }
  /**
   * Validate file path
   */
  static isValidPath(path) {
    return typeof path === "string" && path.trim().length > 0;
  }
  /**
   * Validate that a string is not empty
   */
  static isNonEmptyString(value) {
    return typeof value === "string" && value.trim().length > 0;
  }
  /**
   * Truncate text to specified length with ellipsis
   */
  static truncateText(text, maxLength) {
    if (text.length <= maxLength) {
      return text;
    }
    return text.substring(0, maxLength - 3) + "...";
  }
  /**
   * Clean HTML entities and escape sequences from text
   */
  static cleanText(text) {
    return text.replace(/\\n/g, "\n").replace(/\\"/g, '"').replace(/\\'/g, "'").replace(
      /\\u([0-9a-fA-F]{4})/g,
      (match, code) => String.fromCharCode(parseInt(code, 16))
    );
  }
};
/**
 * YouTube URL patterns for validation (ordered by frequency for performance)
 * Enhanced patterns to handle various YouTube URL formats
 */
ValidationUtils.URL_PATTERNS = [
  // Standard youtube.com/watch?v= format (most common)
  /(?:https?:\/\/)?(?:www\.)?youtube\.com\/watch\?v=([a-zA-Z0-9_-]{11})(?:&.*)?$/,
  // youtu.be short format (second most common)
  /(?:https?:\/\/)?(?:www\.)?youtu\.be\/([a-zA-Z0-9_-]{11})(?:\?.*)?$/,
  // youtube.com/embed format
  /(?:https?:\/\/)?(?:www\.)?youtube\.com\/embed\/([a-zA-Z0-9_-]{11})(?:\?.*)?$/,
  // youtube.com/v format
  /(?:https?:\/\/)?(?:www\.)?youtube\.com\/v\/([a-zA-Z0-9_-]{11})(?:\?.*)?$/,
  // Mobile youtube.com format
  /(?:https?:\/\/)?(?:m\.)?youtube\.com\/watch\?v=([a-zA-Z0-9_-]{11})(?:&.*)?$/
];
// Memoized regex for video ID validation (hot path optimization)
ValidationUtils.VIDEO_ID_REGEX = /^[a-zA-Z0-9_-]{11}$/;
ValidationUtils.URL_CACHE = /* @__PURE__ */ new Map();

// src/services/error-handler.ts
var import_obsidian = require("obsidian");
var ErrorHandler = class _ErrorHandler {
  /**
   * Handle errors with consistent logging and user feedback
   */
  static handle(error, context, showNotice = true) {
    const errorMessage = `${context}: ${error.message}`;
    console.error(errorMessage, error);
    if (showNotice) {
      new import_obsidian.Notice(`Error: ${error.message}`);
    }
  }
  /**
   * Execute an operation with automatic error handling
   */
  static async withErrorHandling(operation, context, showNotice = true) {
    try {
      return await operation();
    } catch (error) {
      this.handle(error, context, showNotice);
      return null;
    }
  }
  /**
   * Execute a synchronous operation with error handling
   */
  static withSyncErrorHandling(operation, context, showNotice = true) {
    try {
      return operation();
    } catch (error) {
      this.handle(error, context, showNotice);
      return null;
    }
  }
  /**
   * Create a standardized error for API responses
   */
  static createAPIError(provider, status, statusText, details) {
    const message = `${provider} API error: ${status} ${statusText}${details ? `. ${details}` : ""}`;
    return new Error(message);
  }
  /**
   * Handle API response errors with consistent format
   */
  static async handleAPIError(response, provider, fallbackMessage) {
    var _a;
    let errorDetails = fallbackMessage || "";
    try {
      const errorData = await response.json();
      errorDetails = ((_a = errorData.error) == null ? void 0 : _a.message) || errorData.message || fallbackMessage || "";
    } catch (e) {
    }
    throw this.createAPIError(provider, response.status, response.statusText, errorDetails);
  }
  /**
   * Validate required configuration and throw descriptive errors
   */
  static validateConfiguration(config, requiredFields) {
    const missing = requiredFields.filter((field) => !config[field]);
    if (missing.length > 0) {
      throw new Error(`Missing required configuration: ${missing.join(", ")}`);
    }
  }
  /**
   * Create a user-friendly error message for common scenarios
   */
  static createUserFriendlyError(error, operation) {
    const message = `Failed to ${operation}: ${error.message}`;
    return new Error(message);
  }
  /**
   * Handle API quota and billing errors with specific user guidance
   */
  static handleQuotaError(error, provider) {
    const errorMessage = error.message.toLowerCase();
    let userMessage = "";
    let showRetryAction = false;
    if (errorMessage.includes("quota") || errorMessage.includes("limit") || errorMessage.includes("exceeded")) {
      if (errorMessage.includes("rate") || errorMessage.includes("too many requests")) {
        userMessage = MESSAGES.ERRORS.RATE_LIMITED(provider);
        showRetryAction = true;
      } else if (errorMessage.includes("billing") || errorMessage.includes("payment")) {
        userMessage = MESSAGES.ERRORS.BILLING_REQUIRED(provider);
      } else if (errorMessage.includes("credit") || errorMessage.includes("balance")) {
        userMessage = MESSAGES.ERRORS.CREDIT_EXHAUSTED(provider);
      } else {
        userMessage = MESSAGES.ERRORS.QUOTA_EXCEEDED(provider);
        showRetryAction = true;
      }
    } else {
      userMessage = MESSAGES.ERRORS.QUOTA_EXCEEDED(provider);
    }
    console.error(`Quota Error [${provider}]: ${error.message}`, error);
    if (showRetryAction) {
      const noticeWithAction = new import_obsidian.Notice(userMessage, 0);
      setTimeout(() => {
        const noticeEl = noticeWithAction.noticeEl;
        const retryButton = noticeEl.createEl("button", {
          text: "Retry",
          cls: "mod-cta"
        });
        retryButton.style.marginLeft = "10px";
        retryButton.onclick = () => {
          noticeWithAction.hide();
          window.dispatchEvent(new CustomEvent("yt-clipper-retry-processing"));
        };
      }, 100);
    } else {
      new import_obsidian.Notice(userMessage, 8e3);
    }
  }
  /**
   * Detect if an error is quota/billing related
   */
  static isQuotaError(error) {
    const errorMessage = error.message.toLowerCase();
    const quotaKeywords = [
      "quota",
      "limit",
      "exceeded",
      "rate",
      "billing",
      "payment",
      "credit",
      "balance",
      "insufficient",
      "429",
      "usage"
    ];
    return quotaKeywords.some((keyword) => errorMessage.includes(keyword));
  }
  /**
   * Get provider name from error or use default
   */
  static extractProviderName(error, defaultProvider = "AI Service") {
    const errorMessage = error.message.toLowerCase();
    if (errorMessage.includes("gemini") || errorMessage.includes("google")) {
      return "Google Gemini";
    } else if (errorMessage.includes("groq")) {
      return "Groq";
    } else if (errorMessage.includes("openai")) {
      return "OpenAI";
    }
    return defaultProvider;
  }
  /**
   * Enhanced error handling with quota detection
   */
  static handleEnhanced(error, context, showNotice = true) {
    if (this.isQuotaError(error)) {
      const provider = this.extractProviderName(error);
      this.handleQuotaError(error, provider);
      return;
    }
    this.handle(error, context, showNotice);
  }
  // Instance methods implementing interface
  handle(error, context, showNotice = true) {
    _ErrorHandler.handle(error, context, showNotice);
  }
  async withErrorHandling(operation, context) {
    return _ErrorHandler.withErrorHandling(operation, context);
  }
};

// src/services/logger.ts
var LogLevel = /* @__PURE__ */ ((LogLevel2) => {
  LogLevel2[LogLevel2["DEBUG"] = 0] = "DEBUG";
  LogLevel2[LogLevel2["INFO"] = 1] = "INFO";
  LogLevel2[LogLevel2["WARN"] = 2] = "WARN";
  LogLevel2[LogLevel2["ERROR"] = 3] = "ERROR";
  LogLevel2[LogLevel2["SILENT"] = 4] = "SILENT";
  return LogLevel2;
})(LogLevel || {});
var Logger = class _Logger {
  constructor(config = {}) {
    this.logs = [];
    this.config = {
      level: 1 /* INFO */,
      enableConsole: true,
      enableFile: false,
      maxLogEntries: 1e3,
      enableTimestamps: true,
      ...config
    };
  }
  static getInstance(config) {
    if (!_Logger.instance) {
      _Logger.instance = new _Logger(config);
    }
    return _Logger.instance;
  }
  shouldLog(level) {
    return level >= this.config.level;
  }
  formatMessage(entry) {
    const levelStr = LogLevel[entry.level].padEnd(5);
    const timestamp = this.config.enableTimestamps ? `[${entry.timestamp.toISOString()}] ` : "";
    const context = entry.context ? ` [${entry.context}]` : "";
    const data = entry.data ? ` ${JSON.stringify(entry.data)}` : "";
    return `${timestamp}${levelStr}${context} ${entry.message}${data}`;
  }
  addLogEntry(level, message, context, data) {
    if (!this.shouldLog(level))
      return;
    const entry = {
      timestamp: /* @__PURE__ */ new Date(),
      level,
      message,
      context,
      data
    };
    this.logs.push(entry);
    if (this.logs.length > this.config.maxLogEntries) {
      this.logs = this.logs.slice(-this.config.maxLogEntries);
    }
    if (this.config.enableConsole) {
      const formattedMessage = this.formatMessage(entry);
      switch (level) {
        case 0 /* DEBUG */:
          console.debug(formattedMessage);
          break;
        case 1 /* INFO */:
          console.info(formattedMessage);
          break;
        case 2 /* WARN */:
          console.warn(formattedMessage);
          break;
        case 3 /* ERROR */:
          console.error(formattedMessage);
          break;
      }
    }
  }
  debug(message, context, data) {
    this.addLogEntry(0 /* DEBUG */, message, context, data);
  }
  info(message, context, data) {
    this.addLogEntry(1 /* INFO */, message, context, data);
  }
  warn(message, context, data) {
    this.addLogEntry(2 /* WARN */, message, context, data);
  }
  error(message, context, data) {
    this.addLogEntry(3 /* ERROR */, message, context, data);
  }
  getLogs(level, context) {
    let filteredLogs = this.logs;
    if (level !== void 0) {
      filteredLogs = filteredLogs.filter((log) => log.level === level);
    }
    if (context) {
      filteredLogs = filteredLogs.filter((log) => log.context === context);
    }
    return filteredLogs;
  }
  clearLogs() {
    this.logs = [];
  }
  setLevel(level) {
    this.config.level = level;
  }
  getConfig() {
    return { ...this.config };
  }
  updateConfig(config) {
    this.config = { ...this.config, ...config };
  }
  // Convenience methods for common contexts
  plugin(message, data) {
    this.info(message, "Plugin", data);
  }
  aiService(message, data) {
    this.info(message, "AIService", data);
  }
  videoService(message, data) {
    this.info(message, "VideoService", data);
  }
  fileService(message, data) {
    this.info(message, "FileService", data);
  }
  modal(message, data) {
    this.info(message, "Modal", data);
  }
  performance(message, data) {
    this.debug(message, "Performance", data);
  }
};
var logger = Logger.getInstance();

// src/services/url-handler.ts
var import_obsidian2 = require("obsidian");
var UrlHandler = class {
  constructor(app, settings, onUrlDetected, config = {
    noteMarker: "<!-- ytc-extension:youtube-clipper -->",
    urlHandlerDelay: 500,
    maxHandledFiles: 100,
    tempFileAgeThreshold: 5e3
  }) {
    this.app = app;
    this.settings = settings;
    this.onUrlDetected = onUrlDetected;
    this.config = config;
    this.handledTempFiles = /* @__PURE__ */ new Set();
    this.pendingUrls = /* @__PURE__ */ new Map();
  }
  /**
   * Check if a file is a temporary YouTube clipper file
   */
  isTempFile(file, content) {
    try {
      if (content && content.includes(this.config.noteMarker)) {
        logger.debug("File identified as temp file via marker", "UrlHandler", {
          filePath: file.path,
          hasMarker: true
        });
        return true;
      }
      if (file.name && file.name.startsWith("YouTube Clip -")) {
        logger.debug("File identified as temp file via name", "UrlHandler", {
          filePath: file.path,
          fileName: file.name
        });
        return true;
      }
      const trimmedContent = content.trim();
      const lines = trimmedContent.split("\n").filter((line) => line.trim().length > 0);
      const isUrlOnly = lines.length === 1 && ValidationUtils.isValidYouTubeUrl(lines[0]);
      if (isUrlOnly && content.length < 200) {
        const fileAge = Date.now() - file.stat.ctime;
        const isInOutputPath = file.path.includes(this.settings.outputPath);
        if (fileAge < this.config.tempFileAgeThreshold && !isInOutputPath) {
          logger.debug("File identified as temp file via content analysis", "UrlHandler", {
            filePath: file.path,
            fileAge,
            isInOutputPath,
            contentLength: content.length
          });
          return true;
        }
      }
      return false;
    } catch (error) {
      logger.error("Error checking if file is temp file", "UrlHandler", {
        filePath: file.path,
        error: error instanceof Error ? error.message : String(error)
      });
      return false;
    }
  }
  /**
   * Extract YouTube URL from file content
   */
  extractUrl(content) {
    try {
      if (content && content.includes(this.config.noteMarker)) {
        const url = content.replace(this.config.noteMarker, "").trim();
        return ValidationUtils.isValidYouTubeUrl(url) ? url : null;
      }
      const trimmed = content.trim();
      const ytRegex = /(https?:\/\/(?:www\.)?youtube\.com\/watch\?v=[A-Za-z0-9_-]{6,}|https?:\/\/(?:www\.)?youtu\.be\/[A-Za-z0-9_-]{6,})/i;
      const match = trimmed.match(ytRegex);
      if (match && match[1]) {
        const url = match[1].trim();
        return ValidationUtils.isValidYouTubeUrl(url) ? url : null;
      }
      return null;
    } catch (error) {
      logger.error("Error extracting URL from content", "UrlHandler", {
        error: error instanceof Error ? error.message : String(error),
        contentLength: content.length
      });
      return null;
    }
  }
  /**
   * Safely handle detected URL with deduplication and debouncing
   */
  handleUrlSafely(result) {
    logger.info("URL detected, processing safely", "UrlHandler", {
      url: result.url,
      source: result.source,
      filePath: result.filePath
    });
    if (result.file && result.content && !this.isTempFile(result.file, result.content)) {
      logger.warn("URL rejected - not in temp file", "UrlHandler", {
        url: result.url,
        filePath: result.filePath
      });
      return;
    }
    if (this.handledTempFiles.has(result.url)) {
      logger.debug("URL already handled, skipping", "UrlHandler", { url: result.url });
      return;
    }
    if (this.pendingUrls.has(result.url)) {
      logger.debug("Cancelling pending handler for URL", "UrlHandler", { url: result.url });
      clearTimeout(this.pendingUrls.get(result.url));
    }
    this.handledTempFiles.add(result.url);
    if (result.filePath) {
      this.handledTempFiles.add(result.filePath);
    }
    const timeout = setTimeout(() => {
      logger.info("Processing URL after debounce", "UrlHandler", { url: result.url });
      this.onUrlDetected(result);
      this.pendingUrls.delete(result.url);
      this.cleanupHandledFiles();
    }, this.config.urlHandlerDelay);
    this.pendingUrls.set(result.url, timeout);
  }
  /**
   * Clean up old handled file entries to prevent memory leaks
   */
  cleanupHandledFiles() {
    if (this.handledTempFiles.size > this.config.maxHandledFiles) {
      const entries = Array.from(this.handledTempFiles);
      this.handledTempFiles.clear();
      entries.slice(-Math.floor(this.config.maxHandledFiles / 2)).forEach((entry) => {
        this.handledTempFiles.add(entry);
      });
      logger.debug("Cleaned up handled temp files", "UrlHandler", {
        oldSize: entries.length,
        newSize: this.handledTempFiles.size
      });
    }
  }
  /**
   * Handle file creation event
   */
  async handleFileCreate(file) {
    try {
      if (!(file instanceof import_obsidian2.TFile))
        return;
      const content = await this.app.vault.read(file);
      if (!this.isTempFile(file, content)) {
        logger.debug("Ignoring non-temp file in create handler", "UrlHandler", {
          filePath: file.path
        });
        return;
      }
      const url = this.extractUrl(content);
      if (!url) {
        logger.debug("No URL extracted from temp file", "UrlHandler", {
          filePath: file.path
        });
        return;
      }
      const result = {
        url,
        source: "create",
        filePath: file.path,
        file,
        content
      };
      logger.info("CREATE EVENT - detected temp note", "UrlHandler", result);
      this.handleUrlSafely(result);
    } catch (error) {
      logger.error("Error handling file create", "UrlHandler", {
        filePath: file.path,
        error: error instanceof Error ? error.message : String(error)
      });
    }
  }
  /**
   * Handle active leaf change event
   */
  async handleActiveLeafChange() {
    try {
      const file = this.app.workspace.getActiveFile();
      if (!file)
        return;
      if (!("stat" in file) || !("basename" in file) || !("extension" in file)) {
        return;
      }
      if (this.handledTempFiles.has(file.path))
        return;
      const content = await this.app.vault.read(file);
      if (!this.isTempFile(file, content)) {
        logger.debug("Ignoring non-temp file in active leaf handler", "UrlHandler", {
          filePath: file.path
        });
        return;
      }
      const url = this.extractUrl(content);
      if (!url) {
        logger.debug("No URL extracted from temp file in active leaf", "UrlHandler", {
          filePath: file.path
        });
        return;
      }
      const result = {
        url,
        source: "active-leaf",
        filePath: file.path,
        file,
        content
      };
      logger.info("ACTIVE-LEAF-CHANGE EVENT - detected temp note", "UrlHandler", result);
      this.handleUrlSafely(result);
    } catch (error) {
      logger.error("Error handling active leaf change", "UrlHandler", {
        error: error instanceof Error ? error.message : String(error)
      });
    }
  }
  /**
   * Handle protocol handler invocation
   */
  handleProtocol(params) {
    try {
      const url = params.url || params.content || params.path || "";
      if (url && ValidationUtils.isValidYouTubeUrl(url)) {
        const result = {
          url,
          source: "protocol"
        };
        logger.info("Protocol handler received valid URL", "UrlHandler", result);
        setTimeout(() => {
          this.onUrlDetected(result);
        }, 200);
      } else {
        logger.debug("Protocol handler received no valid URL", "UrlHandler", { params });
      }
    } catch (error) {
      logger.error("Error in protocol handler", "UrlHandler", {
        params,
        error: error instanceof Error ? error.message : String(error)
      });
    }
  }
  /**
   * Handle clipboard URL
   */
  async handleClipboardUrl() {
    try {
      let text = "";
      try {
        if (navigator && navigator.clipboard && navigator.clipboard.readText) {
          text = await navigator.clipboard.readText() || "";
        }
      } catch (error) {
        logger.debug("Could not read clipboard", "UrlHandler", {
          error: error instanceof Error ? error.message : String(error)
        });
        text = "";
      }
      if (text && ValidationUtils.isValidYouTubeUrl(text.trim())) {
        const result = {
          url: text.trim(),
          source: "clipboard"
        };
        logger.info("URL found in clipboard", "UrlHandler", result);
        this.onUrlDetected(result);
        return;
      }
      logger.debug("No valid YouTube URL in clipboard", "UrlHandler");
    } catch (error) {
      logger.error("Error handling clipboard URL", "UrlHandler", {
        error: error instanceof Error ? error.message : String(error)
      });
    }
  }
  /**
   * Clear all handled URLs and pending operations
   */
  clear() {
    this.pendingUrls.forEach((timeout) => clearTimeout(timeout));
    this.pendingUrls.clear();
    this.handledTempFiles.clear();
    logger.info("URL handler cleared", "UrlHandler");
  }
  /**
   * Update settings
   */
  updateSettings(settings) {
    this.settings = settings;
    logger.debug("URL handler settings updated", "UrlHandler");
  }
};

// src/services/modal-manager.ts
var ModalManager = class {
  constructor() {
    this.state = {
      isModalOpen: false
    };
  }
  /**
   * Check if a modal can be opened safely
   */
  canOpenModal(url) {
    if (this.state.isModalOpen) {
      if (url && url !== this.state.pendingModalUrl) {
        return {
          canOpen: false,
          reason: "Modal already open with different URL"
        };
      }
      return {
        canOpen: false,
        reason: "Modal already open with same URL"
      };
    }
    return { canOpen: true };
  }
  /**
   * Open a modal safely with deduplication
   */
  async openModal(url, openModalFn, onClose) {
    const callId = Math.random().toString(36).substring(2, 9);
    this.state.lastCallId = callId;
    logger.info(`Modal opening requested`, "ModalManager", {
      callId,
      url,
      currentState: { ...this.state }
    });
    const { canOpen, reason } = this.canOpenModal(url);
    if (!canOpen) {
      logger.warn(`Modal open rejected: ${reason}`, "ModalManager", {
        callId,
        url,
        reason,
        pendingUrl: this.state.pendingModalUrl
      });
      if (url && url !== this.state.pendingModalUrl) {
        logger.info(`Updating pending modal URL`, "ModalManager", {
          oldUrl: this.state.pendingModalUrl,
          newUrl: url
        });
        this.state.pendingModalUrl = url;
      }
      return null;
    }
    this.state.isModalOpen = true;
    this.state.pendingModalUrl = url;
    logger.info(`Modal state set to open`, "ModalManager", {
      callId,
      url
    });
    try {
      const enhancedOnClose = () => {
        try {
          logger.info(`Modal onClose triggered`, "ModalManager", {
            callId,
            url
          });
          this.resetModalState();
          if (onClose) {
            onClose();
          }
        } catch (error) {
          logger.error(`Error in modal onClose handler`, "ModalManager", {
            callId,
            error: error instanceof Error ? error.message : String(error)
          });
          this.resetModalState();
        }
      };
      logger.info(`About to open modal`, "ModalManager", {
        callId,
        url
      });
      const result = await openModalFn();
      const fallbackTimeout = setTimeout(() => {
        if (this.state.isModalOpen && this.state.pendingModalUrl === url) {
          logger.warn("Fallback modal state reset triggered", "ModalManager", {
            callId,
            url
          });
          this.resetModalState();
        }
      }, 1e4);
      if (result && typeof result === "object") {
        result._fallbackTimeout = fallbackTimeout;
      } else {
        logger.debug("Modal result is not an object, clearing fallback timeout", "ModalManager", {
          callId,
          url,
          resultType: typeof result
        });
        clearTimeout(fallbackTimeout);
      }
      setTimeout(() => {
        logger.debug(`Modal state after 100ms`, "ModalManager", {
          callId,
          isModalOpen: this.state.isModalOpen
        });
      }, 100);
      return result;
    } catch (error) {
      logger.error(`Error opening modal`, "ModalManager", {
        callId,
        url,
        error: error instanceof Error ? error.message : String(error)
      });
      this.resetModalState();
      throw error;
    }
  }
  /**
   * Reset modal state
   */
  resetModalState() {
    logger.debug(`Resetting modal state`, "ModalManager", {
      previousState: { ...this.state }
    });
    this.state.isModalOpen = false;
    this.state.pendingModalUrl = void 0;
  }
  /**
   * Force reset modal state (for cleanup)
   */
  forceResetModalState() {
    logger.warn(`Force resetting modal state`, "ModalManager", {
      previousState: { ...this.state }
    });
    this.state = {
      isModalOpen: false
    };
  }
  /**
   * Get current modal state
   */
  getState() {
    return { ...this.state };
  }
  /**
   * Check if modal is currently open
   */
  isModalOpen() {
    return this.state.isModalOpen;
  }
  /**
   * Get pending modal URL
   */
  getPendingModalUrl() {
    return this.state.pendingModalUrl;
  }
  /**
   * Clear all modal state (for plugin unload)
   */
  clear() {
    this.forceResetModalState();
    logger.info(`Modal manager cleared`, "ModalManager");
  }
};

// src/save-confirmation-modal.ts
var import_obsidian3 = require("obsidian");
var SaveConfirmationModal = class extends import_obsidian3.Modal {
  constructor(app, file, onConfirm) {
    super(app);
    this.file = file;
    this.onConfirm = onConfirm;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    try {
      contentEl.createEl("h2", { text: "Note created successfully. Open now?" });
      const buttonContainer = contentEl.createDiv("save-confirmation-buttons");
      new import_obsidian3.Setting(buttonContainer).addButton((btn) => btn.setButtonText("Open Note").setCta().onClick(() => {
        this.close();
        this.onConfirm(true);
      })).addButton((btn) => btn.setButtonText("Dismiss").onClick(() => {
        this.close();
        this.onConfirm(false);
      }));
      setTimeout(() => {
        const openButton = buttonContainer.querySelector("button");
        if (openButton) {
          openButton.focus();
        }
      }, 100);
    } catch (error) {
      console.error("[SaveConfirmationModal] Error in onOpen:", error);
      contentEl.createEl("h2", { text: "File Saved" });
      contentEl.createEl("p", { text: `File "${this.file.name}" has been saved successfully.` });
      contentEl.createEl("button", { text: "OK" }).onclick = () => this.close();
    }
  }
  /**
   * Get human-readable file size
   */
  getFileSize() {
    try {
      const stat = this.app.vault.adapter.stat(this.file.path);
      if (stat && typeof stat === "object" && "size" in stat) {
        const bytes = stat.size;
        if (bytes < 1024)
          return `${bytes} bytes`;
        if (bytes < 1024 * 1024)
          return `${(bytes / 1024).toFixed(1)} KB`;
        return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
      }
    } catch (error) {
    }
    return "";
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  /**
   * Add custom styles for the modal
   */
  addStyles() {
    var _a;
    const { contentEl } = this;
    contentEl.addClass("ytp-save-confirmation-modal");
    const style = document.createElement("style");
    style.textContent = `
            .ytp-save-confirmation-modal {
                min-width: 450px;
                max-width: 650px;
            }
            
            .save-confirmation-message {
                margin: 20px 0 30px 0;
                text-align: left;
                line-height: 1.6;
            }
            
            .save-confirmation-filename {
                font-weight: bold;
                font-size: 1.1em;
                margin-bottom: 15px;
                color: var(--text-accent);
                text-align: center;
            }
            
            .save-confirmation-location-container,
            .save-confirmation-size-container {
                margin-bottom: 10px;
                display: flex;
                align-items: center;
                gap: 8px;
            }
            
            .save-confirmation-location {
                font-family: var(--font-monospace);
                background: var(--background-secondary);
                padding: 4px 8px;
                border-radius: 4px;
                font-size: 0.9em;
                word-break: break-all;
                color: var(--text-muted);
                flex: 1;
            }
            
            .save-confirmation-size {
                font-family: var(--font-monospace);
                background: var(--background-modifier-success);
                padding: 4px 8px;
                border-radius: 4px;
                font-size: 0.9em;
                color: var(--text-on-accent);
            }
            
            .save-confirmation-buttons {
                text-align: center;
                margin-top: 20px;
                display: flex;
                justify-content: center;
                gap: 15px;
            }
            
            .save-confirmation-buttons .setting-item {
                border: none;
                padding: 0;
                margin: 0;
                display: flex;
                gap: 10px;
            }
            
            .save-confirmation-buttons button {
                min-width: 100px;
                padding: 8px 20px;
                font-size: 1em;
            }
            
            .save-confirmation-buttons button:first-child {
                /* Open File button - primary action */
                background-color: var(--interactive-accent);
                color: var(--text-on-accent);
            }
            
            .save-confirmation-buttons button:last-child {
                /* OK button - secondary action */
                background-color: var(--background-modifier-border);
                color: var(--text-normal);
            }
        `;
    document.head.appendChild(style);
    (_a = this.modalEl) == null ? void 0 : _a.setAttribute("data-style-id", "ytp-save-confirmation-style");
  }
};

// src/youtube-url-modal.ts
var import_obsidian5 = require("obsidian");
init_base_modal();

// src/services/user-preferences-service.ts
var UserPreferencesService = class {
  /**
   * Load user preferences from storage
   */
  static loadPreferences() {
    try {
      const stored = localStorage.getItem(this.STORAGE_KEY);
      if (stored) {
        const parsed = JSON.parse(stored);
        return { ...this.DEFAULT_PREFERENCES, ...parsed };
      }
    } catch (error) {
      console.warn("Failed to load user preferences:", error);
    }
    return { ...this.DEFAULT_PREFERENCES };
  }
  /**
   * Save user preferences to storage
   */
  static savePreferences(preferences) {
    try {
      localStorage.setItem(this.STORAGE_KEY, JSON.stringify(preferences));
    } catch (error) {
      console.warn("Failed to save user preferences:", error);
    }
  }
  /**
   * Get a specific preference value
   */
  static getPreference(key) {
    const preferences = this.loadPreferences();
    return preferences[key];
  }
  /**
   * Set a specific preference value
   */
  static setPreference(key, value) {
    const preferences = this.loadPreferences();
    preferences[key] = value;
    this.savePreferences(preferences);
  }
  /**
   * Update last used settings
   */
  static updateLastUsed(settings) {
    const preferences = this.loadPreferences();
    if (settings.format) {
      preferences.lastFormat = settings.format;
      preferences.formatUsage[settings.format] = (preferences.formatUsage[settings.format] || 0) + 1;
    }
    if (settings.provider) {
      preferences.lastProvider = settings.provider;
      preferences.providerUsage[settings.provider] = (preferences.providerUsage[settings.provider] || 0) + 1;
    }
    if (settings.model)
      preferences.lastModel = settings.model;
    if (settings.maxTokens)
      preferences.lastMaxTokens = settings.maxTokens;
    if (settings.temperature)
      preferences.lastTemperature = settings.temperature;
    if (settings.performanceMode)
      preferences.lastPerformanceMode = settings.performanceMode;
    if (settings.parallelProcessing !== void 0)
      preferences.lastParallelProcessing = settings.parallelProcessing;
    if (settings.multimodal !== void 0)
      preferences.lastMultimodal = settings.multimodal;
    preferences.lastUsed = (/* @__PURE__ */ new Date()).toISOString();
    preferences.totalProcessed = (preferences.totalProcessed || 0) + 1;
    this.savePreferences(preferences);
  }
  /**
   * Get smart default format based on usage patterns
   */
  static getSmartDefaultFormat() {
    const preferences = this.loadPreferences();
    if (preferences.preferredFormat) {
      return preferences.preferredFormat;
    }
    const formatUsage = preferences.formatUsage || {};
    let maxUsage = 0;
    let mostUsedFormat = "executive-summary";
    for (const [format, count] of Object.entries(formatUsage)) {
      if (count > maxUsage) {
        maxUsage = count;
        mostUsedFormat = format;
      }
    }
    return mostUsedFormat;
  }
  /**
   * Get smart default provider based on usage patterns
   */
  static getSmartDefaultProvider() {
    const preferences = this.loadPreferences();
    if (preferences.preferredProvider) {
      return preferences.preferredProvider;
    }
    const providerUsage = preferences.providerUsage || {};
    let maxUsage = 0;
    let mostUsedProvider;
    for (const [provider, count] of Object.entries(providerUsage)) {
      if (count > maxUsage) {
        maxUsage = count;
        mostUsedProvider = provider;
      }
    }
    return mostUsedProvider;
  }
  /**
   * Get smart defaults for model parameters based on user history
   */
  static getSmartDefaultModelParameters() {
    const preferences = this.loadPreferences();
    return {
      maxTokens: preferences.lastMaxTokens || 4096,
      temperature: preferences.lastTemperature || 0.5
    };
  }
  /**
   * Get smart default performance settings
   */
  static getSmartDefaultPerformanceSettings() {
    const preferences = this.loadPreferences();
    return {
      mode: preferences.lastPerformanceMode || "balanced",
      parallel: preferences.lastParallelProcessing || false,
      multimodal: preferences.lastMultimodal || true
    };
  }
  /**
   * Analyze user behavior and suggest optimizations
   */
  static getUserInsights() {
    const preferences = this.loadPreferences();
    const formatUsage = preferences.formatUsage || {};
    const providerUsage = preferences.providerUsage || {};
    let favoriteFormat = "executive-summary";
    let maxFormatUsage = 0;
    for (const [format, count] of Object.entries(formatUsage)) {
      if (count > maxFormatUsage) {
        maxFormatUsage = count;
        favoriteFormat = format;
      }
    }
    let favoriteProvider = "";
    let maxProviderUsage = 0;
    for (const [provider, count] of Object.entries(providerUsage)) {
      if (count > maxProviderUsage) {
        maxProviderUsage = count;
        favoriteProvider = provider;
      }
    }
    const totalProcessed = preferences.totalProcessed || 0;
    const usageLevel = totalProcessed < 5 ? "light" : totalProcessed < 20 ? "moderate" : "heavy";
    const recommendations = [];
    if (usageLevel === "heavy" && !preferences.showAdvancedSettings) {
      recommendations.push("Consider enabling advanced settings for more control");
    }
    if (!preferences.autoSelectProvider && Object.keys(providerUsage).length > 1) {
      recommendations.push("Enable auto-select provider to speed up your workflow");
    }
    if (!preferences.showPreview && totalProcessed > 10) {
      recommendations.push("Enable video preview for better context");
    }
    return {
      favoriteFormat,
      favoriteProvider,
      averageTokens: preferences.lastMaxTokens || 4096,
      averageTemperature: preferences.lastTemperature || 0.5,
      usageLevel,
      recommendations
    };
  }
  /**
   * Reset preferences to defaults
   */
  static resetPreferences() {
    localStorage.removeItem(this.STORAGE_KEY);
  }
  /**
   * Export preferences for backup
   */
  static exportPreferences() {
    const preferences = this.loadPreferences();
    return JSON.stringify(preferences, null, 2);
  }
  /**
   * Import preferences from backup
   */
  static importPreferences(jsonData) {
    try {
      const preferences = JSON.parse(jsonData);
      this.savePreferences({ ...this.DEFAULT_PREFERENCES, ...preferences });
      return true;
    } catch (error) {
      console.error("Failed to import preferences:", error);
      return false;
    }
  }
};
UserPreferencesService.STORAGE_KEY = "yt-clipper-user-preferences";
UserPreferencesService.DEFAULT_PREFERENCES = {
  autoSelectProvider: true,
  showPreview: true,
  enableKeyboardShortcuts: true,
  enableAnimations: true,
  autoFocusUrl: true,
  showAdvancedSettings: false,
  compactMode: false,
  formatUsage: {
    brief: 0,
    "executive-summary": 0,
    "detailed-guide": 0,
    custom: 0
  },
  providerUsage: {}
};

// src/youtube-url-modal.ts
var YouTubeUrlModal = class extends BaseModal {
  constructor(app, options) {
    super(app);
    this.options = options;
    this.url = "";
    this.format = "executive-summary";
    this.fetchInProgress = false;
    this.progressSteps = [];
    this.currentStepIndex = 0;
    this.isProcessing = false;
    // Theme state
    this.isLightTheme = false;
    this.url = options.initialUrl || "";
    const savedTheme = localStorage.getItem("ytc-theme-mode");
    this.isLightTheme = savedTheme === "light";
    const smartDefaults = UserPreferencesService.getSmartDefaultPerformanceSettings();
    const smartModelParams = UserPreferencesService.getSmartDefaultModelParameters();
    this.selectedProvider = "Google Gemini";
    this.selectedModel = "gemini-2.5-pro";
    UserPreferencesService.updateLastUsed({
      format: "detailed-guide",
      provider: this.selectedProvider,
      model: this.selectedModel,
      maxTokens: options.defaultMaxTokens || 4096,
      temperature: options.defaultTemperature || 0.5,
      performanceMode: smartDefaults.mode,
      parallelProcessing: smartDefaults.parallel,
      multimodal: smartDefaults.multimodal
    });
  }
  onOpen() {
    this.createModalContent();
    this.setupEventHandlers();
    this.setupKeyboardShortcuts();
    if (this.options.initialUrl) {
      this.setUrl(this.options.initialUrl);
      this.updateProcessButtonState();
      const isValid = ValidationUtils.isValidYouTubeUrl((this.options.initialUrl || "").trim());
      if (isValid && this.processButton) {
        this.processButton.focus();
        return;
      }
    }
    this.focusUrlInput();
  }
  /**
   * Create streamlined modal content with compact UI
   */
  createModalContent() {
    this.headerEl = this.createHeader(MESSAGES.MODALS.PROCESS_VIDEO);
    this.createThemeToggle();
    this.createCompactUrlSection();
    this.createDropDownRow();
    this.createProgressSection();
    this.createActionButtons();
  }
  /**
   * Create compact URL section with paste button
   */
  createCompactUrlSection() {
    const urlContainer = this.contentEl.createDiv();
    urlContainer.style.cssText = `
            margin: 16px 0;
            position: relative;
        `;
    const inputWrapper = urlContainer.createDiv();
    inputWrapper.style.cssText = `
            position: relative;
            display: flex;
            align-items: center;
            gap: 8px;
        `;
    this.urlInput = inputWrapper.createEl("input");
    this.urlInput.type = "url";
    this.urlInput.placeholder = "Paste YouTube URL here...";
    this.urlInput.style.cssText = `
            flex: 1;
            padding: 12px;
            border: 1px solid var(--background-modifier-border);
            border-radius: 6px;
            font-size: 0.9rem;
            background: var(--background-primary);
            color: var(--text-normal);
            transition: all 0.2s ease;
            outline: none;
        `;
    this.pasteButton = inputWrapper.createEl("button");
    this.pasteButton.innerHTML = "\u{1F4CB}";
    this.pasteButton.style.cssText = `
            padding: 8px 12px;
            background: var(--interactive-accent);
            border: 1px solid var(--background-modifier-border);
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s ease;
            color: white;
        `;
    this.pasteButton.addEventListener("click", () => this.handleSmartPaste());
    this.pasteButton.addEventListener("mouseenter", () => {
      this.pasteButton.style.background = "var(--interactive-accent-hover)";
    });
    this.pasteButton.addEventListener("mouseleave", () => {
      this.pasteButton.style.background = "var(--interactive-accent)";
    });
    this.urlInput.addEventListener("focus", () => {
      this.urlInput.style.borderColor = "var(--interactive-accent)";
      this.urlInput.style.boxShadow = "0 0 0 2px rgba(99, 102, 241, 0.2)";
    });
    this.urlInput.addEventListener("blur", () => {
      this.urlInput.style.borderColor = "var(--background-modifier-border)";
      this.urlInput.style.boxShadow = "none";
    });
    this.validationMessage = urlContainer.createDiv();
    this.validationMessage.style.cssText = `
            margin-top: 6px;
            padding: 6px;
            font-size: 0.8rem;
            color: var(--text-muted);
            border-radius: 4px;
        `;
  }
  /**
   * Create three dropdowns in a single row: Format, Provider, Model
   */
  createDropDownRow() {
    const dropdownContainer = this.contentEl.createDiv();
    dropdownContainer.style.cssText = `
            display: flex;
            gap: 10px;
            margin: 12px 0;
        `;
    const formatContainer = dropdownContainer.createDiv();
    formatContainer.style.cssText = `
            flex: 1;
        `;
    const formatLabel = formatContainer.createDiv();
    formatLabel.textContent = "Format";
    formatLabel.style.cssText = `
            font-weight: 500;
            margin-bottom: 6px;
            color: var(--text-normal);
            font-size: 0.9rem;
        `;
    this.formatSelect = formatContainer.createEl("select");
    this.formatSelect.style.cssText = `
            width: 100%;
            padding: 10px 14px;
            border: 1px solid var(--background-modifier-border);
            border-radius: 6px;
            font-size: 0.9rem;
            background: var(--background-primary);
            color: var(--text-normal);
            cursor: pointer;
            outline: none;
            transition: all 0.2s ease;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            min-height: 40px;
        `;
    const formatOptions = [
      { value: "executive-summary", text: "1. Executive" },
      { value: "detailed-guide", text: "2. Comprehensive" },
      { value: "brief", text: "3. Brief" },
      { value: "custom", text: "4. Custom" }
    ];
    formatOptions.forEach((option) => {
      const optionEl = this.formatSelect.createEl("option");
      optionEl.value = option.value;
      optionEl.textContent = option.text;
    });
    this.formatSelect.value = "executive-summary";
    this.formatSelect.addEventListener("change", () => {
      this.format = this.formatSelect.value;
    });
    const providerContainer = dropdownContainer.createDiv();
    providerContainer.style.cssText = `
            flex: 1;
        `;
    const providerLabel = providerContainer.createDiv();
    providerLabel.textContent = "Provider";
    providerLabel.style.cssText = `
            font-weight: 500;
            margin-bottom: 6px;
            color: var(--text-normal);
            font-size: 0.9rem;
        `;
    this.providerSelect = providerContainer.createEl("select");
    this.providerSelect.style.cssText = `
            width: 100%;
            padding: 10px 14px;
            border: 1px solid var(--background-modifier-border);
            border-radius: 6px;
            font-size: 0.9rem;
            background: var(--background-primary);
            color: var(--text-normal);
            cursor: pointer;
            outline: none;
            transition: all 0.2s ease;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            min-height: 40px;
        `;
    const providerOptions = [
      { value: "Google Gemini", text: "Google" },
      { value: "Groq", text: "Groq" },
      { value: "Ollama", text: "Ollama" }
    ];
    providerOptions.forEach((option) => {
      const optionEl = this.providerSelect.createEl("option");
      optionEl.value = option.value;
      optionEl.textContent = option.text;
    });
    this.providerSelect.value = "Google Gemini";
    this.providerSelect.addEventListener("change", () => {
      this.selectedProvider = this.providerSelect.value;
      if (this.options.modelOptions) {
        this.updateModelDropdown(this.options.modelOptions);
      }
    });
    const modelContainer = dropdownContainer.createDiv();
    modelContainer.style.cssText = `
            flex: 1;
            position: relative;
        `;
    const modelLabelRow = modelContainer.createDiv();
    modelLabelRow.style.cssText = `
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        `;
    const modelLabel = modelLabelRow.createDiv();
    modelLabel.textContent = "Model";
    modelLabel.style.cssText = `
            font-weight: 500;
            color: var(--text-normal);
            font-size: 0.9rem;
        `;
    const refreshBtn = modelLabelRow.createEl("button");
    refreshBtn.innerHTML = "\u{1F504}";
    refreshBtn.style.cssText = `
            background: none;
            border: none;
            cursor: pointer;
            font-size: 0.9rem;
            padding: 2px 4px;
            border-radius: 4px;
            opacity: 0.7;
            transition: opacity 0.2s, background 0.2s;
        `;
    refreshBtn.addEventListener("mouseenter", () => {
      refreshBtn.style.opacity = "1";
      refreshBtn.style.background = "var(--background-modifier-hover)";
    });
    refreshBtn.addEventListener("mouseleave", () => {
      refreshBtn.style.opacity = "0.7";
      refreshBtn.style.background = "none";
    });
    refreshBtn.addEventListener("click", async () => {
      refreshBtn.innerHTML = "\u23F3";
      refreshBtn.style.opacity = "0.5";
      refreshBtn.style.cursor = "wait";
      try {
        if (this.options.fetchModels) {
          const modelOptionsMap = await this.options.fetchModels();
          this.updateModelDropdown(modelOptionsMap);
          new import_obsidian5.Notice("Model list updated!");
        }
      } catch (error) {
        console.error("Error refreshing models:", error);
        new import_obsidian5.Notice("Failed to refresh models. Using cached options.");
      } finally {
        refreshBtn.innerHTML = "\u{1F504}";
        refreshBtn.style.opacity = "0.7";
        refreshBtn.style.cursor = "pointer";
      }
    });
    this.modelSelect = modelContainer.createEl("select");
    this.modelSelect.style.cssText = `
            width: 100%;
            padding: 10px 14px;
            border: 1px solid var(--background-modifier-border);
            border-radius: 6px;
            font-size: 0.9rem;
            background: var(--background-primary);
            color: var(--text-normal);
            cursor: pointer;
            outline: none;
            transition: all 0.2s ease;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            min-height: 40px;
        `;
    const modelOptions = [
      { value: "gemini-2.5-pro", text: "Gemini Pro 2.5" },
      { value: "gemini-2.5-flash", text: "Gemini Flash 2.5" },
      { value: "gemini-1.5-pro", text: "Gemini Pro 1.5" },
      { value: "gemini-1.5-flash", text: "Gemini Flash 1.5" },
      { value: "qwen3-coder:480b-cloud", text: "Qwen3-Coder 480B Cloud" },
      { value: "llama3.2", text: "Llama 3.2" },
      { value: "llama3.1", text: "Llama 3.1" },
      { value: "mistral", text: "Mistral" },
      { value: "gemma2", text: "Gemma 2" },
      { value: "phi3", text: "Phi 3" }
    ];
    modelOptions.forEach((option) => {
      const optionEl = this.modelSelect.createEl("option");
      optionEl.value = option.value;
      optionEl.textContent = option.text;
    });
    this.modelSelect.value = "gemini-2.5-pro";
    this.modelSelect.addEventListener("change", () => {
      this.selectedModel = this.modelSelect.value;
    });
  }
  /**
   * Update the model dropdown options based on provider selection and fetched data
   */
  updateModelDropdown(modelOptionsMap) {
    if (!this.modelSelect || !this.providerSelect)
      return;
    this.modelSelect.innerHTML = "";
    const currentProvider = this.providerSelect.value;
    let models = [];
    if (modelOptionsMap && modelOptionsMap[currentProvider]) {
      models = modelOptionsMap[currentProvider];
    } else {
      switch (currentProvider) {
        case "Google Gemini":
          models = ["gemini-2.5-pro", "gemini-2.5-flash", "gemini-1.5-pro", "gemini-1.5-flash"];
          break;
        case "Groq":
          models = ["llama-4-maverick-17b-128e-instruct", "llama-4-scout-17b-16e-instruct", "llama-3.3-70b-versatile", "llama-3.1-8b-instant"];
          break;
        case "Ollama":
          models = ["qwen3-coder:480b-cloud", "llama3.2", "llama3.1", "mistral", "mixtral", "gemma2", "phi3", "qwen2", "command-r"];
          break;
        default:
          models = [];
      }
    }
    models.forEach((model) => {
      const option = this.modelSelect.createEl("option");
      option.value = model;
      option.textContent = this.formatModelName(model);
    });
    if (this.selectedModel && models.includes(this.selectedModel)) {
      this.modelSelect.value = this.selectedModel;
    } else if (models.length > 0) {
      this.modelSelect.value = models[0];
      this.selectedModel = models[0];
    }
  }
  /**
   * Format model names to be more user-friendly
   */
  formatModelName(modelName) {
    if (modelName === "gemini-2.5-pro")
      return "Gemini Pro 2.5";
    if (modelName === "gemini-2.5-flash")
      return "Gemini Flash 2.5";
    if (modelName === "gemini-1.5-pro")
      return "Gemini Pro 1.5";
    if (modelName === "gemini-1.5-flash")
      return "Gemini Flash 1.5";
    if (modelName === "qwen3-coder:480b-cloud")
      return "Qwen3-Coder 480B Cloud";
    if (modelName === "llama-4-maverick-17b-128e-instruct")
      return "Llama 4 Maverick 17B";
    if (modelName === "llama-4-scout-17b-16e-instruct")
      return "Llama 4 Scout 17B";
    if (modelName === "llama-3.3-70b-versatile")
      return "Llama 3.3 70B";
    if (modelName === "llama-3.1-8b-instant")
      return "Llama 3.1 8B";
    return modelName.charAt(0).toUpperCase() + modelName.slice(1).replace(/[-_]/g, " ");
  }
  /**
   * Create theme toggle component (light/dark mode)
   */
  createThemeToggle() {
    const themeContainer = this.contentEl.createDiv();
    themeContainer.style.cssText = `
            display: flex;
            justify-content: flex-end;
            margin: 8px 0 16px 0;
            padding: 0 4px;
        `;
    const toggleWrapper = themeContainer.createDiv();
    toggleWrapper.style.cssText = `
            display: flex;
            align-items: center;
            gap: 12px;
            background: var(--background-secondary);
            padding: 6px 12px;
            border-radius: 20px;
            border: 1px solid var(--background-modifier-border);
            transition: all 0.3s ease;
        `;
    toggleWrapper.addEventListener("mouseenter", () => {
      toggleWrapper.style.borderColor = "var(--interactive-accent)";
      toggleWrapper.style.boxShadow = "0 2px 8px rgba(99, 102, 241, 0.2)";
    });
    toggleWrapper.addEventListener("mouseleave", () => {
      toggleWrapper.style.borderColor = "var(--background-modifier-border)";
      toggleWrapper.style.boxShadow = "none";
    });
    const sunIcon = toggleWrapper.createSpan();
    sunIcon.innerHTML = "\u2600\uFE0F";
    sunIcon.style.cssText = `
            font-size: 1.1rem;
            transition: all 0.3s ease;
            opacity: ${this.isLightTheme ? "1" : "0.5"};
        `;
    const themeSwitch = toggleWrapper.createEl("input");
    themeSwitch.type = "checkbox";
    themeSwitch.checked = this.isLightTheme;
    themeSwitch.style.cssText = `
            opacity: 0;
            width: 0;
            height: 0;
            position: absolute;
        `;
    const slider = toggleWrapper.createDiv();
    slider.style.cssText = `
            position: relative;
            width: 44px;
            height: 24px;
            background: ${this.isLightTheme ? "var(--interactive-accent)" : "var(--text-muted)"};
            border-radius: 24px;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.2);
        `;
    const knob = slider.createDiv();
    knob.style.cssText = `
            position: absolute;
            height: 18px;
            width: 18px;
            left: ${this.isLightTheme ? "24px" : "3px"};
            bottom: 3px;
            background: white;
            border-radius: 50%;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        `;
    const moonIcon = toggleWrapper.createSpan();
    moonIcon.innerHTML = "\u{1F319}";
    moonIcon.style.cssText = `
            font-size: 1.1rem;
            transition: all 0.3s ease;
            opacity: ${this.isLightTheme ? "0.5" : "1"};
        `;
    const updateTheme = (isLight) => {
      this.isLightTheme = isLight;
      themeSwitch.checked = isLight;
      slider.style.background = isLight ? "var(--interactive-accent)" : "var(--text-muted)";
      knob.style.left = isLight ? "24px" : "3px";
      sunIcon.style.opacity = isLight ? "1" : "0.5";
      moonIcon.style.opacity = isLight ? "0.5" : "1";
      this.applyTheme(isLight);
      localStorage.setItem("ytc-theme-mode", isLight ? "light" : "dark");
    };
    slider.addEventListener("click", () => {
      updateTheme(!this.isLightTheme);
    });
    themeSwitch.addEventListener("change", () => {
      updateTheme(themeSwitch.checked);
    });
    this.themeElements = {
      slider,
      knob,
      sunIcon,
      moonIcon,
      updateTheme
    };
  }
  /**
   * Apply theme to modal
   */
  applyTheme(isLight) {
    var _a, _b, _c;
    if (!document.getElementById("ytc-theme-styles")) {
      const themeStyle = document.createElement("style");
      themeStyle.id = "ytc-theme-styles";
      let css = "";
      css += `.ytc-modal-light {`;
      css += `--ytc-bg-primary: #ffffff;`;
      css += `--ytc-bg-secondary: #f8f9fa;`;
      css += `--ytc-bg-tertiary: #e9ecef;`;
      css += `--ytc-text-primary: #212529;`;
      css += `--ytc-text-secondary: #6c757d;`;
      css += `--ytc-text-muted: #adb5bd;`;
      css += `--ytc-border: #dee2e6;`;
      css += `--ytc-accent: #0d6efd;`;
      css += `--ytc-accent-hover: #0b5ed7;`;
      css += `--ytc-success: #198754;`;
      css += `--ytc-warning: #ffc107;`;
      css += `--ytc-error: #dc3545;`;
      css += `--ytc-shadow: rgba(0, 0, 0, 0.1);`;
      css += `}`;
      css += `.ytc-modal-dark {`;
      css += `--ytc-bg-primary: #1e1e1e;`;
      css += `--ytc-bg-secondary: #252526;`;
      css += `--ytc-bg-tertiary: #3c3c3c;`;
      css += `--ytc-text-primary: #ffffff;`;
      css += `--ytc-text-secondary: #e0e0e0;`;
      css += `--ytc-text-muted: #a0a0a0;`;
      css += `--ytc-border: #3c3c3c;`;
      css += `--ytc-accent: #4a9eff;`;
      css += `--ytc-accent-hover: #3a8eef;`;
      css += `--ytc-success: #4caf50;`;
      css += `--ytc-warning: #ff9800;`;
      css += `--ytc-error: #f44336;`;
      css += `--ytc-shadow: rgba(0, 0, 0, 0.3);`;
      css += `}`;
      themeStyle.innerHTML = css;
      document.head.appendChild(themeStyle);
    }
    (_a = this.modalEl) == null ? void 0 : _a.classList.add("ytc-themed-modal");
    (_b = this.modalEl) == null ? void 0 : _b.classList.toggle("ytc-modal-light", isLight);
    (_c = this.modalEl) == null ? void 0 : _c.classList.toggle("ytc-modal-dark", !isLight);
    if (this.formatSelect) {
      this.formatSelect.style.background = `var(--ytc-bg-primary)`;
      this.formatSelect.style.color = `var(--ytc-text-primary)`;
      this.formatSelect.style.borderColor = `var(--ytc-border)`;
    }
    if (this.providerSelect) {
      this.providerSelect.style.background = `var(--ytc-bg-primary)`;
      this.providerSelect.style.color = `var(--ytc-text-primary)`;
      this.providerSelect.style.borderColor = `var(--ytc-border)`;
    }
    if (this.modelSelect) {
      this.modelSelect.style.background = `var(--ytc-bg-primary)`;
      this.modelSelect.style.color = `var(--ytc-text-primary)`;
      this.modelSelect.style.borderColor = `var(--ytc-border)`;
    }
    if (this.headerEl) {
      this.headerEl.style.color = "var(--ytc-text-primary)";
    }
    if (this.progressText) {
      this.progressText.style.color = "var(--ytc-text-primary)";
    }
  }
  /**
   * Create progress section to display real-time progress
   */
  createProgressSection() {
    this.progressContainer = this.contentEl.createDiv();
    this.progressContainer.setAttribute("role", "region");
    this.progressContainer.setAttribute("aria-label", "Processing progress");
    this.progressContainer.setAttribute("aria-live", "polite");
    this.progressContainer.style.marginTop = "16px";
    this.progressContainer.style.display = "none";
    this.progressText = this.progressContainer.createDiv();
    this.progressText.id = "progress-text";
    this.progressText.style.marginBottom = "8px";
    this.progressText.style.fontWeight = "500";
    this.progressText.style.color = "var(--text-accent)";
    this.progressText.textContent = "Processing video...";
    const progressBarContainer = this.progressContainer.createDiv();
    progressBarContainer.setAttribute("role", "progressbar");
    progressBarContainer.setAttribute("aria-valuenow", "0");
    progressBarContainer.setAttribute("aria-valuemin", "0");
    progressBarContainer.setAttribute("aria-valuemax", "100");
    progressBarContainer.setAttribute("aria-labelledby", "progress-text");
    progressBarContainer.style.width = "100%";
    progressBarContainer.style.height = "10px";
    progressBarContainer.style.backgroundColor = "var(--background-modifier-border)";
    progressBarContainer.style.borderRadius = "5px";
    progressBarContainer.style.overflow = "hidden";
    this.progressBar = progressBarContainer.createDiv();
    this.progressBar.style.height = "100%";
    this.progressBar.style.backgroundColor = "var(--interactive-accent)";
    this.progressBar.style.borderRadius = "5px";
    this.progressBar.style.width = "0%";
    this.progressBar.style.transition = "width 0.3s ease";
  }
  /**
   * Create action buttons with accessibility
   */
  createActionButtons() {
    const container = this.contentEl.createDiv();
    container.style.cssText = `
            display: flex;
            justify-content: flex-end;
            gap: 12px;
            margin-top: 20px;
            padding-top: 16px;
            border-top: 1px solid var(--background-modifier-border);
        `;
    const cancelBtn = container.createEl("button");
    cancelBtn.textContent = MESSAGES.MODALS.CANCEL;
    cancelBtn.style.cssText = `
            padding: 8px 16px;
            border: 1px solid var(--background-modifier-border);
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            background: var(--background-secondary);
            color: var(--text-normal);
            transition: all 0.2s ease;
        `;
    cancelBtn.addEventListener("click", () => this.close());
    this.processButton = container.createEl("button");
    this.processButton.textContent = MESSAGES.MODALS.PROCESS;
    this.processButton.style.cssText = `
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            background: var(--interactive-accent);
            color: var(--text-on-accent);
            transition: all 0.2s ease;
        `;
    this.processButton.addEventListener("click", () => this.handleProcess());
    this.openButton = container.createEl("button");
    this.openButton.textContent = "Open Note";
    this.openButton.style.cssText = `
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            background: var(--interactive-accent);
            color: var(--text-on-accent);
            transition: all 0.2s ease;
        `;
    this.openButton.style.display = "none";
    this.openButton.addEventListener("click", () => this.handleOpenFile());
    this.updateProcessButtonState();
  }
  /**
   * Set up event handlers for the modal
   */
  setupEventHandlers() {
    this.scope.register([], "Enter", () => {
      if (this.processButton && !this.processButton.disabled) {
        this.processButton.click();
      }
      return false;
    });
    this.scope.register([], "Escape", () => {
      this.close();
      return false;
    });
    if (this.urlInput) {
      this.urlInput.addEventListener("input", () => {
        this.url = this.urlInput.value;
        this.updateProcessButtonState();
      });
    }
  }
  /**
   * Focus on URL input
   */
  focusUrlInput() {
    if (this.urlInput) {
      this.urlInput.focus();
    }
  }
  /**
   * Update process button enabled state
   */
  updateProcessButtonState() {
    if (!this.processButton)
      return;
    const trimmedUrl = this.url.trim();
    const isValid = ValidationUtils.isValidYouTubeUrl(trimmedUrl);
    this.processButton.disabled = !isValid || this.isProcessing;
    this.processButton.style.opacity = this.processButton.disabled ? "0.5" : "1";
    if (trimmedUrl.length === 0) {
      this.setValidationMessage("Paste a YouTube link to begin processing.", "info");
    } else {
      this.setValidationMessage(
        isValid ? "Ready to process this video." : "Enter a valid YouTube video URL.",
        isValid ? "success" : "error"
      );
    }
  }
  /**
   * Set validation message
   */
  setValidationMessage(message, type = "info") {
    if (!this.validationMessage)
      return;
    this.validationMessage.textContent = message;
    let color = "var(--text-muted)";
    if (type === "error") {
      color = "var(--text-error)";
    } else if (type === "success") {
      color = "var(--text-accent)";
    }
    this.validationMessage.style.color = color;
  }
  /**
   * Handle process button click
   */
  async handleProcess() {
    const trimmedUrl = this.url.trim();
    if (!trimmedUrl) {
      new import_obsidian5.Notice(MESSAGES.ERRORS.ENTER_URL);
      this.focusUrlInput();
      return;
    }
    if (!ValidationUtils.isValidYouTubeUrl(trimmedUrl)) {
      new import_obsidian5.Notice(MESSAGES.ERRORS.INVALID_URL);
      this.focusUrlInput();
      return;
    }
    try {
      this.showProcessingState();
      this.updateProgress(0, "Starting...");
      this.updateProgress(25, "Validating URL...");
      const videoId = ValidationUtils.extractVideoId(trimmedUrl);
      if (!videoId) {
        throw new Error("Could not extract YouTube video ID");
      }
      this.updateProgress(50, "Fetching video data...");
      this.updateProgress(75, "Processing with AI...");
      this.format = this.formatSelect.value;
      this.selectedProvider = this.providerSelect.value;
      this.selectedModel = this.modelSelect.value;
      const filePath = await this.options.onProcess(
        trimmedUrl,
        this.format,
        this.selectedProvider,
        this.selectedModel,
        this.format === "custom" ? void 0 : void 0,
        this.options.performanceMode || "balanced",
        this.options.enableParallelProcessing || false,
        this.options.preferMultimodal || false,
        this.options.defaultMaxTokens || 4096,
        this.options.defaultTemperature || 0.5
      );
      this.updateProgress(100, "Complete!");
      this.processedFilePath = filePath;
      this.showCompletionState();
    } catch (error) {
      this.showErrorState(error);
      ErrorHandler.handle(error, "YouTube URL processing");
    }
  }
  /**
   * Show processing state
   */
  showProcessingState() {
    this.isProcessing = true;
    if (this.progressContainer) {
      this.progressContainer.style.display = "block";
    }
    if (this.urlInput) {
      this.urlInput.disabled = true;
    }
    if (this.processButton) {
      this.processButton.disabled = true;
      this.processButton.textContent = "Processing...";
    }
    if (this.openButton) {
      this.openButton.style.display = "none";
    }
  }
  /**
   * Update progress bar and text in real-time
   */
  updateProgress(percent, text) {
    if (this.progressBar) {
      this.progressBar.style.width = `${percent}%`;
    }
    if (this.progressText) {
      this.progressText.textContent = text;
    }
  }
  /**
   * Show completion state
   */
  showCompletionState() {
    this.isProcessing = false;
    if (this.urlInput) {
      this.urlInput.disabled = false;
      this.urlInput.value = "";
      this.url = "";
    }
    if (this.processButton) {
      this.processButton.disabled = false;
      this.processButton.textContent = "Process Another";
      this.processButton.style.display = "inline-block";
    }
    if (this.openButton) {
      this.openButton.style.display = "inline-block";
    }
    if (this.headerEl) {
      this.headerEl.textContent = "\u2705 Video Processed Successfully!";
    }
    this.setValidationMessage("Note saved. You can open it now or process another video.", "success");
    this.focusUrlInput();
  }
  /**
   * Show error state
   */
  showErrorState(error) {
    this.isProcessing = false;
    if (this.urlInput) {
      this.urlInput.disabled = false;
    }
    if (this.processButton) {
      this.processButton.disabled = false;
      this.processButton.textContent = MESSAGES.MODALS.PROCESS;
    }
    if (this.openButton) {
      this.openButton.style.display = "none";
    }
    if (this.headerEl) {
      this.headerEl.textContent = "\u274C Processing Failed";
    }
    this.setValidationMessage(error.message, "error");
  }
  /**
   * Handle open file button click
   */
  async handleOpenFile() {
    if (this.processedFilePath && this.options.onOpenFile) {
      try {
        await this.options.onOpenFile(this.processedFilePath);
        this.close();
      } catch (error) {
        ErrorHandler.handle(error, "Opening file");
      }
    }
  }
  /**
   * Set URL value
   */
  setUrl(url) {
    this.url = url;
    if (this.urlInput) {
      this.urlInput.value = url;
    }
    this.updateProcessButtonState();
  }
  /**
   * Enhanced paste functionality with smart URL detection
   */
  async handleSmartPaste() {
    try {
      const text = await navigator.clipboard.readText();
      const trimmed = text.trim();
      if (ValidationUtils.isValidYouTubeUrl(trimmed)) {
        this.setUrl(trimmed);
        new import_obsidian5.Notice("YouTube URL detected and pasted!");
      } else {
        const urlMatch = trimmed.match(/(?:https?:\/\/)?(?:www\.)?(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([a-zA-Z0-9_-]{11})/);
        if (urlMatch) {
          const videoId = urlMatch[1];
          const fullUrl = `https://www.youtube.com/watch?v=${videoId}`;
          this.setUrl(fullUrl);
          new import_obsidian5.Notice("YouTube URL extracted from clipboard!");
        } else {
          new import_obsidian5.Notice("No YouTube URL found in clipboard");
        }
      }
      if (this.processButton && !this.isProcessing && ValidationUtils.isValidYouTubeUrl(trimmed)) {
        this.processButton.focus();
      } else {
        this.focusUrlInput();
      }
    } catch (error) {
      console.error("Failed to read clipboard:", error);
      new import_obsidian5.Notice("Could not access clipboard");
    }
  }
  /**
   * Setup keyboard shortcuts for enhanced productivity
   */
  setupKeyboardShortcuts() {
    const handleKeyDown = (e) => {
      if (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement) {
        return;
      }
      if ((e.ctrlKey || e.metaKey) && e.key === "Enter") {
        e.preventDefault();
        if (this.processButton && !this.processButton.disabled) {
          this.processButton.click();
        }
      }
      if (e.key === "Escape") {
        this.close();
      }
    };
    this.scope.register(["Ctrl"], "Enter", () => {
      if (this.processButton && !this.processButton.disabled) {
        this.processButton.click();
      }
      return false;
    });
  }
  /**
   * Clean up resources when modal is closed
   */
  onClose() {
    if (this.validationTimer) {
      clearTimeout(this.validationTimer);
    }
    super.onClose();
  }
};

// src/settings-tab.ts
var import_obsidian6 = require("obsidian");

// src/secure-config.ts
var SecureConfigService = class {
  constructor(settings) {
    this.settings = settings;
  }
  /**
   * Get API key with environment variable fallback
   */
  getApiKey(keyType) {
    if (this.settings.useEnvironmentVariables) {
      return this.getFromEnvironment(keyType);
    }
    return keyType === "gemini" ? this.settings.geminiApiKey : this.settings.groqApiKey;
  }
  /**
   * Get API key from environment variables
   */
  getFromEnvironment(keyType) {
    const prefix = this.settings.environmentPrefix || "YTC";
    const envVarName = `${prefix}_${keyType.toUpperCase()}_API_KEY`;
    return this.getSecureEnvVar(envVarName) || "";
  }
  /**
   * Secure environment variable access
   * Note: In Obsidian plugins, environment variables are limited
   * This method can be extended for server-side environments
   */
  getSecureEnvVar(varName) {
    if (typeof process !== "undefined" && process.env) {
      return process.env[varName];
    }
    return this.getFromSecureStorage(varName);
  }
  /**
   * Get from secure storage (implementation depends on environment)
   */
  getFromSecureStorage(varName) {
    return void 0;
  }
  /**
   * Validate configuration security
   */
  validateSecurityConfiguration() {
    const warnings = [];
    let isSecure = true;
    if (!this.settings.useEnvironmentVariables) {
      if (this.settings.geminiApiKey && this.settings.geminiApiKey.length > 0) {
        warnings.push("Gemini API key is stored directly in configuration. Consider using environment variables.");
        isSecure = false;
      }
      if (this.settings.groqApiKey && this.settings.groqApiKey.length > 0) {
        warnings.push("Groq API key is stored directly in configuration. Consider using environment variables.");
        isSecure = false;
      }
    }
    if (this.settings.geminiApiKey === "your-api-key-here" || this.settings.groqApiKey === "your-api-key-here") {
      warnings.push("Default placeholder API keys detected. Please set real API keys.");
      isSecure = false;
    }
    return { isSecure, warnings };
  }
  /**
   * Get configuration template for environment variables
   */
  getEnvironmentTemplate() {
    const prefix = this.settings.environmentPrefix || "YTC";
    return `# YouTubeClipper Environment Variables
# Set these in your environment for secure API key management

# Google Gemini API Key
${prefix}_GEMINI_API_KEY=your_gemini_api_key_here

# Groq API Key  
${prefix}_GROQ_API_KEY=your_groq_api_key_here

# Usage:
# 1. Set these variables in your shell profile (.bashrc, .zshrc, etc.)
# 2. Enable "Use Environment Variables" in plugin settings
# 3. Restart Obsidian to pick up the new environment variables
`;
  }
};

// src/settings-tab.ts
var SETTINGS_CSS_CLASSES = {
  container: "ytc-settings-container",
  section: "ytc-settings-section",
  header: "ytc-settings-header",
  validation: "ytc-settings-validation"
};
var YouTubeSettingsTab = class extends import_obsidian6.PluginSettingTab {
  constructor(app, options) {
    super(app, options.plugin);
    this.options = options;
    this.validationErrors = [];
    this.settings = { ...options.plugin.settings };
    this.secureConfig = new SecureConfigService(this.settings);
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.addClass(SETTINGS_CSS_CLASSES.container);
    containerEl.setAttribute("data-plugin", "youtube-clipper");
    containerEl.style.overflowY = "auto";
    containerEl.style.maxHeight = "80vh";
    containerEl.style.height = "fit-content";
    containerEl.style.paddingRight = "8px";
    containerEl.style.margin = "0";
    containerEl.style.padding = "8px";
    this.addScrollbarStyling();
    this.createImprovedCompactLayout();
  }
  /**
   * Add custom scrollbar styling for better UX
   */
  addScrollbarStyling() {
    if (document.getElementById("ytc-scrollbar-styles")) {
      return;
    }
    const scrollbarStyle = document.createElement("style");
    scrollbarStyle.id = "ytc-scrollbar-styles";
    scrollbarStyle.textContent = `
            .${SETTINGS_CSS_CLASSES.container}::-webkit-scrollbar {
                width: 8px;
            }

            .${SETTINGS_CSS_CLASSES.container}::-webkit-scrollbar-track {
                background: var(--background-primary);
                border-radius: 4px;
            }

            .${SETTINGS_CSS_CLASSES.container}::-webkit-scrollbar-thumb {
                background: var(--background-modifier-border);
                border-radius: 4px;
            }

            .${SETTINGS_CSS_CLASSES.container}::-webkit-scrollbar-thumb:hover {
                background: var(--interactive-accent);
            }
        `;
    document.head.appendChild(scrollbarStyle);
  }
  /**
   * Create improved compact and scollable layout
   */
  createImprovedCompactLayout() {
    this.addCompactStyles();
    const { containerEl } = this;
    containerEl.style.display = "flex";
    containerEl.style.flexDirection = "column";
    containerEl.style.height = "fit-content";
    containerEl.style.gap = "8px";
    containerEl.style.padding = "8px";
    containerEl.style.overflow = "visible";
    containerEl.style.backgroundColor = "var(--background-primary)";
    this.createCompactHeader();
    const mainContent = containerEl.createDiv();
    mainContent.style.display = "flex";
    mainContent.style.flexDirection = "column";
    mainContent.style.gap = "8px";
    mainContent.style.width = "100%";
    this.createAPISettingsSection(mainContent);
    this.createAIParametersSection(mainContent);
    this.createFileSettingsSection(mainContent);
    this.createAdvancedSettingsSection(mainContent);
    this.createQuickStartSection(mainContent);
  }
  /**
   * Add compact styles to the document
   */
  addCompactStyles() {
    if (document.getElementById("ytc-compact-styles")) {
      return;
    }
    const compactStyle = document.createElement("style");
    compactStyle.id = "ytc-compact-styles";
    compactStyle.textContent = `
            .${SETTINGS_CSS_CLASSES.container} .setting-item {
                padding: 6px 4px !important;
                margin: 2px 0 !important;
            }
            .${SETTINGS_CSS_CLASSES.container} .setting-item-name {
                font-size: 0.85rem !important;
                margin-bottom: 1px !important;
            }
            .${SETTINGS_CSS_CLASSES.container} .setting-item-description {
                font-size: 0.75rem !important;
                margin-bottom: 2px !important;
            }
            .${SETTINGS_CSS_CLASSES.container} input[type="text"] {
                font-size: 0.8rem !important;
                padding: 4px 6px !important;
            }
            .${SETTINGS_CSS_CLASSES.container} select {
                font-size: 0.8rem !important;
                padding: 4px 6px !important;
            }
            .${SETTINGS_CSS_CLASSES.container} button {
                font-size: 0.75rem !important;
                padding: 3px 8px !important;
            }
        `;
    document.head.appendChild(compactStyle);
  }
  /**
   * Create compact header
   */
  createCompactHeader() {
    const { containerEl } = this;
    const header = containerEl.createDiv();
    header.style.cssText = `
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 6px 10px;
            background: var(--background-secondary);
            border-radius: 5px;
            border: 1px solid var(--background-modifier-border);
            margin-bottom: 6px;
        `;
    const title = header.createEl("h2", {
      text: "YT Clipper Settings",
      style: "margin: 0; font-size: 1rem; font-weight: 600; color: var(--text-normal);"
    });
    const hasValidConfig = this.validateConfiguration();
    const statusBadge = header.createDiv();
    statusBadge.style.cssText = `
            padding: 3px 8px;
            border-radius: 10px;
            font-size: 0.7rem;
            font-weight: 600;
        `;
    if (hasValidConfig) {
      statusBadge.style.background = "var(--interactive-accent)";
      statusBadge.style.color = "var(--text-on-accent)";
      statusBadge.textContent = "\u2713 Ready";
    } else {
      statusBadge.style.background = "var(--text-warning)";
      statusBadge.style.color = "var(--text-on-accent)";
      statusBadge.textContent = "\u26A0 Setup Needed";
    }
  }
  /**
   * Create API settings section
   */
  createAPISettingsSection(mainContent) {
    const section = mainContent.createDiv();
    section.style.background = "var(--background-secondary)";
    section.style.border = "1px solid var(--background-modifier-border)";
    section.style.borderRadius = "6px";
    section.style.padding = "6px";
    section.style.display = "flex";
    section.style.flexDirection = "column";
    section.style.gap = "4px";
    const header = section.createEl("h3", {
      text: "\u{1F511} API",
      style: "margin: 0 0 3px 0; font-size: 0.85rem; font-weight: 600; color: var(--text-normal);"
      // Smaller font
    });
    new import_obsidian6.Setting(section).setName("Gemi").setDesc("Key").addText((text) => text.setPlaceholder("AIza...").setValue(this.settings.geminiApiKey || "").onChange(async (value) => {
      await this.updateSetting("geminiApiKey", value);
    })).setClass("compact-setting");
    new import_obsidian6.Setting(section).setName("Groq").setDesc("Key").addText((text) => text.setPlaceholder("gsk_...").setValue(this.settings.groqApiKey || "").onChange(async (value) => {
      await this.updateSetting("groqApiKey", value);
    })).setClass("compact-setting");
    new import_obsidian6.Setting(section).setName("Ollm").setDesc("Key").addText((text) => text.setPlaceholder("key").setValue(this.settings.ollamaApiKey || "").onChange(async (value) => {
      await this.updateSetting("ollamaApiKey", value);
    })).setClass("compact-setting");
    const testDiv = section.createDiv();
    testDiv.style.marginTop = "2px";
    new import_obsidian6.Setting(testDiv).setName("Test").setDesc("").addButton((btn) => btn.setButtonText("\u2713").onClick(async () => {
      btn.setDisabled(true);
      btn.setButtonText("...");
      try {
        await this.testAPIKeys();
        btn.setButtonText("\u2713");
        setTimeout(() => {
          btn.setButtonText("\u2713");
          btn.setDisabled(false);
        }, 1500);
      } catch (error) {
        btn.setButtonText("\u2717");
        ErrorHandler.handle(error, "API key test failed", true);
        setTimeout(() => {
          btn.setButtonText("\u2713");
          btn.setDisabled(false);
        }, 1500);
      }
    })).setClass("compact-setting");
  }
  /**
   * Create AI parameters section with model defaults
   */
  createAIParametersSection(mainContent) {
    const section = mainContent.createDiv();
    section.style.background = "var(--background-secondary)";
    section.style.border = "1px solid var(--background-modifier-border)";
    section.style.borderRadius = "6px";
    section.style.padding = "6px";
    section.style.display = "flex";
    section.style.flexDirection = "column";
    section.style.gap = "4px";
    const header = section.createEl("h3", {
      text: "\u2699\uFE0F AI",
      style: "margin: 0 0 3px 0; font-size: 0.85rem; font-weight: 600; color: var(--text-normal);"
      // Smaller font
    });
    const styleSheet = document.createElement("style");
    styleSheet.textContent = `
            .ytc-slider {
                width: 100% !important;
                height: 5px !important; /* Even thinner for compactness */
                border-radius: 2px !important;
                background: var(--interactive-normal) !important;
                outline: none !important;
                -webkit-appearance: none !important;
                appearance: none !important;
                cursor: pointer !important;
            }
            .ytc-slider:hover {
                background: var(--interactive-hover) !important;
            }
            .ytc-slider::-webkit-slider-thumb {
                -webkit-appearance: none !important;
                appearance: none !important;
                width: 14px !important; /* Smaller thumb */
                height: 14px !important;
                background: var(--interactive-accent) !important;
                border-radius: 50% !important;
                cursor: pointer !important;
                border: 1px solid var(--text-on-accent) !important;
                box-shadow: 0 1px 2px rgba(0,0,0,0.2) !important;
            }
            .ytc-slider::-moz-range-thumb {
                width: 14px !important;
                height: 14px !important;
                background: var(--interactive-accent) !important;
                border-radius: 50% !important;
                cursor: pointer !important;
                border: 1px solid var(--text-on-accent) !important;
                box-shadow: 0 1px 2px rgba(0,0,0,0.2) !important;
            }
        `;
    document.head.appendChild(styleSheet);
    const createCompactSlider = (label, min, max, step, value, settingKey) => {
      const container = section.createDiv();
      container.style.marginBottom = "4px";
      const labelRow = container.createDiv();
      labelRow.style.display = "flex";
      labelRow.style.justifyContent = "space-between";
      labelRow.style.alignItems = "center";
      labelRow.style.marginBottom = "2px";
      const labelText = labelRow.createSpan();
      labelText.textContent = label;
      labelText.style.fontSize = "0.75rem";
      labelText.style.fontWeight = "500";
      labelText.style.color = "var(--text-normal)";
      const valueText = labelRow.createSpan();
      valueText.textContent = value.toString();
      valueText.style.fontSize = "0.7rem";
      valueText.style.fontWeight = "600";
      valueText.style.color = "var(--interactive-accent)";
      valueText.style.padding = "1px 3px";
      valueText.style.background = "var(--background-primary)";
      valueText.style.borderRadius = "2px";
      valueText.style.border = "1px solid var(--interactive-accent)";
      const slider = container.createEl("input", { type: "range" });
      slider.className = "ytc-slider";
      slider.min = min.toString();
      slider.max = max.toString();
      slider.step = step.toString();
      slider.value = value.toString();
      slider.addEventListener("input", () => {
        valueText.textContent = settingKey === "defaultTemperature" ? parseFloat(slider.value).toFixed(1) : slider.value;
      });
      slider.addEventListener("change", async () => {
        const finalValue = settingKey === "defaultTemperature" ? parseFloat(slider.value) : parseInt(slider.value);
        await this.updateSetting(settingKey, finalValue);
      });
      return container;
    };
    createCompactSlider(
      "Tokens",
      256,
      8192,
      256,
      this.settings.defaultMaxTokens || 4096,
      "defaultMaxTokens"
    );
    createCompactSlider(
      "Temp",
      0,
      2,
      0.1,
      this.settings.defaultTemperature || 0.5,
      "defaultTemperature"
    );
    const scaleDiv = section.createDiv();
    scaleDiv.style.display = "flex";
    scaleDiv.style.justifyContent = "space-between";
    scaleDiv.style.fontSize = "0.6rem";
    scaleDiv.style.color = "var(--text-muted)";
    scaleDiv.style.marginTop = "-4px";
    scaleDiv.style.padding = "0 1px";
    scaleDiv.createSpan({ text: "P" });
    scaleDiv.createSpan({ text: "C" });
    new import_obsidian6.Setting(section).setName("Perf").setDesc("Mode").addDropdown((dropdown) => dropdown.addOption("fast", "F").addOption("balanced", "B").addOption("quality", "Q").setValue(this.settings.performanceMode || "balanced").onChange(async (value) => {
      await this.updateSetting("performanceMode", value);
    })).setClass("compact-setting");
  }
  /**
   * Create advanced settings section for moved options from modal
   */
  createAdvancedSettingsSection(mainContent) {
    const section = mainContent.createDiv();
    section.style.background = "var(--background-secondary)";
    section.style.border = "1px solid var(--background-modifier-border)";
    section.style.borderRadius = "6px";
    section.style.padding = "6px";
    section.style.display = "flex";
    section.style.flexDirection = "column";
    section.style.gap = "3px";
    const header = section.createEl("h3", {
      text: "\u2699\uFE0F Adv",
      style: "margin: 0 0 2px 0; font-size: 0.85rem; font-weight: 600; color: var(--text-normal);"
      // Smaller font
    });
    new import_obsidian6.Setting(section).setName("Parallel").setDesc("Multi").addToggle((toggle) => toggle.setValue(this.settings.enableParallelProcessing || false).onChange(async (value) => {
      await this.updateSetting("enableParallelProcessing", value);
    })).setClass("compact-setting");
    new import_obsidian6.Setting(section).setName("MM-Audio").setDesc("Vid").addToggle((toggle) => toggle.setValue(this.settings.preferMultimodal || false).onChange(async (value) => {
      await this.updateSetting("preferMultimodal", value);
    })).setClass("compact-setting");
  }
  /**
   * Create file settings section
   */
  createFileSettingsSection(mainContent) {
    const section = mainContent.createDiv();
    section.style.background = "var(--background-secondary)";
    section.style.border = "1px solid var(--background-modifier-border)";
    section.style.borderRadius = "6px";
    section.style.padding = "6px";
    section.style.display = "flex";
    section.style.flexDirection = "column";
    section.style.gap = "4px";
    const header = section.createEl("h3", {
      text: "\u{1F4C1} Files",
      style: "margin: 0 0 2px 0; font-size: 0.85rem; font-weight: 600; color: var(--text-normal);"
      // Smaller font
    });
    new import_obsidian6.Setting(section).setName("Path").setDesc("Out").addText((text) => text.setPlaceholder("YT/Proc").setValue(this.settings.outputPath || "YouTube/Processed Videos").onChange(async (value) => {
      await this.updateSetting("outputPath", value);
    })).setClass("compact-setting");
  }
  /**
   * Validate entire configuration
   */
  validateConfiguration() {
    var _a, _b;
    const hasApiKey = ((_a = this.settings.geminiApiKey) == null ? void 0 : _a.trim()) || ((_b = this.settings.groqApiKey) == null ? void 0 : _b.trim());
    const hasValidPath = ValidationUtils.isValidPath(this.settings.outputPath);
    return Boolean(hasApiKey && hasValidPath);
  }
  /**
   * Show inline documentation
   */
  showDocumentation() {
    window.open("https://github.com/youtube-clipper/obsidian-plugin#readme", "_blank");
  }
  /**
   * Create quick start section
   */
  createQuickStartSection(mainContent) {
    const section = mainContent.createDiv();
    section.style.background = "var(--background-secondary)";
    section.style.border = "1px solid var(--background-modifier-border)";
    section.style.borderRadius = "6px";
    section.style.padding = "6px";
    section.style.display = "flex";
    section.style.flexDirection = "column";
    section.style.gap = "3px";
    const header = section.createEl("h3", {
      text: "\u{1F680} Go",
      style: "margin: 0 0 2px 0; font-size: 0.8rem; font-weight: 600; color: var(--text-normal);"
      // Smaller font
    });
    const stepsDiv = section.createDiv();
    stepsDiv.style.fontSize = "0.7rem";
    stepsDiv.style.lineHeight = "1.2";
    const steps = [
      "API (G/G)",
      "Cfg",
      "URL",
      "Go"
    ];
    steps.forEach((step, index) => {
      const stepDiv = stepsDiv.createDiv();
      stepDiv.style.marginBottom = "2px";
      stepDiv.style.display = "flex";
      stepDiv.style.alignItems = "flex-start";
      stepDiv.style.gap = "3px";
      const stepNumber = stepDiv.createSpan();
      stepNumber.textContent = index + 1 + ".";
      stepNumber.style.color = "var(--interactive-accent)";
      stepNumber.style.fontWeight = "600";
      stepNumber.style.minWidth = "10px";
      const stepText = stepDiv.createSpan();
      stepText.textContent = step;
    });
    const linksDiv = section.createDiv();
    linksDiv.style.marginTop = "3px";
    linksDiv.style.paddingTop = "3px";
    linksDiv.style.borderTop = "1px solid var(--background-modifier-border)";
    linksDiv.style.fontSize = "0.65rem";
    linksDiv.style.color = "var(--text-muted)";
    const linksLabel = linksDiv.createSpan();
    linksLabel.textContent = "Keys: ";
    linksLabel.style.fontWeight = "500";
    const geminiLink = linksDiv.createEl("a", {
      text: "G",
      href: "https://aistudio.google.com/app/apikey",
      cls: "external-link"
    });
    geminiLink.style.marginRight = "5px";
    geminiLink.style.color = "var(--link-color)";
    geminiLink.style.fontSize = "0.65rem";
    const groqLink = linksDiv.createEl("a", {
      text: "Gr",
      href: "https://console.groq.com/keys",
      cls: "external-link"
    });
    groqLink.style.color = "var(--link-color)";
    groqLink.style.fontSize = "0.65rem";
  }
  /**
   * Test API keys for validity
   */
  async testAPIKeys() {
    const errors = [];
    if (this.settings.geminiApiKey) {
      try {
        const response = await fetch(
          "https://generativelanguage.googleapis.com/v1beta/models?key=" + this.settings.geminiApiKey
        );
        if (!response.ok) {
          errors.push(`Gemini API key invalid (${response.status})`);
        }
      } catch (error) {
        errors.push("Gemini API key test failed (network error)");
      }
    } else {
      errors.push("Gemini API key not configured");
    }
    if (errors.length > 0) {
      throw new Error(errors.join("\n"));
    }
  }
  /**
   * Update a setting value
   */
  async updateSetting(key, value) {
    try {
      this.settings[key] = value;
      await this.validateAndSaveSettings();
    } catch (error) {
      ErrorHandler.handle(error, `Settings update for ${key}`);
    }
  }
  /**
   * Validate and save settings
   */
  async validateAndSaveSettings() {
    const validation = ValidationUtils.validateSettings(this.settings);
    this.validationErrors = validation.errors;
    if (validation.isValid) {
      await this.options.onSettingsChange(this.settings);
    }
    this.display();
  }
  /**
   * Get current settings
   */
  getSettings() {
    return { ...this.settings };
  }
  /**
   * Update settings from external source
   */
  updateSettings(newSettings) {
    this.settings = { ...newSettings };
    this.display();
  }
};

// src/services/ai-service.ts
init_api();

// src/performance.ts
var PERFORMANCE_PRESETS = {
  fast: {
    name: "Fast",
    description: "Maximum speed with optimized models and parallel processing. Best for quick summaries.",
    timeouts: {
      geminiTimeout: 15e3,
      groqTimeout: 1e4,
      metadataTimeout: 5e3
    },
    enableParallel: true,
    preferMultimodal: false,
    modelStrategy: {
      briefFormat: "llama-3.1-8b-instant",
      executiveSummary: "llama-3.3-70b-versatile",
      detailedGuide: "gemini-2.0-flash-lite",
      fallbackModel: "llama-3.1-8b-instant"
    }
  },
  balanced: {
    name: "Balanced",
    description: "Balanced speed and quality with multimodal analysis for detailed content.",
    timeouts: {
      geminiTimeout: 3e4,
      groqTimeout: 2e4,
      metadataTimeout: 1e4
    },
    enableParallel: true,
    preferMultimodal: true,
    modelStrategy: {
      briefFormat: "llama-3.1-8b-instant",
      executiveSummary: "gemini-2.0-flash-lite",
      detailedGuide: "gemini-2.5-flash",
      fallbackModel: "llama-3.3-70b-versatile"
    }
  },
  quality: {
    name: "Quality",
    description: "Maximum quality with comprehensive multimodal analysis. Slower but most detailed.",
    timeouts: {
      geminiTimeout: 6e4,
      groqTimeout: 3e4,
      metadataTimeout: 15e3
    },
    enableParallel: false,
    preferMultimodal: true,
    modelStrategy: {
      briefFormat: "gemini-2.0-flash-lite",
      executiveSummary: "gemini-2.5-flash",
      detailedGuide: "gemini-2.5-pro",
      fallbackModel: "gemini-2.0-flash"
    }
  }
};

// src/services/retry-service.ts
var RetryService = class {
  /**
   * Execute an operation with retry logic
   */
  static async executeWithRetry(operation, operationName, config = {}) {
    const finalConfig = { ...this.defaultConfig, ...config };
    const startTime = Date.now();
    let lastError;
    logger.info(`Starting retryable operation: ${operationName}`, "RetryService", {
      maxAttempts: finalConfig.maxAttempts,
      baseDelayMs: finalConfig.baseDelayMs
    });
    for (let attempt = 1; attempt <= finalConfig.maxAttempts; attempt++) {
      try {
        const result = await operation();
        const totalTime2 = Date.now() - startTime;
        logger.info(`Operation succeeded: ${operationName}`, "RetryService", {
          attempt,
          totalTimeMs: totalTime2
        });
        return {
          success: true,
          result,
          attempts: attempt,
          totalTimeMs: totalTime2
        };
      } catch (error) {
        lastError = error;
        logger.warn(`Operation failed: ${operationName}`, "RetryService", {
          attempt,
          error: lastError.message,
          willRetry: attempt < finalConfig.maxAttempts && this.isRetryableError(lastError, finalConfig)
        });
        if (attempt === finalConfig.maxAttempts || !this.isRetryableError(lastError, finalConfig)) {
          break;
        }
        const delay = this.calculateDelay(attempt, finalConfig);
        logger.debug(`Waiting ${delay}ms before retry`, "RetryService", {
          attempt,
          delay
        });
        await this.sleep(delay);
      }
    }
    const totalTime = Date.now() - startTime;
    logger.error(`Operation failed after all retries: ${operationName}`, "RetryService", {
      attempts: finalConfig.maxAttempts,
      totalTimeMs: totalTime,
      finalError: lastError == null ? void 0 : lastError.message
    });
    return {
      success: false,
      error: lastError,
      attempts: finalConfig.maxAttempts,
      totalTimeMs: totalTime
    };
  }
  /**
   * Execute with simple retry (for backward compatibility)
   */
  static async withRetry(operation, operationName, maxAttempts = 3, baseDelayMs = 1e3) {
    const result = await this.executeWithRetry(operation, operationName, {
      maxAttempts,
      baseDelayMs
    });
    if (result.success) {
      return result.result;
    } else {
      throw result.error || new Error("Operation failed after retries");
    }
  }
  /**
   * Check if an error is retryable
   */
  static isRetryableError(error, config) {
    const errorMessage = error.message.toLowerCase();
    const errorName = error.name.toLowerCase();
    for (const retryableError of config.retryableErrors) {
      if (errorMessage.includes(retryableError.toLowerCase()) || errorName.includes(retryableError.toLowerCase())) {
        return true;
      }
    }
    if ("status" in error) {
      const status = error.status;
      return config.retryableStatusCodes.includes(status);
    }
    if (error instanceof TypeError && error.message.includes("fetch")) {
      return true;
    }
    return false;
  }
  /**
   * Calculate delay with exponential backoff and optional jitter
   */
  static calculateDelay(attempt, config) {
    let delay = config.baseDelayMs * Math.pow(config.backoffFactor, attempt - 1);
    delay = Math.min(delay, config.maxDelayMs);
    if (config.jitter) {
      const jitterAmount = delay * 0.25;
      delay = delay + (Math.random() - 0.5) * 2 * jitterAmount;
    }
    return Math.floor(delay);
  }
  /**
   * Sleep for specified milliseconds
   */
  static sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
  /**
   * Create a wrapped fetch with retry logic
   */
  static createRetryableFetch(input, init, retryConfig) {
    return this.withRetry(
      async () => {
        const response = await fetch(input, init);
        if (!response.ok) {
          const error = new Error(`HTTP ${response.status}: ${response.statusText}`);
          error.status = response.status;
          error.statusText = response.statusText;
          throw error;
        }
        return response;
      },
      `fetch: ${typeof input === "string" ? input : "request"}`,
      (retryConfig == null ? void 0 : retryConfig.maxAttempts) || 3,
      (retryConfig == null ? void 0 : retryConfig.baseDelayMs) || 1e3
    );
  }
  /**
   * Execute multiple operations concurrently with individual retry logic
   */
  static async executeWithRetryConcurrently(operations) {
    logger.info(`Executing ${operations.length} operations concurrently with retry`, "RetryService");
    const promises = operations.map(
      ({ operation, name, config }) => this.executeWithRetry(operation, name, config)
    );
    const results = await Promise.all(promises);
    const successfulCount = results.filter((r) => r.success).length;
    const failedCount = results.length - successfulCount;
    logger.info(`Concurrent operations completed`, "RetryService", {
      total: results.length,
      successful: successfulCount,
      failed: failedCount
    });
    return results;
  }
  /**
   * Execute operations in series with retry logic
   */
  static async executeWithRetrySeries(operations) {
    logger.info(`Executing ${operations.length} operations in series with retry`, "RetryService");
    const results = [];
    for (const { operation, name, config, continueOnError = false } of operations) {
      const result = await this.executeWithRetry(operation, name, config);
      results.push(result);
      if (!result.success && !continueOnError) {
        logger.info(`Stopping series execution due to failure in: ${name}`, "RetryService");
        break;
      }
    }
    const successfulCount = results.filter((r) => r.success).length;
    const failedCount = results.length - successfulCount;
    logger.info(`Series operations completed`, "RetryService", {
      total: results.length,
      successful: successfulCount,
      failed: failedCount
    });
    return results;
  }
};
RetryService.defaultConfig = {
  maxAttempts: 3,
  baseDelayMs: 1e3,
  maxDelayMs: 3e4,
  backoffFactor: 2,
  retryableErrors: [
    "ECONNRESET",
    "ECONNREFUSED",
    "ETIMEDOUT",
    "ENOTFOUND",
    "NETWORK_ERROR",
    "TIMEOUT",
    "Rate limit",
    "Quota exceeded",
    "Service unavailable"
  ],
  retryableStatusCodes: [408, 429, 500, 502, 503, 504],
  jitter: true
};
var retry = RetryService.withRetry;
var retryFetch = RetryService.createRetryableFetch;

// src/services/ai-service.ts
var AIService = class {
  constructor(providers, settings) {
    this.providers = [];
    if (!providers || providers.length === 0) {
      throw new Error(MESSAGES.ERRORS.MISSING_API_KEYS);
    }
    this.providers = providers;
    this.settings = settings;
    this.applyPerformanceSettings();
  }
  /**
   * Apply performance settings to providers
   */
  applyPerformanceSettings() {
    const preset = PERFORMANCE_PRESETS[this.settings.performanceMode] || PERFORMANCE_PRESETS.balanced;
    const timeouts = this.settings.customTimeouts || preset.timeouts;
    this.providers.forEach((provider) => {
      if (provider.name === "Google Gemini" && provider.setTimeout) {
        provider.setTimeout(timeouts.geminiTimeout);
      } else if (provider.name === "Groq" && provider.setTimeout) {
        provider.setTimeout(timeouts.groqTimeout);
      }
    });
  }
  /**
   * Update settings and reapply performance configurations
   */
  updateSettings(newSettings) {
    this.settings = newSettings;
    this.applyPerformanceSettings();
  }
  /**
   * Return available model options for a provider name (from constants mapping)
   */
  getProviderModels(providerName) {
    const raw = PROVIDER_MODEL_OPTIONS[providerName] || [];
    return raw.map((r) => typeof r === "string" ? r : r && r.name ? r.name : String(r));
  }
  /**
   * Best-effort fetch of latest models for all providers by scraping known provider pages.
   * Returns a mapping providerName -> list of discovered models. Falls back to static mapping.
   * Special handling for Ollama to query the actual running instance.
   */
  async fetchLatestModels() {
    const result = {};
    const providers = this.getProviderNames();
    for (const p of providers) {
      try {
        const models = await this.fetchLatestModelsForProvider(p);
        result[p] = models.length > 0 ? models : PROVIDER_MODEL_OPTIONS[p] ? PROVIDER_MODEL_OPTIONS[p].map((m) => typeof m === "string" ? m : m.name) : [];
      } catch (error) {
        logger.error(`Error fetching models for ${p}`, "AIService", {
          error: error instanceof Error ? error.message : String(error)
        });
        result[p] = PROVIDER_MODEL_OPTIONS[p] ? PROVIDER_MODEL_OPTIONS[p].map((m) => typeof m === "string" ? m : m.name) : [];
      }
    }
    return result;
  }
  /**
   * Fetch latest models for a single provider (best-effort scraping).
   * Special handling for Ollama to query the actual running instance.
   */
  async fetchLatestModelsForProvider(providerName) {
    var _a;
    if (providerName === "Ollama") {
      try {
        const defaultOllamaEndpoint = "http://localhost:11434";
        const response = await fetch(`${defaultOllamaEndpoint}/api/tags`, {
          method: "GET",
          headers: {
            "Content-Type": "application/json"
          }
        });
        if (response.ok) {
          const data = await response.json();
          if (data && data.models && Array.isArray(data.models)) {
            const modelNames = data.models.map((model) => {
              if (model.name) {
                return model.name;
              } else if (model.id) {
                return model.id;
              }
              return "";
            }).filter((name) => name !== "");
            logger.debug(`Fetched ${modelNames.length} models from local Ollama instance`, "AIService", {
              models: modelNames.slice(0, 10)
              // Log first 10 for debugging
            });
            return modelNames;
          }
        } else {
          logger.warn(`Ollama instance not accessible at ${defaultOllamaEndpoint}, using static list`, "AIService");
        }
      } catch (error) {
        logger.warn("Ollama instance not accessible, using static model list", "AIService", {
          error: error instanceof Error ? error.message : String(error)
        });
      }
      logger.debug("Using static Ollama models list", "AIService");
      const fallbackModels = PROVIDER_MODEL_OPTIONS[providerName] ? PROVIDER_MODEL_OPTIONS[providerName].map((m) => typeof m === "string" ? m : m.name) : [];
      return fallbackModels;
    }
    const url = PROVIDER_MODEL_LIST_URLS[providerName];
    const regex = PROVIDER_MODEL_REGEX[providerName];
    if (!url || !regex) {
      return PROVIDER_MODEL_OPTIONS[providerName] ? PROVIDER_MODEL_OPTIONS[providerName].map((m) => typeof m === "string" ? m : m.name) : [];
    }
    try {
      logger.debug(`Fetching latest models for ${providerName}`, "AIService", { url });
      const result = await RetryService.executeWithRetry(
        async () => {
          const resp = await RetryService.createRetryableFetch(url, {
            method: "GET",
            headers: {
              "User-Agent": "Mozilla/5.0 (compatible; YT-Clipper/1.3.5)"
            }
          }, {
            maxAttempts: 2,
            baseDelayMs: 1e3
          });
          if (!resp.ok) {
            const error = new Error(`HTTP ${resp.status}: ${resp.statusText}`);
            error.status = resp.status;
            throw error;
          }
          return resp;
        },
        `fetch-models-${providerName}`,
        {
          maxAttempts: 2,
          baseDelayMs: 1e3,
          retryableStatusCodes: [429, 500, 502, 503, 504]
        }
      );
      if (!result.success) {
        logger.warn(`Failed to fetch models for ${providerName}, using fallback`, "AIService", {
          error: (_a = result.error) == null ? void 0 : _a.message
        });
        return PROVIDER_MODEL_OPTIONS[providerName] ? PROVIDER_MODEL_OPTIONS[providerName].map((m) => typeof m === "string" ? m : m.name) : [];
      }
      const text = await result.result.text();
      const matches = text.match(regex) || [];
      const normalized = Array.from(new Set(matches.map((m) => m.toLowerCase())));
      logger.debug(`Found ${normalized.length} models for ${providerName}`, "AIService", {
        models: normalized.slice(0, 5)
        // Log first 5 for debugging
      });
      return normalized;
    } catch (error) {
      logger.error(`Error fetching models for ${providerName}`, "AIService", {
        error: error instanceof Error ? error.message : String(error),
        providerName
      });
      return PROVIDER_MODEL_OPTIONS[providerName] ? PROVIDER_MODEL_OPTIONS[providerName].map((m) => typeof m === "string" ? m : m.name) : [];
    }
  }
  /**
   * Process prompt with fallback support (original sequential method)
   */
  async process(prompt, images) {
    if (!prompt || typeof prompt !== "string") {
      throw new Error("Valid prompt is required");
    }
    if (this.settings.enableParallelProcessing) {
      return this.processParallel(prompt, images);
    }
    return this.processSequential(prompt, images);
  }
  /**
   * Process prompt with sequential fallback (original method)
   */
  async processSequential(prompt, images) {
    let lastError = null;
    for (const provider of this.providers) {
      try {
        logger.info(`Attempting to process with ${provider.name}`, "AIService", {
          model: provider.model
        });
        let content;
        if (images && images.length > 0 && provider.processWithImage) {
          content = await RetryService.withRetry(
            () => provider.processWithImage(prompt, images),
            `${provider.name}-process-multimodal`,
            2,
            // 2 attempts per provider
            2e3
            // 2 second base delay
          );
        } else {
          content = await RetryService.withRetry(
            () => provider.process(prompt),
            `${provider.name}-process`,
            2,
            // 2 attempts per provider
            2e3
            // 2 second base delay
          );
        }
        if (content && content.trim().length > 0) {
          logger.info(`Successfully processed with ${provider.name}`, "AIService", {
            model: provider.model,
            contentLength: content.length
          });
          return {
            content,
            provider: provider.name,
            model: provider.model
          };
        } else {
          throw new Error("Empty response from AI provider");
        }
      } catch (error) {
        lastError = error;
        logger.warn(`${provider.name} failed`, "AIService", {
          error: error instanceof Error ? error.message : String(error),
          model: provider.model
        });
        if (provider === this.providers[this.providers.length - 1]) {
          break;
        }
      }
    }
    const errorMessage = lastError ? MESSAGES.ERRORS.AI_PROCESSING(lastError.message) : "All AI providers failed to process the request";
    throw new Error(errorMessage);
  }
  /**
   * Process prompt with parallel provider racing for maximum speed
   */
  async processParallel(prompt, images) {
    console.log("Starting parallel provider racing...");
    const providerPromises = this.providers.map(async (provider) => {
      try {
        let content;
        if (images && images.length > 0 && provider.processWithImage) {
          content = await provider.processWithImage(prompt, images);
        } else {
          content = await provider.process(prompt);
        }
        if (content && content.trim().length > 0) {
          return {
            content,
            provider: provider.name,
            model: provider.model,
            success: true,
            responseTime: Date.now()
          };
        } else {
          throw new Error("Empty response from AI provider");
        }
      } catch (error) {
        console.warn(`${provider.name} failed in parallel race:`, error);
        return {
          error: error.message,
          provider: provider.name,
          model: provider.model,
          success: false,
          responseTime: Date.now()
        };
      }
    });
    const results = await Promise.allSettled(providerPromises);
    for (const result of results) {
      if (result.status === "fulfilled" && result.value.success) {
        console.log(`Parallel winner: ${result.value.provider} (${Date.now() - result.value.responseTime}ms)`);
        return {
          content: result.value.content,
          provider: result.value.provider,
          model: result.value.model
        };
      }
    }
    const errors = results.filter((r) => r.status === "fulfilled" && !r.value.success).map((r) => r.value.error);
    const errorMessage = errors.length > 0 ? MESSAGES.ERRORS.AI_PROCESSING(errors.join("; ")) : "All AI providers failed to process the request";
    throw new Error(errorMessage);
  }
  /**
   * Process prompt using a specific provider name. Optionally override the model if supported.
   */
  async processWith(providerName, prompt, overrideModel, images) {
    const provider = this.providers.find((p) => p.name === providerName);
    if (!provider) {
      throw new Error(`AI provider not found: ${providerName}`);
    }
    try {
      if (overrideModel && typeof provider.setModel === "function") {
        provider.setModel(overrideModel);
      }
      let content;
      if (images && images.length > 0 && provider.processWithImage) {
        content = await provider.processWithImage(prompt, images);
      } else {
        content = await provider.process(prompt);
      }
      if (content && content.trim().length > 0) {
        return { content, provider: provider.name, model: provider.model };
      }
      throw new Error("Empty response from AI provider");
    } catch (error) {
      throw new Error(MESSAGES.ERRORS.AI_PROCESSING(error.message));
    }
  }
  /**
   * Check if any providers are available
   */
  hasAvailableProviders() {
    return this.providers.length > 0;
  }
  /**
   * Get list of available provider names
   */
  getProviderNames() {
    return this.providers.map((p) => p.name);
  }
  /**
   * Add a new provider
   */
  addProvider(provider) {
    this.providers.push(provider);
  }
  /**
   * Remove a provider by name
   */
  removeProvider(providerName) {
    const index = this.providers.findIndex((p) => p.name === providerName);
    if (index !== -1) {
      this.providers.splice(index, 1);
      return true;
    }
    return false;
  }
};

// src/gemini.ts
init_api();

// src/base.ts
var BaseAIProvider = class {
  constructor(apiKey, initialModel, timeout) {
    this.apiKey = apiKey;
    this._timeout = 3e4;
    // Default 30s timeout
    this._maxTokens = 2048;
    // Default max tokens
    this._temperature = 0.7;
    if (!apiKey) {
      throw new Error("API key is required for AI provider");
    }
    this._model = initialModel || "";
    if (timeout) {
      this._timeout = timeout;
    }
  }
  // Default temperature
  get model() {
    return this._model;
  }
  get timeout() {
    return this._timeout;
  }
  get maxTokens() {
    return this._maxTokens;
  }
  get temperature() {
    return this._temperature;
  }
  setModel(model) {
    this._model = model;
  }
  setTimeout(timeout) {
    this._timeout = timeout;
  }
  setMaxTokens(maxTokens) {
    this._maxTokens = maxTokens;
  }
  setTemperature(temperature) {
    this._temperature = temperature;
  }
  /**
   * Process with timeout support
   */
  async processWithTimeout(prompt, customTimeout) {
    const timeoutMs = customTimeout || this._timeout;
    const timeoutPromise = new Promise((_, reject) => {
      setTimeout(() => {
        reject(new Error(`${this.name} request timed out after ${timeoutMs}ms`));
      }, timeoutMs);
    });
    const processPromise = this.process(prompt);
    return Promise.race([processPromise, timeoutPromise]);
  }
  /**
   * Validate API response structure
   */
  validateResponse(response, requiredPath) {
    let current = response;
    for (const key of requiredPath) {
      if (!current || typeof current !== "object" || !(key in current)) {
        return false;
      }
      current = current[key];
    }
    return current !== null && current !== void 0;
  }
  /**
   * Safely parse JSON response without throwing
   */
  async safeJsonParse(response) {
    try {
      return await response.json();
    } catch (e) {
      return null;
    }
  }
  /**
   * Handle API errors consistently
   */
  async handleAPIError(response) {
    return ErrorHandler.handleAPIError(response, this.name);
  }
};

// src/gemini.ts
var GeminiProvider = class extends BaseAIProvider {
  constructor(apiKey, model, timeout) {
    super(apiKey, model || AI_MODELS.GEMINI, timeout);
    this.name = "Google Gemini";
  }
  async process(prompt) {
    var _a, _b;
    try {
      if (!this.apiKey || this.apiKey.trim().length === 0) {
        throw new Error(MESSAGES.ERRORS.GEMINI_INVALID_KEY);
      }
      const response = await fetch(`${API_ENDPOINTS.GEMINI}?key=${this.apiKey}`, {
        method: "POST",
        headers: this.createHeaders(),
        body: JSON.stringify(this.createRequestBody(prompt))
      });
      if (response.status === 400) {
        const errorData = await this.safeJsonParse(response);
        const errorMessage = ((_a = errorData == null ? void 0 : errorData.error) == null ? void 0 : _a.message) || "Bad request";
        throw new Error(`Gemini API error: ${errorMessage}. Try checking the model configuration.`);
      }
      if (response.status === 401) {
        throw new Error(MESSAGES.ERRORS.GEMINI_INVALID_KEY);
      }
      if (response.status === 403) {
        throw new Error("Gemini API quota exceeded or billing required. Please check your plan and billing details.");
      }
      if (response.status === 429) {
        try {
          const errorData = await response.json();
          const errorMessage = ((_b = errorData.error) == null ? void 0 : _b.message) || errorData.message || "";
          if (errorMessage.toLowerCase().includes("quota")) {
            throw new Error(`Gemini API quota exceeded: ${errorMessage}. Please check your plan and billing details.`);
          } else if (errorMessage.toLowerCase().includes("rate")) {
            throw new Error(`Gemini API rate limit exceeded: ${errorMessage}. Please wait a moment and try again.`);
          } else {
            throw new Error(`Gemini API rate limit exceeded. Please wait and try again.`);
          }
        } catch (e) {
          throw new Error("Gemini API rate limit exceeded. Please wait and try again.");
        }
      }
      if (!response.ok) {
        await this.handleAPIError(response);
      }
      const data = await response.json();
      if (!data.candidates || !data.candidates.length) {
        throw new Error("No response candidates returned from Gemini API");
      }
      if (data.candidates[0].finishReason === "SAFETY") {
        throw new Error("Response blocked by Gemini safety filters. Try rephrasing.");
      }
      if (!this.validateResponse(data, ["candidates", "0", "content", "parts", "0", "text"])) {
        throw new Error("Invalid response format from Gemini API");
      }
      return this.extractContent(data);
    } catch (error) {
      if (error instanceof Error) {
        throw error;
      }
      throw new Error(`Gemini processing failed: ${error}`);
    }
  }
  createHeaders() {
    return {
      "Content-Type": "application/json"
    };
  }
  createRequestBody(prompt) {
    const normalizedPrompt = prompt.toLowerCase();
    const isVideoAnalysis = normalizedPrompt.includes("youtube video") || normalizedPrompt.includes("youtu.be/") || normalizedPrompt.includes("youtube.com/");
    const baseConfig = {
      contents: [{
        parts: [{ text: prompt }]
      }],
      generationConfig: {
        temperature: this._temperature,
        maxOutputTokens: this._maxTokens,
        candidateCount: 1
      }
      // safetySettings: [
      //     {
      //         category: "HARM_CATEGORY_HARASSMENT",
      //         threshold: "BLOCK_MEDIUM_AND_ABOVE"
      //     },
      //     {
      //         category: "HARM_CATEGORY_HATE_SPEECH", 
      //         threshold: "BLOCK_MEDIUM_AND_ABOVE"
      //     }
      // ]
    };
    if (isVideoAnalysis) {
      const providerModels = PROVIDER_MODEL_OPTIONS["Google Gemini"] || [];
      const currentModelName = String(this.model || "").toLowerCase();
      const matched = providerModels.find((m) => {
        const name = typeof m === "string" ? m : m && m.name ? m.name : "";
        return String(name).toLowerCase() === currentModelName;
      });
      const supportsAudioVideo = matched && matched.supportsAudioVideo === true;
      const videoConfig = {
        ...baseConfig,
        systemInstruction: {
          parts: [{
            text: `You are an expert video content analyzer. Provide comprehensive, multimodal analysis using:
\u2022 AUDIO STREAM: Transcribe all spoken content, identify speakers, capture tone/emphasis/emotion
\u2022 VIDEO STREAM: Analyze visual elements, text overlays, diagrams, slides, gestures, scene changes, and visual demonstrations
\u2022 INTEGRATED INSIGHTS: Synthesize audio and visual data to provide complete understanding

For best results:
- Prioritize accuracy in transcription and speaker identification
- Extract and explain key concepts shown visually
- Note timing relationships between audio and visual elements
- Identify visual cues that reinforce or clarify spoken content`
          }]
        }
      };
      const gcsMatch = prompt.match(/(gs:\/\/[\w\-\.\/]+\.(?:mp4|mov|mkv|webm))/i);
      if (gcsMatch && gcsMatch[1]) {
        const gcsUri = gcsMatch[1];
        videoConfig.contents = videoConfig.contents || [];
        videoConfig.contents.push({
          parts: [{ fileData: { fileUri: gcsUri, mimeType: "video/mp4" } }]
        });
      }
      return videoConfig;
    }
    return baseConfig;
  }
  extractContent(response) {
    const content = response.candidates[0].content.parts[0].text;
    return content ? content.trim() : "";
  }
};

// src/groq.ts
init_api();
var GroqProvider = class extends BaseAIProvider {
  constructor(apiKey, model, timeout) {
    super(apiKey, model || AI_MODELS.GROQ, timeout);
    this.name = "Groq";
  }
  async process(prompt) {
    var _a;
    const response = await fetch(API_ENDPOINTS.GROQ, {
      method: "POST",
      headers: this.createHeaders(),
      body: JSON.stringify(this.createRequestBody(prompt))
    });
    if (response.status === 401) {
      throw new Error("Groq API key is invalid or missing. Please check your key.");
    }
    if (response.status === 402) {
      throw new Error("Groq API requires a paid plan. Please check your billing settings.");
    }
    if (response.status === 404) {
      throw new Error(MESSAGES.ERRORS.GROQ_MODEL_NOT_FOUND);
    }
    if (response.status === 429) {
      try {
        const errorData = await response.json();
        const errorMessage = ((_a = errorData.error) == null ? void 0 : _a.message) || errorData.message || "";
        if (errorMessage.toLowerCase().includes("quota")) {
          throw new Error(`Groq API quota exceeded: ${errorMessage}. Please check your plan and billing details.`);
        } else if (errorMessage.toLowerCase().includes("rate")) {
          throw new Error(`Groq API rate limit exceeded: ${errorMessage}. Please wait a moment and try again.`);
        } else {
          throw new Error("Groq API rate limit exceeded. Please wait and try again.");
        }
      } catch (e) {
        throw new Error("Groq API rate limit exceeded. Please wait and try again.");
      }
    }
    if (!response.ok) {
      await this.handleAPIError(response);
    }
    const data = await response.json();
    if (!this.validateResponse(data, ["choices", "0", "message"])) {
      throw new Error("Invalid response format from Groq API");
    }
    return this.extractContent(data);
  }
  createHeaders() {
    return {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${this.apiKey}`
    };
  }
  createRequestBody(prompt) {
    return {
      model: this.model,
      messages: [
        {
          role: "system",
          content: "You are an expert content analyzer specializing in extracting practical value and creating actionable guides from video content. Focus on clarity, practicality, and immediate implementability. Even with limited information, provide maximum value through structured analysis and practical recommendations."
        },
        {
          role: "user",
          content: prompt
        }
      ],
      max_tokens: this._maxTokens,
      temperature: this._temperature
    };
  }
  extractContent(response) {
    const content = response.choices[0].message.content;
    return content ? content.trim() : "";
  }
};

// src/ollama.ts
var OllamaProvider = class extends BaseAIProvider {
  constructor(apiKey = "", model, timeout, endpoint) {
    super(apiKey, model || "qwen3-coder:480b-cloud", timeout);
    this.name = "Ollama";
    this.ollamaEndpoint = endpoint || "http://localhost:11434";
    this.apiKey = apiKey || void 0;
  }
  async process(prompt) {
    try {
      if (!prompt || prompt.trim().length === 0) {
        throw new Error("Prompt cannot be empty");
      }
      const requestBody = {
        model: this._model,
        prompt,
        stream: false,
        options: {
          temperature: this._temperature,
          num_predict: this._maxTokens
        }
      };
      const response = await fetch(`${this.ollamaEndpoint}/api/generate`, {
        method: "POST",
        headers: this.createHeaders(),
        body: JSON.stringify(requestBody)
      });
      if (!response.ok) {
        if (response.status === 404) {
          throw new Error(`Ollama model not found: ${this._model}. Please make sure the model is pulled in Ollama using 'ollama pull ${this._model}'.`);
        }
        if (response.status === 500) {
          const errorData = await this.safeJsonParse(response);
          const errorMessage = (errorData == null ? void 0 : errorData.error) || "Ollama server error";
          throw new Error(`Ollama error: ${errorMessage}`);
        }
        throw new Error(`Ollama API error: ${response.status} - ${response.statusText}`);
      }
      const data = await response.json();
      if (!this.validateResponse(data, ["response"])) {
        throw new Error("Invalid response format from Ollama API");
      }
      return this.extractContent(data);
    } catch (error) {
      if (error instanceof Error) {
        if (error.message.includes("fetch") || error.message.includes("network") || error.message.includes("ECONNREFUSED") || error.message.includes("ENOTFOUND")) {
          throw new Error("Ollama server is not running or unreachable. Please ensure Ollama is installed and running on your system.");
        }
        throw error;
      }
      throw new Error(`Ollama processing failed: ${error}`);
    }
  }
  /**
   * Process with image support for multimodal models
   * Note: This is prepared for potential image processing, though it would require special handling in browser
   */
  async processWithImage(prompt, images) {
    try {
      if (!prompt || prompt.trim().length === 0) {
        throw new Error("Prompt cannot be empty");
      }
      const messages = [
        { role: "user", content: prompt }
      ];
      if (images && images.length > 0) {
        const processedImages = [];
        for (const img of images) {
          if (typeof img === "string") {
            processedImages.push(img);
          } else if (img instanceof ArrayBuffer) {
            const bytes = new Uint8Array(img);
            let binary = "";
            for (let i = 0; i < bytes.length; i++) {
              binary += String.fromCharCode(bytes[i]);
            }
            const base64 = btoa(binary);
            processedImages.push(base64);
          }
        }
        if (processedImages.length > 0) {
          messages[0].images = processedImages;
        }
      }
      const requestBody = {
        model: this._model,
        messages,
        stream: false,
        options: {
          temperature: this._temperature,
          num_predict: this._maxTokens
        }
      };
      const response = await fetch(`${this.ollamaEndpoint}/api/chat`, {
        method: "POST",
        headers: this.createHeaders(),
        body: JSON.stringify(requestBody)
      });
      if (!response.ok) {
        if (response.status === 404) {
          throw new Error(`Ollama model not found: ${this._model}. Please make sure the model is pulled in Ollama using 'ollama pull ${this._model}'.`);
        }
        if (response.status === 500) {
          const errorData = await this.safeJsonParse(response);
          const errorMessage = (errorData == null ? void 0 : errorData.error) || "Ollama server error";
          throw new Error(`Ollama error: ${errorMessage}`);
        }
        throw new Error(`Ollama API error: ${response.status} - ${response.statusText}`);
      }
      const data = await response.json();
      if (!this.validateResponse(data, ["message", "content"])) {
        throw new Error("Invalid response format from Ollama API");
      }
      return this.extractContentFromChat(data);
    } catch (error) {
      if (error instanceof Error) {
        if (error.message.includes("fetch") || error.message.includes("network") || error.message.includes("ECONNREFUSED") || error.message.includes("ENOTFOUND")) {
          throw new Error("Ollama server is not running or unreachable. Please ensure Ollama is installed and running on your system.");
        }
        throw error;
      }
      throw new Error(`Ollama processing failed: ${error}`);
    }
  }
  /**
   * Check if Ollama server is accessible
   */
  async checkAvailability() {
    try {
      const response = await fetch(`${this.ollamaEndpoint}/api/tags`, {
        method: "GET",
        headers: this.createHeaders()
      });
      return response.ok;
    } catch (error) {
      return false;
    }
  }
  /**
   * Check if a specific model is available in Ollama
   */
  async checkModelAvailability(modelName) {
    try {
      const response = await fetch(`${this.ollamaEndpoint}/api/tags`, {
        method: "GET",
        headers: this.createHeaders()
      });
      if (!response.ok) {
        return false;
      }
      const data = await response.json();
      if (!data || !data.models) {
        return false;
      }
      return data.models.some(
        (model) => model.name === modelName || model.name.startsWith(`${modelName}:`) || model.id && model.id.includes(modelName)
      );
    } catch (error) {
      return false;
    }
  }
  createHeaders() {
    const headers = {
      "Content-Type": "application/json"
    };
    if (this.apiKey) {
      headers["Authorization"] = `Bearer ${this.apiKey}`;
    }
    return headers;
  }
  createRequestBody(prompt) {
    return {};
  }
  extractContent(response) {
    if (response && typeof response === "object" && "response" in response) {
      return response.response.trim();
    }
    return "";
  }
  extractContentFromChat(response) {
    if (response && typeof response === "object" && response.message && "content" in response.message) {
      return response.message.content.trim();
    }
    return "";
  }
};

// src/video-data.ts
init_api();

// src/services/transcript-service.ts
init_api();
var YouTubeTranscriptService = class {
  // 1 hour
  constructor(cache) {
    this.cache = cache;
    this.transcriptTTL = 1e3 * 60 * 60;
  }
  /**
   * Extract transcript for a YouTube video
   */
  async getTranscript(videoId) {
    var _a, _b;
    if (!videoId) {
      throw new Error("Video ID is required");
    }
    const cacheKey = `transcript-${videoId}`;
    const cached = (_a = this.cache) == null ? void 0 : _a.get(cacheKey);
    if (cached) {
      return cached;
    }
    try {
      const transcript = await this.fetchTranscriptWithFallback(videoId);
      if (transcript) {
        (_b = this.cache) == null ? void 0 : _b.set(cacheKey, transcript, this.transcriptTTL);
        return transcript;
      }
      return null;
    } catch (error) {
      console.warn("Failed to fetch transcript:", error);
      return null;
    }
  }
  /**
   * Fetch transcript using multiple methods with fallback
   */
  async fetchTranscriptWithFallback(videoId) {
    try {
      const transcript = await this.fetchFromYouTubeAPI(videoId);
      if (transcript)
        return transcript;
    } catch (error) {
      console.debug("YouTube API method failed:", error);
    }
    try {
      const transcript = await this.scrapeTranscriptFromPage(videoId);
      if (transcript)
        return transcript;
    } catch (error) {
      console.debug("Page scraping method failed:", error);
    }
    try {
      const transcript = await this.fetchFromThirdParty(videoId);
      if (transcript)
        return transcript;
    } catch (error) {
      console.debug("Third-party method failed:", error);
    }
    return null;
  }
  /**
   * Method 1: Official YouTube transcript API
   */
  async fetchFromYouTubeAPI(videoId) {
    const url = `https://video.google.com/timedtext?lang=en&v=${videoId}`;
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`Transcript API failed: ${response.status}`);
    }
    const xmlText = await response.text();
    return this.parseXMLTranscript(xmlText, videoId);
  }
  /**
   * Method 2: Scrape transcript from YouTube page
   */
  async scrapeTranscriptFromPage(videoId) {
    const videoUrl = `https://www.youtube.com/watch?v=${videoId}`;
    const proxyUrl = `${API_ENDPOINTS.CORS_PROXY}?url=${encodeURIComponent(videoUrl)}`;
    const response = await fetch(proxyUrl);
    if (!response.ok) {
      throw new Error("Failed to fetch video page");
    }
    const html = await response.text();
    const transcriptData = await this.extractTranscriptFromHTML(html);
    if (transcriptData) {
      return this.createTranscript(transcriptData, videoId, true);
    }
    return null;
  }
  /**
   * Method 3: Third-party transcript service (optional)
   */
  async fetchFromThirdParty(videoId) {
    return null;
  }
  /**
   * Parse XML transcript from YouTube API
   */
  parseXMLTranscript(xmlText, videoId) {
    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(xmlText, "text/xml");
    const textElements = xmlDoc.getElementsByTagName("text");
    const segments = [];
    let fullText = "";
    for (let i = 0; i < textElements.length; i++) {
      const element = textElements[i];
      const text = element.textContent || "";
      const start = parseFloat(element.getAttribute("start") || "0");
      const duration = parseFloat(element.getAttribute("dur") || "0");
      if (text.trim()) {
        segments.push({ text: text.trim(), start, duration });
        fullText += text.trim() + " ";
      }
    }
    return {
      segments,
      fullText: fullText.trim(),
      language: "en",
      autoGenerated: true
    };
  }
  /**
   * Extract transcript data from YouTube page HTML
   */
  async extractTranscriptFromHTML(html) {
    const transcriptRegex = /"captions":\s*{[^}]*"playerCaptionsTracklistRenderer":\s*{[^}]*"captionTracks":\s*\[([^\]]+)\]/;
    const match = html.match(transcriptRegex);
    if (!match || !match[1]) {
      return null;
    }
    try {
      const captionTracksJson = match[1];
      const captionTracks = JSON.parse(`[${captionTracksJson}]`);
      const englishTrack = captionTracks.find(
        (track) => {
          var _a;
          return track.languageCode === "en" || ((_a = track.languageCode) == null ? void 0 : _a.startsWith("en"));
        }
      );
      if (!englishTrack || !englishTrack.baseUrl) {
        return null;
      }
      return fetch(englishTrack.baseUrl).then((resp) => {
        if (!resp.ok)
          throw new Error("Failed to fetch caption track");
        return resp.text();
      }).then((xmlText) => this.parseXMLTranscript(xmlText, "").segments).catch((err) => {
        console.debug("Failed to fetch caption track:", err);
        return null;
      });
    } catch (error) {
      console.debug("Failed to parse transcript from HTML:", error);
      return null;
    }
  }
  /**
   * Create transcript object from segments
   */
  createTranscript(segments, videoId, autoGenerated = false) {
    if (!Array.isArray(segments)) {
      segments = [segments];
    }
    const normalizedSegments = segments.map((seg) => ({
      text: seg.text,
      start: seg.start,
      duration: seg.duration || 0
    }));
    const fullText = normalizedSegments.map((seg) => seg.text).join(" ").trim();
    return {
      segments: normalizedSegments,
      fullText,
      language: "en",
      autoGenerated
    };
  }
  /**
   * Get transcript summary for quick analysis
   */
  async getTranscriptSummary(videoId, maxLength = 2e3) {
    const transcript = await this.getTranscript(videoId);
    if (!transcript) {
      return null;
    }
    if (transcript.fullText.length <= maxLength) {
      return transcript.fullText;
    }
    const keySegments = transcript.segments.filter((seg) => seg.text.length > 20).slice(0, 10).map((seg) => seg.text).join(" ");
    return keySegments.length > maxLength ? keySegments.substring(0, maxLength) + "..." : keySegments;
  }
  /**
   * Extract key time-stamped moments from transcript
   */
  async extractKeyMoments(videoId, count = 5) {
    const transcript = await this.getTranscript(videoId);
    if (!transcript || transcript.segments.length === 0) {
      return null;
    }
    const meaningfulSegments = transcript.segments.filter((seg) => seg.text.length > 30);
    if (meaningfulSegments.length === 0) {
      return null;
    }
    const totalSegments = meaningfulSegments.length;
    const step = Math.max(1, Math.floor(totalSegments / count));
    const keyMoments = [];
    for (let i = 0; i < totalSegments && keyMoments.length < count; i += step) {
      const segment = meaningfulSegments[i];
      keyMoments.push({
        time: segment.start,
        text: segment.text
      });
    }
    return keyMoments;
  }
  /**
   * Check if transcript is available for a video
   */
  async isTranscriptAvailable(videoId) {
    const transcript = await this.getTranscript(videoId);
    return transcript !== null && transcript.segments.length > 0;
  }
};

// src/video-data.ts
var YouTubeVideoService = class {
  constructor(cache) {
    this.cache = cache;
    this.metadataTTL = 1e3 * 60 * 30;
    // 30 minutes
    this.descriptionTTL = 1e3 * 60 * 30;
    this.transcriptService = new YouTubeTranscriptService(cache);
  }
  /**
   * Extract video ID from YouTube URL
   */
  extractVideoId(url) {
    return ValidationUtils.extractVideoId(url);
  }
  /**
   * Get video metadata and description
   */
  async getVideoData(videoId) {
    var _a, _b;
    if (!videoId) {
      throw new Error("Video ID is required");
    }
    const cacheKey = this.getCacheKey("video-data", videoId);
    const cached = (_a = this.cache) == null ? void 0 : _a.get(cacheKey);
    if (cached) {
      return cached;
    }
    try {
      const metadata = await this.getVideoMetadata(videoId);
      const result = {
        title: metadata.title || "Unknown Title",
        description: metadata.description || "No description available",
        duration: metadata.duration,
        thumbnail: metadata.thumbnail,
        channelName: metadata.channelName
      };
      if (result.duration && result.duration < 1800) {
        this.checkTranscriptAvailability(videoId).then((hasTranscript) => {
          var _a2;
          result.hasTranscript = hasTranscript;
          (_a2 = this.cache) == null ? void 0 : _a2.set(cacheKey, result, this.metadataTTL);
        });
      }
      (_b = this.cache) == null ? void 0 : _b.set(cacheKey, result, this.metadataTTL);
      return result;
    } catch (error) {
      throw ErrorHandler.createUserFriendlyError(
        error,
        "fetch video data"
      );
    }
  }
  /**
   * Get video metadata using YouTube oEmbed API
   */
  async getVideoMetadata(videoId) {
    var _a, _b;
    const cacheKey = this.getCacheKey("metadata", videoId);
    const cached = (_a = this.cache) == null ? void 0 : _a.get(cacheKey);
    if (cached) {
      return cached;
    }
    const oembedUrl = `${API_ENDPOINTS.YOUTUBE_OEMBED}?url=https://www.youtube.com/watch?v=${videoId}&format=json`;
    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 1e4);
      const response = await fetch(oembedUrl, {
        headers: {
          "User-Agent": "Obsidian YoutubeClipper Plugin"
        },
        signal: controller.signal
      });
      clearTimeout(timeoutId);
      if (!response.ok) {
        if (response.status === 400) {
          throw new Error(`Invalid YouTube video ID: ${videoId}. Please check the URL and try again.`);
        } else if (response.status === 404) {
          throw new Error(`YouTube video not found: ${videoId}. The video may be private, deleted, or the ID is incorrect.`);
        } else if (response.status === 403) {
          throw new Error(`Access denied to YouTube video: ${videoId}. The video may be private or restricted.`);
        } else {
          throw new Error(MESSAGES.ERRORS.FETCH_VIDEO_DATA(response.status));
        }
      }
      const data = await response.json();
      let enhancedData = {
        title: data.title || "Unknown Title",
        thumbnail: data.thumbnail_url,
        author_name: data.author_name
      };
      try {
        const pageData = await this.scrapeAdditionalMetadata(videoId);
        enhancedData = { ...enhancedData, ...pageData };
      } catch (error) {
        console.debug("Could not scrape additional metadata:", error);
      }
      const metadata = {
        title: enhancedData.title,
        description: enhancedData.description,
        duration: enhancedData.duration,
        thumbnail: enhancedData.thumbnail,
        channelName: enhancedData.author_name
      };
      (_b = this.cache) == null ? void 0 : _b.set(cacheKey, metadata, this.metadataTTL);
      return metadata;
    } catch (error) {
      if (error instanceof DOMException && error.name === "AbortError") {
        throw new Error("Request timed out. Please check your internet connection and try again.");
      } else if (error instanceof TypeError) {
        throw new Error(MESSAGES.ERRORS.NETWORK_ERROR);
      } else if (error instanceof Error && error.message.includes("JSON")) {
        throw new Error("Failed to parse YouTube response. The service may be temporarily unavailable.");
      }
      throw error;
    }
  }
  /**
   * Scrape additional metadata from YouTube page
   */
  async scrapeAdditionalMetadata(videoId) {
    try {
      const html = await this.fetchVideoPageHTML(videoId);
      const durationMatch = html.match(/"lengthSeconds":"(\d+)"/);
      const duration = durationMatch ? parseInt(durationMatch[1]) : void 0;
      const descriptionMatch = html.match(/"shortDescription":"([^"]+)"/);
      const description = descriptionMatch ? descriptionMatch[1].replace(/\\u0026/g, "&").replace(/\\n/g, "\n") : void 0;
      return { description, duration };
    } catch (error) {
      return {};
    }
  }
  /**
   * Check if transcript is available for this video
   */
  async checkTranscriptAvailability(videoId) {
    try {
      return await this.transcriptService.isTranscriptAvailable(videoId);
    } catch (error) {
      return false;
    }
  }
  /**
   * Get video description by scraping the YouTube page
   */
  async getVideoDescription(videoId) {
    var _a, _b, _c;
    const cacheKey = this.getCacheKey("description", videoId);
    const cached = (_a = this.cache) == null ? void 0 : _a.get(cacheKey);
    if (cached) {
      return cached;
    }
    try {
      const html = await this.fetchVideoPageHTML(videoId);
      const description = this.extractDescriptionFromHTML(html);
      (_b = this.cache) == null ? void 0 : _b.set(cacheKey, description, this.descriptionTTL);
      return description;
    } catch (error) {
      console.warn("Failed to scrape video page:", error);
      const fallback = MESSAGES.WARNINGS.EXTRACTION_FAILED;
      (_c = this.cache) == null ? void 0 : _c.set(cacheKey, fallback, this.descriptionTTL);
      return fallback;
    }
  }
  /**
   * Fetch YouTube page HTML using CORS proxy
   */
  async fetchVideoPageHTML(videoId) {
    const videoUrl = `https://www.youtube.com/watch?v=${videoId}`;
    const proxyUrl = `${API_ENDPOINTS.CORS_PROXY}?url=${encodeURIComponent(videoUrl)}`;
    const response = await fetch(proxyUrl);
    if (!response.ok) {
      throw new Error(MESSAGES.WARNINGS.CORS_RESTRICTIONS);
    }
    return response.text();
  }
  /**
   * Extract description from YouTube page HTML
   */
  extractDescriptionFromHTML(html) {
    const patterns = [
      /"shortDescription":"([^"]*?)"/,
      /"description":{"simpleText":"([^"]*?)"}/,
      /<meta name="description" content="([^"]*?)">/,
      /<meta property="og:description" content="([^"]*?)">/
    ];
    for (const pattern of patterns) {
      const match = html.match(pattern);
      if (match && match[1]) {
        const cleanedText = ValidationUtils.cleanText(match[1]);
        return ValidationUtils.truncateText(cleanedText, API_LIMITS.DESCRIPTION_MAX_LENGTH);
      }
    }
    return MESSAGES.WARNINGS.AUTO_EXTRACTION;
  }
  /**
   * Validate YouTube URL and extract video ID
   */
  validateAndExtractVideoId(url) {
    if (!ValidationUtils.isValidYouTubeUrl(url)) {
      throw new Error(MESSAGES.ERRORS.INVALID_URL);
    }
    const videoId = this.extractVideoId(url);
    if (!videoId) {
      throw new Error(MESSAGES.ERRORS.INVALID_URL);
    }
    return videoId;
  }
  getCacheKey(namespace, videoId) {
    return `youtube-video-service:${namespace}:${videoId}`;
  }
};

// src/obsidian-file.ts
var import_obsidian7 = require("obsidian");
init_api();

// src/file-conflict-modal.ts
init_base_modal();
var COPY_WARNING = "A note with this title already exists. Choose how to proceed.";
var FileConflictModal = class extends BaseModal {
  constructor(app, file) {
    super(app);
    this.file = file;
    this.decision = "cancel";
  }
  onOpen() {
    this.createHeader("Note Already Exists");
    this.createMessage(`${COPY_WARNING}

Existing note: ${this.file.path}`);
    this.createButtons();
  }
  openAndWait() {
    return new Promise((resolve) => {
      this.resolve = resolve;
      this.forceVisible();
      this.open();
    });
  }
  onClose() {
    if (this.resolve) {
      this.resolve(this.decision);
    }
    super.onClose();
  }
  createButtons() {
    const container = this.createButtonContainer();
    this.createButton(container, "Cancel", false, () => {
      this.closeWithDecision("cancel");
    });
    this.createButton(container, "Save as Numbered Copy", false, () => {
      this.closeWithDecision("new-name");
    });
    this.createButton(container, "Overwrite Existing", true, () => {
      this.closeWithDecision("overwrite");
    });
  }
  closeWithDecision(decision) {
    this.decision = decision;
    this.close();
  }
};

// src/obsidian-file.ts
var ObsidianFileService = class {
  constructor(app) {
    this.app = app;
  }
  /**
   * Save content to a file in the vault
   */
  async saveToFile(title, content, outputPath) {
    try {
      const filename = this.createSafeFilename(title);
      const normalizedBase = this.normalizePath(outputPath);
      await this.ensureDirectoryExists(normalizedBase);
      const dailyFolder = this.getDailyFolderPath(normalizedBase);
      await this.ensureDirectoryExists(dailyFolder);
      const filePath = `${dailyFolder}/${filename}`;
      const finalPath = await this.handleFileConflicts(filePath, content);
      return finalPath;
    } catch (error) {
      throw new Error(MESSAGES.ERRORS.SAVE_FILE(error.message));
    }
  }
  /**
   * Open a file with user confirmation
   */
  async openFileWithConfirmation(file) {
    await this.waitForFileCreation();
    try {
      const currentFile = this.app.vault.getAbstractFileByPath(file.path);
      if (!(currentFile instanceof import_obsidian7.TFile)) {
        throw new Error(MESSAGES.ERRORS.FILE_NOT_EXISTS);
      }
      const leaf = this.app.workspace.getLeaf(false);
      await leaf.openFile(currentFile);
    } catch (error) {
      throw new Error(MESSAGES.ERRORS.COULD_NOT_OPEN(error.message));
    }
  }
  /**
   * Create a safe filename from title
   */
  createSafeFilename(title) {
    const sanitized = ValidationUtils.sanitizeFilename(title);
    return `${sanitized}.md`;
  }
  /**
   * Ensure the output directory exists
   */
  async ensureDirectoryExists(outputPath) {
    try {
      await this.app.vault.createFolder(outputPath);
    } catch (error) {
    }
  }
  getDailyFolderPath(basePath) {
    const trimmedBase = basePath.replace(/\/+$/, "");
    const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
    return `${trimmedBase}/${today}`;
  }
  /**
   * Handle file naming conflicts by adding timestamp
   */
  async handleFileConflicts(filePath, content) {
    const existingFile = this.app.vault.getAbstractFileByPath(filePath);
    if (existingFile instanceof import_obsidian7.TFile) {
      const decision = await this.promptConflictResolution(existingFile);
      switch (decision) {
        case "overwrite":
          await this.app.vault.modify(existingFile, content);
          return existingFile.path;
        case "new-name":
          return this.createVersionedCopy(existingFile.path, content);
        default:
          throw new Error("Save cancelled by user");
      }
    }
    await this.app.vault.create(filePath, content);
    return filePath;
  }
  /**
   * Wait for file creation to complete
   */
  async waitForFileCreation() {
    return new Promise(
      (resolve) => setTimeout(resolve, TIMEOUTS.FILE_CREATION_WAIT)
    );
  }
  /**
   * Get file by path with validation
   */
  getFileByPath(filePath) {
    const file = this.app.vault.getAbstractFileByPath(filePath);
    return file instanceof import_obsidian7.TFile ? file : null;
  }
  /**
   * Check if file exists at path
   */
  fileExists(filePath) {
    return this.getFileByPath(filePath) !== null;
  }
  /**
   * Create a file with unique naming
   */
  async createUniqueFile(basePath, content) {
    let counter = 1;
    let filePath = basePath;
    while (this.fileExists(filePath)) {
      const pathParts = basePath.split("/");
      const filename = pathParts.pop();
      const nameWithoutExt = filename.replace(".md", "");
      const newFilename = `${nameWithoutExt} (${counter}).md`;
      filePath = [...pathParts, newFilename].join("/");
      counter++;
    }
    await this.app.vault.create(filePath, content);
    return filePath;
  }
  async promptConflictResolution(file) {
    const modal = new FileConflictModal(this.app, file);
    const decision = await modal.openAndWait();
    return decision;
  }
  async createVersionedCopy(originalPath, content) {
    const pathParts = originalPath.split("/");
    const filename = pathParts.pop();
    const nameWithoutExt = filename.replace(".md", "");
    let counter = 1;
    let candidatePath;
    do {
      candidatePath = [...pathParts, `${nameWithoutExt} (${counter}).md`].join("/");
      counter++;
    } while (this.fileExists(candidatePath));
    await this.app.vault.create(candidatePath, content);
    return candidatePath;
  }
  normalizePath(path) {
    if (!path) {
      return "";
    }
    let normalized = path.trim();
    if (normalized.startsWith("./")) {
      normalized = normalized.slice(2);
    }
    while (normalized.startsWith("/")) {
      normalized = normalized.slice(1);
    }
    normalized = normalized.replace(/\/+/g, "/");
    return normalized;
  }
};

// src/services/prompt-service.ts
var _AIPromptService = class _AIPromptService {
  /**
   * Create analysis prompt for YouTube video content with performance optimization
   */
  createAnalysisPrompt(videoData, videoUrl, format = "detailed-guide", customPrompt, performanceMode = "balanced") {
    if (customPrompt && customPrompt.trim()) {
      return this.applyCustomPrompt(customPrompt, videoData, videoUrl);
    }
    let baseTemplate;
    switch (performanceMode) {
      case "fast":
        baseTemplate = _AIPromptService.COMPACT_BASE_TEMPLATE;
        break;
      case "quality":
        baseTemplate = _AIPromptService.COMPREHENSIVE_BASE_TEMPLATE;
        break;
      default:
        baseTemplate = _AIPromptService.BALANCED_BASE_TEMPLATE;
    }
    const baseContent = baseTemplate.replace("{{TITLE}}", videoData.title).replace("{{URL}}", videoUrl).replace("{{DESCRIPTION}}", videoData.description);
    switch (format) {
      case "executive-summary":
        return this.createExecutiveSummaryPrompt(baseContent, videoUrl, performanceMode);
      case "brief":
        return this.createBriefPrompt(baseContent, videoUrl, performanceMode);
      case "detailed-guide":
      default:
        return this.createDetailedGuidePrompt(baseContent, videoUrl, performanceMode);
    }
  }
  /**
   * Apply custom prompt template with placeholder substitution
   */
  applyCustomPrompt(customPrompt, videoData, videoUrl) {
    const videoId = ValidationUtils.extractVideoId(videoUrl);
    const embedUrl = videoId ? `https://www.youtube-nocookie.com/embed/${videoId}` : videoUrl;
    return customPrompt.replace(/__VIDEO_TITLE__/g, videoData.title || "Unknown Video").replace(/__VIDEO_DESCRIPTION__/g, videoData.description || "No description available").replace(/__VIDEO_URL__/g, videoUrl).replace(/__VIDEO_ID__/g, videoId || "unknown").replace(/__EMBED_URL__/g, embedUrl).replace(/__DATE__/g, (/* @__PURE__ */ new Date()).toISOString().split("T")[0]).replace(/__TIMESTAMP__/g, (/* @__PURE__ */ new Date()).toISOString());
  }
  /**
   * Create a brief prompt: short description plus resources list
   */
  createBriefPrompt(baseContent, videoUrl, performanceMode = "balanced") {
    const videoId = ValidationUtils.extractVideoId(videoUrl);
    const embedUrl = videoId ? `https://www.youtube-nocookie.com/embed/${videoId}` : videoUrl;
    return `${baseContent}

        OUTPUT FORMAT - BRIEF DESCRIPTION + RESOURCES:

        Use this EXACT template:

        ---
        title: {Video Title}
        source: ${videoUrl}
        created: "${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}"
        modified: "${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}"
        description: "One short paragraph (3-4 sentences) summarizing the video"
        type: youtube-note
        format: brief
        tags:
          - youtube
          - brief
        status: processed
        duration: "[Extract video duration]"
        channel: "[Extract channel name]"
        video_id: "${videoId || "unknown"}"
        processing_date: "${(/* @__PURE__ */ new Date()).toISOString()}"
    ai_provider: "__AI_PROVIDER__"
    ai_model: "__AI_MODEL__"
        ---

        <iframe width="640" height="360" src="${embedUrl}" title="{Video Title}" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

        ---

        ## Brief Description
        [Provide a concise 3-4 sentence description that captures the core message of the video]

        ## Key Takeaways
        - **[Takeaway 1]**: [Core insight or lesson from the video]
        - **[Takeaway 2]**: [Core insight or lesson from the video]
        - **[Takeaway 3]**: [Core insight or lesson from the video]

        ## Quick Actions
        1. **[Immediate Action]**: [Specific action you can take right away]
        2. **[Next Step]**: [Follow-up action to apply what you learned]

        ## Resources
        - **Original Video:** [Watch on YouTube](${videoUrl})
        - **Channel:** [Creator's Channel](https://youtube.com/channel/[extract-channel-id])
        - **Top resources mentioned or related (links):**
          - [Resource 1]
          - [Resource 2]
          - [Resource 3]

        IMPORTANT: Keep the Brief Description short and focused. Provide 2-3 high-quality resource links that help the reader explore the topic further. Action items should be simple and immediately applicable.`;
  }
  /**
   * Create executive summary prompt (250 words, tech/developer focused)
   */
  createExecutiveSummaryPrompt(baseContent, videoUrl, performanceMode = "balanced") {
    const videoId = ValidationUtils.extractVideoId(videoUrl);
    const embedUrl = videoId ? `https://www.youtube-nocookie.com/embed/${videoId}` : videoUrl;
    const modeMap = {
      "fast": "Fast Mode: transcript only",
      "balanced": "Balanced Mode: transcript + primary visuals",
      "quality": "Quality Mode: full multimodal analysis (audio, visuals, diagrams, slides, demonstrations)"
    };
    const processingMode = modeMap[performanceMode] || modeMap["balanced"];
    return `## \u{1F3AF} YouTube \u2192 Obsidian Executive Summary Prompt (Tech/Developer Focus)

**ROLE:**
You are an expert technical analyst and executive summarizer. Your task is to extract high-value strategic insights from a technology-focused YouTube video and produce a concise, structured note for Obsidian.

---

Use this EXACT template:

---
title: {{TITLE}}
source: ${videoUrl}
created: "${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}"
modified: "${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}"
description: "Single sentence capturing the core insight"
type: youtube-note
format: executive-summary
tags:
  - youtube
  - executive-summary
  - technology
  - strategy
status: processed
duration: "[Extract video duration]"
channel: "[Extract channel name]"
video_id: "${videoId || "unknown"}"
processing_date: "${(/* @__PURE__ */ new Date()).toISOString()}"
word_count: 250
ai_provider: "__AI_PROVIDER__"
ai_model: "__AI_MODEL__"
---

<div style="text-align: center; margin-bottom: 24px;">
<iframe width="640" height="360" src="${embedUrl}" title="{{TITLE}}" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</div>

---

# \u{1F4CA} Executive Summary

The video discusses [explain the main problem/opportunity and the central argument of the video].

Key concepts include [summarize the most important concepts, frameworks, or differentiators that create impact].

To implement these insights, [provide recommendations, risks, and priority actions based on the insights].

> **\u{1F4A1} Focus:** Strategic value over narrative recap - prioritize actionable insights.

---

## \u{1F3AF} Key Strategic Insights

### \u{1F527} Technical Strategy
**[Critical insight with specific business impact and example from video]**

### \u{1F4A1} Design Thinking
**[Critical insight with specific business impact and example from video]**

### \u{1F4DA} Continuous Learning
**[Critical insight with specific business impact and example from video]**

> *Optional: Add 4\u20135 additional insights if they provide significant value.*

---

## \u{1F680} Action Plan & Implementation

### \u26A1 Immediate (0-30 days)
- **Action:** [Specific, measurable action]
- **Success Metric:** [Clear success criteria]

### \u{1F4C8} Short-term (1-3 months)
- **Action:** [Specific, measurable action]
- **Success Metric:** [Clear success criteria]

### \u{1F3AF} Mid-term (3-6 months)
- **Action:** [Specific, measurable action]
- **Success Metric:** [Clear success criteria]

### \u{1F52E} Long-term (6+ months)
- **Action:** [Specific, measurable action]
- **Success Metric:** [Clear success criteria]

> **\u2705 Requirement:** Each action item must include clear, measurable success criteria.

---

## \u{1F4DA} Curated Resources & References

### \u{1F3A5} Primary Sources
- **Original Video:** [Watch on YouTube](${videoUrl})
- **Channel:** [Creator's Channel](https://youtube.com/channel/[extract-channel-id])

### \u{1F6E0}\uFE0F Key Tools & Technologies
- [List main tools, frameworks, or technologies mentioned]

### \u{1F4D6} Official Documentation
- [Links to official documentation for mentioned technologies]

### \u{1F31F} Further Reading
- [1-2 high-quality related articles or resources for deep dive]

---

### Non-Negotiable Rules

- Executive Summary \u2264 250 words
- Insights & action items must reference the video
- Focus on strategy and developer/business value
- Avoid fluff and storytelling\u2014prioritize usable analysis

---

### Suggested Prompt Invocation

Analyze this YouTube video in **${processingMode}**:
Title: {{TITLE}}
URL: ${videoUrl}
Description: {{DESCRIPTION}}
Return a structured Obsidian-ready note with strategic insights and developer-aligned action steps.`;
  }
  /**
   * Create detailed guide prompt
   */
  createDetailedGuidePrompt(baseContent, videoUrl, performanceMode = "balanced") {
    const videoId = ValidationUtils.extractVideoId(videoUrl);
    const embedUrl = videoId ? `https://www.youtube-nocookie.com/embed/${videoId}` : videoUrl;
    return `${baseContent}

        OUTPUT FORMAT - EFFICIENT STEP-BY-STEP TUTORIAL:

        Create a concise step-by-step tutorial following this structure:

        ---
        title: {{TITLE}}
        source: ${videoUrl}
        created: "${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}"
        type: youtube-tutorial
        format: step-by-step
        tags: [youtube, tutorial, implementation, practical]
        status: processed
        channel: "[Extract channel name]"
        video_id: "${videoId || "unknown"}"
        ai_provider: "__AI_PROVIDER__"
        ai_model: "__AI_MODEL__"
        ---

        <div style="text-align: center; margin-bottom: 24px;">
        <iframe width="640" height="360" src="${embedUrl}" title="{{TITLE}}" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
        </div>

        ---

        # [Title] - Practical Tutorial

        ## Overview
        **Goal:** [Main learning objective]
        **Duration:** [Estimated time]
        **Level:** [Difficulty]

        **Video:** [{{TITLE}}](${videoUrl})

        ## Prerequisites
        - [Requirement 1]
        - [Requirement 2]
        - [Requirement 3]

        ## Step-by-Step Guide

        ### Step 1: [Action/Setup]
        **Objective:** [Clear goal]

        **Actions:**
        1. [Specific instruction]
        2. [Follow-up instruction]
        3. [Verification step]

        \u2705 **Success:** [How to confirm it worked]

        ### Step 2: [Core Implementation]
        **Objective:** [Clear goal]

        [Continue with remaining steps...]

        ### Step 3: [Final Touches]
        **Objective:** [Clear goal]

        ## Learning Outcomes
        Upon completion, you will:
- [Achieved skill 1]
- [Achieved skill 2]
- [Achieved skill 3]

        ## Required Tools
        - **[Tool/Resource 1]:** [Where to get it]
        - **[Tool/Resource 2]:** [Where to get it]

        ## Pro Tips
        \u{1F4A1} **Tip 1:** [Key insight from video]
        \u{1F4A1} **Tip 2:** [Best practice]
        \u26A0\uFE0F **Avoid:** [Common mistake]

        ## Verification
        **Final Check:** [How to verify complete success]
        **Expected Result:** [What you should see/accomplish]

              *Generated from YouTube video content*`;
  }
  /**
   * Process AI response and inject provider information
   */
  processAIResponse(content, provider, model, format) {
    if (!content) {
      return content;
    }
    const providerValue = provider || "unknown";
    const modelValue = model || "unknown";
    let updatedContent = content.replace(/__AI_PROVIDER__/g, providerValue).replace(/__AI_MODEL__/g, modelValue);
    updatedContent = this.ensureFrontMatterValue(updatedContent, "ai_provider", providerValue);
    updatedContent = this.ensureFrontMatterValue(updatedContent, "ai_model", modelValue);
    return updatedContent;
  }
  ensureFrontMatterValue(content, key, value) {
    const pattern = new RegExp(`(${key}\\s*:\\s*)(["'])?([^"'\\n]*)(["'])?`, "i");
    if (pattern.test(content)) {
      return content.replace(pattern, (_, prefix, openingQuote, _existing, closingQuote) => {
        const quote = openingQuote || closingQuote ? '"' : "";
        return `${prefix}${quote}${value}${quote}`;
      });
    }
    if (content.startsWith("---")) {
      return content.replace(/^---\s*\n/, `---
${key}: "${value}"
`);
    }
    return content;
  }
  /**
   * Create a summary prompt for shorter content
   */
  createSummaryPrompt(videoData, videoUrl) {
    return `Create a concise summary for this YouTube video:

        Title: ${videoData.title}
        URL: ${videoUrl}
        Description: ${videoData.description}

        Please provide:
        1. A 2-paragraph summary (max 250 words)
        2. 3-5 key takeaways
        3. Main actionable insights

        Format as markdown with clear headings.`;
  }
  /**
   * Validate prompt length and content
   */
  validatePrompt(prompt) {
    return Boolean(prompt) && typeof prompt === "string" && prompt.trim().length > 10 && prompt.length < 5e4;
  }
};
// Optimized prompt templates for different performance modes
_AIPromptService.COMPACT_BASE_TEMPLATE = `Analyze this YouTube video:
Title: {{TITLE}}
URL: {{URL}}
Description: {{DESCRIPTION}}

Focus on extracting the key information and insights.`;
_AIPromptService.BALANCED_BASE_TEMPLATE = `Analyze this YouTube video with multimodal analysis:
Title: {{TITLE}}
URL: {{URL}}
Description: {{DESCRIPTION}}

Extract insights from both spoken content and visual elements, focusing on practical information.`;
_AIPromptService.COMPREHENSIVE_BASE_TEMPLATE = `Analyze this YouTube video using comprehensive multimodal analysis:
Title: {{TITLE}}
URL: {{URL}}
Description: {{DESCRIPTION}}

MULTIMODAL ANALYSIS INSTRUCTIONS:
1. Watch the complete video using both audio and visual analysis capabilities
2. Extract insights from spoken content, music, sound effects, and ambient audio
3. Analyze visual elements including slides, diagrams, charts, body language, and demonstrations
4. Focus on practical, action-oriented information with specific examples
5. Maintain accuracy and cite specific examples from the video when relevant`;
var AIPromptService = _AIPromptService;

// src/services/cache/memory-cache.ts
var MemoryCacheService = class {
  constructor() {
    this.cache = /* @__PURE__ */ new Map();
    this.defaultTTL = 3e5;
    // 5 minutes
    this.lastCleanup = 0;
    this.CLEANUP_INTERVAL = 6e4;
  }
  // 1 minute
  /**
   * Get item from cache (optimized with lazy cleanup)
   */
  get(key) {
    var _a;
    if (this.cache.size > 50) {
      this.cleanup();
    }
    const item = this.cache.get(key);
    if (!item)
      return null;
    const ttl = (_a = item.ttl) != null ? _a : this.defaultTTL;
    if (Date.now() - item.timestamp > ttl) {
      this.cache.delete(key);
      return null;
    }
    return item.data;
  }
  /**
   * Set item in cache
   */
  set(key, data, ttl) {
    this.cache.set(key, {
      data,
      timestamp: Date.now(),
      ttl
    });
  }
  /**
   * Clear all cache items
   */
  clear() {
    this.cache.clear();
  }
  /**
   * Delete specific cache item
   */
  delete(key) {
    return this.cache.delete(key);
  }
  /**
   * Check if key exists in cache
   */
  has(key) {
    var _a;
    const item = this.cache.get(key);
    if (!item) {
      return false;
    }
    const ttl = (_a = item.ttl) != null ? _a : this.defaultTTL;
    if (Date.now() - item.timestamp > ttl) {
      this.cache.delete(key);
      return false;
    }
    return true;
  }
  /**
   * Get cache size
   */
  size() {
    return this.cache.size;
  }
  /**
   * Clean up expired items (optimized with batched operations)
   */
  cleanup() {
    var _a;
    const now = Date.now();
    if (now - this.lastCleanup < this.CLEANUP_INTERVAL)
      return;
    this.lastCleanup = now;
    const expiredKeys = [];
    for (const [key, item] of this.cache.entries()) {
      const ttl = (_a = item.ttl) != null ? _a : this.defaultTTL;
      if (now - item.timestamp > ttl) {
        expiredKeys.push(key);
      }
    }
    expiredKeys.forEach((key) => this.cache.delete(key));
  }
};

// src/services/service-container.ts
var ServiceContainer = class {
  constructor(settings, app) {
    this.settings = settings;
    this.app = app;
  }
  get aiService() {
    if (!this._aiService) {
      const providers = [];
      if (this.settings.geminiApiKey) {
        providers.push(new GeminiProvider(this.settings.geminiApiKey));
      }
      if (this.settings.groqApiKey) {
        providers.push(new GroqProvider(this.settings.groqApiKey));
      }
      providers.push(new OllamaProvider(this.settings.ollamaApiKey || ""));
      this._aiService = new AIService(providers, this.settings);
    }
    return this._aiService;
  }
  get videoService() {
    if (!this._videoService) {
      this._videoService = new YouTubeVideoService(this.cacheService);
    }
    return this._videoService;
  }
  get fileService() {
    if (!this._fileService) {
      this._fileService = new ObsidianFileService(this.app);
    }
    return this._fileService;
  }
  get cacheService() {
    if (!this._cacheService) {
      this._cacheService = new MemoryCacheService();
    }
    return this._cacheService;
  }
  get promptService() {
    if (!this._promptService) {
      this._promptService = new AIPromptService();
    }
    return this._promptService;
  }
  /**
   * Update settings and refresh services that depend on them
   */
  async updateSettings(newSettings) {
    this.settings = newSettings;
    this._aiService = void 0;
  }
  /**
   * Clear all cached services
   */
  clearServices() {
    this._aiService = void 0;
    this._videoService = void 0;
    this._fileService = void 0;
    this._cacheService = void 0;
    this._promptService = void 0;
  }
};

// src/main.ts
var PLUGIN_PREFIX = "ytp";
var PLUGIN_VERSION = "1.3.5";
var DEFAULT_SETTINGS = {
  geminiApiKey: "",
  groqApiKey: "",
  ollamaApiKey: "",
  // Add Ollama API key
  outputPath: "YouTube/Processed Videos",
  useEnvironmentVariables: false,
  environmentPrefix: "YTC",
  performanceMode: "balanced",
  enableParallelProcessing: true,
  preferMultimodal: true,
  defaultMaxTokens: 4096,
  // Good balance for Gemini video processing
  defaultTemperature: 0.5
  // Balanced creativity vs consistency
};
var YoutubeClipperPlugin = class extends import_obsidian8.Plugin {
  constructor() {
    super(...arguments);
    this.settings = DEFAULT_SETTINGS;
    this.isUnloading = false;
    this.operationCount = 0;
  }
  async onload() {
    this.manifest.version = PLUGIN_VERSION;
    logger.info(`Initializing YoutubeClipper Plugin v${PLUGIN_VERSION}...`);
    try {
      await this.loadSettings();
      this.setupLogger();
      await this.initializeServices();
      this.registerUIComponents();
      this.setupUrlHandling();
      this.setupProtocolHandler();
      logger.plugin("Plugin loaded successfully");
    } catch (error) {
      logger.error("Failed to load plugin", "Plugin", {
        error: error instanceof Error ? error.message : String(error)
      });
      ErrorHandler.handle(error, "Plugin initialization");
      new import_obsidian8.Notice("Failed to load YoutubeClipper Plugin. Check console for details.");
    }
  }
  onunload() {
    var _a, _b, _c;
    logger.plugin("Unloading YoutubeClipper Plugin...");
    this.isUnloading = true;
    try {
      (_a = this.urlHandler) == null ? void 0 : _a.clear();
      (_b = this.modalManager) == null ? void 0 : _b.clear();
      (_c = this.serviceContainer) == null ? void 0 : _c.clearServices();
      this.cleanupUIElements();
      ConflictPrevention.cleanupAllElements();
      logger.plugin("Plugin unloaded successfully");
    } catch (error) {
      logger.error("Error during plugin unload", "Plugin", {
        error: error instanceof Error ? error.message : String(error)
      });
    }
  }
  setupLogger() {
    const isDev = true;
    logger.updateConfig({
      level: isDev ? 0 /* DEBUG */ : 1 /* INFO */,
      enableConsole: true,
      enableFile: false,
      maxLogEntries: 1e3
    });
  }
  async initializeServices() {
    this.serviceContainer = new ServiceContainer(this.settings, this.app);
    this.modalManager = new ModalManager();
    this.urlHandler = new UrlHandler(
      this.app,
      this.settings,
      this.handleUrlDetection.bind(this)
    );
  }
  setupUrlHandling() {
    if (!this.urlHandler)
      return;
    this.registerEvent(this.app.vault.on("create", (file) => {
      if (file instanceof import_obsidian8.TFile) {
        this.safeOperation(() => this.urlHandler.handleFileCreate(file), "Handle file create");
      }
    }));
    this.registerEvent(this.app.workspace.on("active-leaf-change", () => {
      this.safeOperation(() => this.urlHandler.handleActiveLeafChange(), "Handle active leaf change");
    }));
  }
  setupProtocolHandler() {
    var _a;
    try {
      (_a = this.registerObsidianProtocolHandler) == null ? void 0 : _a.call(this, "youtube-clipper", (params) => {
        var _a2;
        (_a2 = this.urlHandler) == null ? void 0 : _a2.handleProtocol(params);
      });
    } catch (error) {
      logger.debug("Protocol handler not available", "Plugin");
    }
  }
  registerUIComponents() {
    this.ribbonIcon = this.addRibbonIcon("film", "Process YouTube Video", () => {
      void this.safeShowUrlModal();
    });
    logger.plugin("Ribbon icon set successfully");
    this.addCommand({
      id: `${PLUGIN_PREFIX}-process-youtube-video`,
      name: "Process YouTube Video",
      callback: () => {
        void this.safeShowUrlModal();
      }
    });
    this.addSettingTab(new YouTubeSettingsTab(this.app, {
      plugin: this,
      onSettingsChange: this.handleSettingsChange.bind(this)
    }));
    this.addCommand({
      id: `${PLUGIN_PREFIX}-open-url-from-clipboard`,
      name: "YouTube Clipper: Open URL Modal (from clipboard)",
      callback: async () => {
        await this.handleClipboardUrl();
      }
    });
  }
  cleanupUIElements() {
    if (this.ribbonIcon) {
      this.ribbonIcon.remove();
      this.ribbonIcon = null;
    }
  }
  handleUrlDetection(result) {
    logger.info("URL detected, opening modal", "Plugin", {
      url: result.url,
      source: result.source,
      filePath: result.filePath
    });
    void this.safeShowUrlModal(result.url);
  }
  async handleClipboardUrl() {
    try {
      if (!this.urlHandler)
        return;
      await this.urlHandler.handleClipboardUrl();
      const manual = window.prompt("Paste YouTube URL to open in YouTube Clipper:");
      if (manual && ValidationUtils.isValidYouTubeUrl(manual.trim())) {
        void this.safeShowUrlModal(manual.trim());
      } else {
        new import_obsidian8.Notice("No valid YouTube URL provided.");
      }
    } catch (error) {
      ErrorHandler.handle(error, "Open URL from clipboard");
    }
  }
  async safeShowUrlModal(initialUrl) {
    if (!this.modalManager || !this.serviceContainer)
      return;
    await this.safeOperation(async () => {
      return this.modalManager.openModal(
        initialUrl,
        () => this.openYouTubeUrlModal(initialUrl),
        () => {
          logger.debug("Modal closed", "Plugin", { url: initialUrl });
        }
      );
    }, "Show URL Modal");
  }
  async openYouTubeUrlModal(initialUrl) {
    if (this.isUnloading) {
      ConflictPrevention.log("Plugin is unloading, ignoring modal request");
      return;
    }
    ConflictPrevention.safeOperation(async () => {
      if (!this.serviceContainer)
        return;
      const aiService = this.serviceContainer.aiService;
      const providers = aiService ? aiService.getProviderNames() : [];
      const modelOptionsMap = this.settings.modelOptionsCache || {};
      if (aiService && (!this.settings.modelOptionsCache || Object.keys(this.settings.modelOptionsCache).length === 0)) {
        for (const provider of providers) {
          modelOptionsMap[provider] = aiService.getProviderModels(provider) || [];
        }
      }
      const modal = new YouTubeUrlModal(this.app, {
        onProcess: this.processYouTubeVideo.bind(this),
        onOpenFile: this.openFileByPath.bind(this),
        ...initialUrl && { initialUrl },
        providers,
        defaultProvider: "Google Gemini",
        // Prefer Gemini as default provider
        defaultModel: "gemini-2.5-pro",
        // Use the latest Gemini model
        defaultMaxTokens: this.settings.defaultMaxTokens,
        defaultTemperature: this.settings.defaultTemperature,
        modelOptions: modelOptionsMap,
        fetchModels: async () => {
          try {
            const map = await this.serviceContainer.aiService.fetchLatestModels();
            this.settings.modelOptionsCache = map;
            await this.saveSettings();
            return map;
          } catch (error) {
            return modelOptionsMap;
          }
        },
        performanceMode: this.settings.performanceMode || "balanced",
        enableParallelProcessing: this.settings.enableParallelProcessing || false,
        preferMultimodal: this.settings.preferMultimodal || false,
        onPerformanceSettingsChange: async (performanceMode, enableParallel, preferMultimodal) => {
          this.settings.performanceMode = performanceMode;
          this.settings.enableParallelProcessing = enableParallel;
          this.settings.preferMultimodal = preferMultimodal;
          await this.saveSettings();
          this.serviceContainer = new ServiceContainer(this.settings, this.app);
        }
      });
      modal.open();
    }, "YouTube URL Modal").catch((error) => {
      ErrorHandler.handle(error, "Opening YouTube URL modal");
    });
  }
  async processYouTubeVideo(url, format = "detailed-guide", providerName, model, customPrompt, performanceMode, enableParallel, preferMultimodal, maxTokens, temperature) {
    if (this.isUnloading) {
      ConflictPrevention.log("Plugin is unloading, cancelling video processing");
      throw new Error("Plugin is shutting down");
    }
    const result = await ConflictPrevention.safeOperation(async () => {
      var _a, _b;
      new import_obsidian8.Notice(MESSAGES.PROCESSING);
      const validation = ValidationUtils.validateSettings(this.settings);
      if (!validation.isValid) {
        throw new Error(`Configuration invalid: ${validation.errors.join(", ")}`);
      }
      if (!this.serviceContainer)
        throw new Error("Service container not initialized");
      const youtubeService = this.serviceContainer.videoService;
      const aiService = this.serviceContainer.aiService;
      const fileService = this.serviceContainer.fileService;
      const promptService = this.serviceContainer.promptService;
      const videoId = youtubeService.extractVideoId(url);
      if (!videoId) {
        throw new Error(MESSAGES.ERRORS.VIDEO_ID_EXTRACTION);
      }
      const videoData = await youtubeService.getVideoData(videoId);
      let promptToUse;
      if (format === "custom") {
        promptToUse = customPrompt;
      } else {
        promptToUse = (_a = this.settings.customPrompts) == null ? void 0 : _a[format];
      }
      const prompt = promptService.createAnalysisPrompt(videoData, url, format, promptToUse);
      logger.aiService("Processing video", {
        videoId,
        format,
        provider: providerName || "Auto",
        model: model || "Default",
        maxTokens: maxTokens || 2048,
        temperature: temperature || 0.7
      });
      const providers = aiService.providers || [];
      for (const provider of providers) {
        if (maxTokens && provider.setMaxTokens) {
          provider.setMaxTokens(maxTokens);
        }
        if (temperature !== void 0 && provider.setTemperature) {
          provider.setTemperature(temperature);
        }
      }
      let aiResponse;
      try {
        if (providerName) {
          aiResponse = await aiService.processWith(providerName, prompt, model, void 0);
        } else {
          aiResponse = await aiService.process(prompt);
        }
        logger.aiService("AI Response received", {
          provider: aiResponse.provider,
          model: aiResponse.model,
          contentLength: ((_b = aiResponse.content) == null ? void 0 : _b.length) || 0
        });
      } catch (error) {
        logger.error("AI Processing failed", "Plugin", {
          error: error instanceof Error ? error.message : String(error)
        });
        if (error instanceof Error) {
          ErrorHandler.handleEnhanced(error, "AI Processing");
        }
        throw error;
      }
      const formattedContent = promptService.processAIResponse(
        aiResponse.content,
        aiResponse.provider,
        aiResponse.model,
        format,
        videoData,
        url
      );
      const filePath = await fileService.saveToFile(
        videoData.title,
        formattedContent,
        this.settings.outputPath
      );
      new import_obsidian8.Notice(MESSAGES.SUCCESS(videoData.title));
      return filePath;
    }, "YouTube Video Processing");
    if (!result) {
      throw new Error("Failed to process YouTube video");
    }
    return result;
  }
  async openFileByPath(filePath) {
    try {
      await new Promise((resolve) => setTimeout(resolve, 300));
      const cleanPath = filePath.startsWith("/") ? filePath.substring(1) : filePath;
      const file = this.app.vault.getAbstractFileByPath(cleanPath);
      if (!file || !(file instanceof import_obsidian8.TFile)) {
        throw new Error(`File not found at path: ${cleanPath}`);
      }
      await this.openFileInNewTab(file);
    } catch (error) {
      ErrorHandler.handle(error, "Opening file by path");
      throw error;
    }
  }
  async openFileInNewTab(file) {
    try {
      const leaf = this.app.workspace.getLeaf("tab");
      await leaf.openFile(file);
      this.app.workspace.setActiveLeaf(leaf);
      new import_obsidian8.Notice(`\u{1F4C2} Opened: ${file.name}`);
    } catch (error) {
      try {
        const currentLeaf = this.app.workspace.getLeaf(false);
        await currentLeaf.openFile(file);
        new import_obsidian8.Notice(`\u{1F4C2} Opened: ${file.name}`);
      } catch (fallbackError) {
        ErrorHandler.handle(fallbackError, "Opening file in current tab");
        new import_obsidian8.Notice(`Note saved as "${file.name}" but could not auto-open. Please open manually.`);
      }
    }
  }
  showPersistentSaveConfirmation(file) {
    try {
      const modal = new SaveConfirmationModal(this.app, file, (shouldOpen) => {
        if (shouldOpen) {
          void this.openFileInNewTab(file);
        }
      });
      modal.open();
    } catch (error) {
      ErrorHandler.handle(error, "Showing save confirmation");
      new import_obsidian8.Notice(`File saved: ${file.name}. Click to open.`, 0).noticeEl.onclick = () => {
        void this.openFileInNewTab(file);
      };
    }
  }
  async handleSettingsChange(newSettings) {
    var _a, _b;
    try {
      this.settings = { ...newSettings };
      await this.saveSettings();
      await ((_a = this.serviceContainer) == null ? void 0 : _a.updateSettings(this.settings));
      (_b = this.urlHandler) == null ? void 0 : _b.updateSettings(this.settings);
    } catch (error) {
      ErrorHandler.handle(error, "Settings update");
      throw error;
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async safeOperation(operation, operationName) {
    if (this.isUnloading) {
      logger.warn(`Attempted ${operationName} during plugin unload - skipping`, "Plugin");
      return null;
    }
    const opId = ++this.operationCount;
    logger.info(`Starting operation ${opId}: ${operationName}`, "Plugin");
    try {
      const result = await operation();
      logger.info(`Completed operation ${opId}: ${operationName}`, "Plugin");
      return result;
    } catch (error) {
      logger.error(`Failed operation ${opId}: ${operationName}`, "Plugin", {
        error: error instanceof Error ? error.message : String(error)
      });
      ErrorHandler.handle(error, operationName);
      return null;
    }
  }
  getServiceContainer() {
    return this.serviceContainer;
  }
  // Expose services for testing and external access
  getUrlHandler() {
    return this.urlHandler;
  }
  getModalManager() {
    return this.modalManager;
  }
  // Public method to get current settings
  getCurrentSettings() {
    return { ...this.settings };
  }
};
